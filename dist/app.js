// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = (id) => {
  return import.meta.require(id);
};

// node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = new Uint16Array('\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\uD835\uDD04rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\uD835\uDD38plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\uD835\uDC9Cign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\uD835\uDD05pf;\uC000\uD835\uDD39eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\uD835\uDC9Ep\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\uD835\uDD07\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\uD835\uDD3B\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\uD835\uDC9Frok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\uD835\uDD08rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\uD835\uDD3Csilon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\uD835\uDD09lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\uD835\uDD3DAll;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\uD835\uDD0A;\u62D9pf;\uC000\uD835\uDD3Eeater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\uD835\uDCA2;\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\uD835\uDD40a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\uD835\uDD0Dpf;\uC000\uD835\uDD41\u01E3\u07C7\0\u07CCr;\uC000\uD835\uDCA5rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\uD835\uDD0Epf;\uC000\uD835\uDD42cr;\uC000\uD835\uDCA6\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\uD835\uDD0F\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\uD835\uDD43er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\uD835\uDD10nusPlus;\u6213pf;\uC000\uD835\uDD44c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\uD835\uDD11\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\uD835\uDCA9ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\uD835\uDD12rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\uD835\uDD46enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\uD835\uDCAAash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\uD835\uDD13i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\uD835\uDCAB;\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\uD835\uDD14pf;\u611Acr;\uC000\uD835\uDCAC\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\uD835\uDD16ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\uD835\uDD4A\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\uD835\uDCAEar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\uD835\uDD17\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\uD835\uDD4BipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\uD835\uDCAFrok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\uD835\uDD18rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\uD835\uDD4C\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\uD835\uDCB0ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\uD835\uDD19pf;\uC000\uD835\uDD4Dcr;\uC000\uD835\uDCB1dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\uD835\uDD1Apf;\uC000\uD835\uDD4Ecr;\uC000\uD835\uDCB2\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\uD835\uDD1B;\u439Epf;\uC000\uD835\uDD4Fcr;\uC000\uD835\uDCB3\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\uD835\uDD1Cpf;\uC000\uD835\uDD50cr;\uC000\uD835\uDCB4ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\uD835\uDCB5\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\uD835\uDD1Erave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\uD835\uDD52\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\uD835\uDCB6;\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\uD835\uDD1Fg\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\uD835\uDD53\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\uD835\uDCB7mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\uD835\uDD20\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\uD835\uDD54o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\uD835\uDCB8\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\uD835\uDD21ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\uD835\uDD55\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\uD835\uDCB9;\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\uD835\uDD22\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\uD835\uDD56\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\uD835\uDD23lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\uD835\uDD57\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\uD835\uDCBB\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\uD835\uDD24\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\uD835\uDD58\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\uD835\uDD25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\uD835\uDD59bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\uD835\uDCBDas\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\uD835\uDD26rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\uD835\uDD5Aa;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\uD835\uDCBEn\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\uD835\uDD27ath;\u4237pf;\uC000\uD835\uDD5B\u01E3\u23EC\0\u23F1r;\uC000\uD835\uDCBFrcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\uD835\uDD28reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\uD835\uDD5Ccr;\uC000\uD835\uDCC0\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\uD835\uDD29\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\uD835\uDD5Dus;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\uD835\uDCC1m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\uD835\uDD2Ao;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\uD835\uDD5E\u0100ct\u28F8\u28FDr;\uC000\uD835\uDCC2pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\uD835\uDD2B\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\uD835\uDD5F\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\uD835\uDCC3ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\uD835\uDD2C\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\uD835\uDD60\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\uD835\uDD2D\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\uD835\uDD61nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\uD835\uDCC5;\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\uD835\uDD2Epf;\uC000\uD835\uDD62rime;\u6057cr;\uC000\uD835\uDCC6\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\uD835\uDD2F\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\uD835\uDD63us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\uD835\uDCC7\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\uD835\uDD30\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\uD835\uDD64a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\uD835\uDCC8tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\uD835\uDD31\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\uD835\uDD65rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\uD835\uDCC9;\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\uD835\uDD32rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\uD835\uDD66\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\uD835\uDCCA\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\uD835\uDD33tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\uD835\uDD67ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\uD835\uDCCB\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\uD835\uDD34pf;\uC000\uD835\uDD68\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\uD835\uDCCC\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\uD835\uDD35\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\uD835\uDD69im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\uD835\uDCCD\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\uD835\uDD36cy;\u4457pf;\uC000\uD835\uDD6Acr;\uC000\uD835\uDCCE\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\uD835\uDD37cy;\u4436grarr;\u61DDpf;\uC000\uD835\uDD6Bcr;\uC000\uD835\uDCCF\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(function(c) {
    return c.charCodeAt(0);
  }));
});

// node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = new Uint16Array("\u0200aglq\t\x15\x18\x1B\u026D\x0F\0\0\x12p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function(c) {
    return c.charCodeAt(0);
  }));
});

// node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS((exports) => {
  var replaceCodePoint = function(codePoint) {
    var _a2;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== undefined ? _a2 : codePoint;
  };
  var decodeCodePoint = function(codePoint) {
    return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.replaceCodePoint = exports.fromCodePoint = undefined;
  var decodeMap = new Map([
    [0, 65533],
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  exports.fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== undefined ? _a : function(codePoint) {
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
  exports.replaceCodePoint = replaceCodePoint;
  exports.default = decodeCodePoint;
});

// node_modules/entities/lib/decode.js
var require_decode = __commonJS((exports) => {
  var isNumber = function(code) {
    return code >= CharCodes.ZERO && code <= CharCodes.NINE;
  };
  var isHexadecimalCharacter = function(code) {
    return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
  };
  var isAsciiAlphaNumeric = function(code) {
    return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
  };
  var isEntityInAttributeInvalidEnd = function(code) {
    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
  };
  var getDecoder = function(decodeTree) {
    var ret = "";
    var decoder = new EntityDecoder(decodeTree, function(str) {
      return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
    });
    return function decodeWithTrie(str, decodeMode) {
      var lastIndex = 0;
      var offset = 0;
      while ((offset = str.indexOf("&", offset)) >= 0) {
        ret += str.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        var len = decoder.write(str, offset + 1);
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      var result = ret + str.slice(lastIndex);
      ret = "";
      return result;
    };
  };
  var determineBranch = function(decodeTree, current, nodeIdx, char) {
    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      var value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    var lo = nodeIdx;
    var hi = lo + branchCount - 1;
    while (lo <= hi) {
      var mid = lo + hi >>> 1;
      var midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  };
  var decodeHTML = function(str, mode) {
    if (mode === undefined) {
      mode = DecodingMode.Legacy;
    }
    return htmlDecoder(str, mode);
  };
  var decodeHTMLAttribute = function(str) {
    return htmlDecoder(str, DecodingMode.Attribute);
  };
  var decodeHTMLStrict = function(str) {
    return htmlDecoder(str, DecodingMode.Strict);
  };
  var decodeXML = function(str) {
    return xmlDecoder(str, DecodingMode.Strict);
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = undefined;
  var decode_data_html_js_1 = __importDefault(require_decode_data_html());
  exports.htmlDecodeTree = decode_data_html_js_1.default;
  var decode_data_xml_js_1 = __importDefault(require_decode_data_xml());
  exports.xmlDecodeTree = decode_data_xml_js_1.default;
  var decode_codepoint_js_1 = __importStar(require_decode_codepoint());
  exports.decodeCodePoint = decode_codepoint_js_1.default;
  var decode_codepoint_js_2 = require_decode_codepoint();
  Object.defineProperty(exports, "replaceCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.replaceCodePoint;
  } });
  Object.defineProperty(exports, "fromCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.fromCodePoint;
  } });
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
    CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
    CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
    CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
    CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
    CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
    CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
    CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
    CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
    CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
    CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  var TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
  var EntityDecoderState;
  (function(EntityDecoderState2) {
    EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
  })(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
  var EntityDecoder = function() {
    function EntityDecoder2(decodeTree, emitCodePoint, errors) {
      this.decodeTree = decodeTree;
      this.emitCodePoint = emitCodePoint;
      this.errors = errors;
      this.state = EntityDecoderState.EntityStart;
      this.consumed = 1;
      this.result = 0;
      this.treeIndex = 0;
      this.excess = 1;
      this.decodeMode = DecodingMode.Strict;
    }
    EntityDecoder2.prototype.startEntity = function(decodeMode) {
      this.decodeMode = decodeMode;
      this.state = EntityDecoderState.EntityStart;
      this.result = 0;
      this.treeIndex = 0;
      this.excess = 1;
      this.consumed = 1;
    };
    EntityDecoder2.prototype.write = function(str, offset) {
      switch (this.state) {
        case EntityDecoderState.EntityStart: {
          if (str.charCodeAt(offset) === CharCodes.NUM) {
            this.state = EntityDecoderState.NumericStart;
            this.consumed += 1;
            return this.stateNumericStart(str, offset + 1);
          }
          this.state = EntityDecoderState.NamedEntity;
          return this.stateNamedEntity(str, offset);
        }
        case EntityDecoderState.NumericStart: {
          return this.stateNumericStart(str, offset);
        }
        case EntityDecoderState.NumericDecimal: {
          return this.stateNumericDecimal(str, offset);
        }
        case EntityDecoderState.NumericHex: {
          return this.stateNumericHex(str, offset);
        }
        case EntityDecoderState.NamedEntity: {
          return this.stateNamedEntity(str, offset);
        }
      }
    };
    EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
      if (offset >= str.length) {
        return -1;
      }
      if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
        this.state = EntityDecoderState.NumericHex;
        this.consumed += 1;
        return this.stateNumericHex(str, offset + 1);
      }
      this.state = EntityDecoderState.NumericDecimal;
      return this.stateNumericDecimal(str, offset);
    };
    EntityDecoder2.prototype.addToNumericResult = function(str, start, end, base) {
      if (start !== end) {
        var digitCount = end - start;
        this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
        this.consumed += digitCount;
      }
    };
    EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
      var startIdx = offset;
      while (offset < str.length) {
        var char = str.charCodeAt(offset);
        if (isNumber(char) || isHexadecimalCharacter(char)) {
          offset += 1;
        } else {
          this.addToNumericResult(str, startIdx, offset, 16);
          return this.emitNumericEntity(char, 3);
        }
      }
      this.addToNumericResult(str, startIdx, offset, 16);
      return -1;
    };
    EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
      var startIdx = offset;
      while (offset < str.length) {
        var char = str.charCodeAt(offset);
        if (isNumber(char)) {
          offset += 1;
        } else {
          this.addToNumericResult(str, startIdx, offset, 10);
          return this.emitNumericEntity(char, 2);
        }
      }
      this.addToNumericResult(str, startIdx, offset, 10);
      return -1;
    };
    EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
      var _a;
      if (this.consumed <= expectedLength) {
        (_a = this.errors) === null || _a === undefined || _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      if (lastCp === CharCodes.SEMI) {
        this.consumed += 1;
      } else if (this.decodeMode === DecodingMode.Strict) {
        return 0;
      }
      this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
      if (this.errors) {
        if (lastCp !== CharCodes.SEMI) {
          this.errors.missingSemicolonAfterCharacterReference();
        }
        this.errors.validateNumericCharacterReference(this.result);
      }
      return this.consumed;
    };
    EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
      var decodeTree = this.decodeTree;
      var current = decodeTree[this.treeIndex];
      var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      for (;offset < str.length; offset++, this.excess++) {
        var char = str.charCodeAt(offset);
        this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
        if (this.treeIndex < 0) {
          return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
        }
        current = decodeTree[this.treeIndex];
        valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        if (valueLength !== 0) {
          if (char === CharCodes.SEMI) {
            return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
          }
          if (this.decodeMode !== DecodingMode.Strict) {
            this.result = this.treeIndex;
            this.consumed += this.excess;
            this.excess = 0;
          }
        }
      }
      return -1;
    };
    EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
      var _a;
      var _b = this, result = _b.result, decodeTree = _b.decodeTree;
      var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
      this.emitNamedEntityData(result, valueLength, this.consumed);
      (_a = this.errors) === null || _a === undefined || _a.missingSemicolonAfterCharacterReference();
      return this.consumed;
    };
    EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
      var decodeTree = this.decodeTree;
      this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
      if (valueLength === 3) {
        this.emitCodePoint(decodeTree[result + 2], consumed);
      }
      return consumed;
    };
    EntityDecoder2.prototype.end = function() {
      var _a;
      switch (this.state) {
        case EntityDecoderState.NamedEntity: {
          return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
        }
        case EntityDecoderState.NumericDecimal: {
          return this.emitNumericEntity(0, 2);
        }
        case EntityDecoderState.NumericHex: {
          return this.emitNumericEntity(0, 3);
        }
        case EntityDecoderState.NumericStart: {
          (_a = this.errors) === null || _a === undefined || _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        case EntityDecoderState.EntityStart: {
          return 0;
        }
      }
    };
    return EntityDecoder2;
  }();
  exports.EntityDecoder = EntityDecoder;
  exports.determineBranch = determineBranch;
  var htmlDecoder = getDecoder(decode_data_html_js_1.default);
  var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
  exports.decodeHTML = decodeHTML;
  exports.decodeHTMLAttribute = decodeHTMLAttribute;
  exports.decodeHTMLStrict = decodeHTMLStrict;
  exports.decodeXML = decodeXML;
});

// node_modules/htmlparser2/lib/Tokenizer.js
var require_Tokenizer = __commonJS((exports) => {
  var isWhitespace = function(c) {
    return c === CharCodes.Space || c === CharCodes.NewLine || c === CharCodes.Tab || c === CharCodes.FormFeed || c === CharCodes.CarriageReturn;
  };
  var isEndOfTagSection = function(c) {
    return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);
  };
  var isNumber = function(c) {
    return c >= CharCodes.Zero && c <= CharCodes.Nine;
  };
  var isASCIIAlpha = function(c) {
    return c >= CharCodes.LowerA && c <= CharCodes.LowerZ || c >= CharCodes.UpperA && c <= CharCodes.UpperZ;
  };
  var isHexDigit = function(c) {
    return c >= CharCodes.UpperA && c <= CharCodes.UpperF || c >= CharCodes.LowerA && c <= CharCodes.LowerF;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QuoteType = undefined;
  var decode_js_1 = require_decode();
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
    CharCodes2[CharCodes2["NewLine"] = 10] = "NewLine";
    CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
    CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
    CharCodes2[CharCodes2["Space"] = 32] = "Space";
    CharCodes2[CharCodes2["ExclamationMark"] = 33] = "ExclamationMark";
    CharCodes2[CharCodes2["Number"] = 35] = "Number";
    CharCodes2[CharCodes2["Amp"] = 38] = "Amp";
    CharCodes2[CharCodes2["SingleQuote"] = 39] = "SingleQuote";
    CharCodes2[CharCodes2["DoubleQuote"] = 34] = "DoubleQuote";
    CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
    CharCodes2[CharCodes2["Slash"] = 47] = "Slash";
    CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
    CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
    CharCodes2[CharCodes2["Semi"] = 59] = "Semi";
    CharCodes2[CharCodes2["Lt"] = 60] = "Lt";
    CharCodes2[CharCodes2["Eq"] = 61] = "Eq";
    CharCodes2[CharCodes2["Gt"] = 62] = "Gt";
    CharCodes2[CharCodes2["Questionmark"] = 63] = "Questionmark";
    CharCodes2[CharCodes2["UpperA"] = 65] = "UpperA";
    CharCodes2[CharCodes2["LowerA"] = 97] = "LowerA";
    CharCodes2[CharCodes2["UpperF"] = 70] = "UpperF";
    CharCodes2[CharCodes2["LowerF"] = 102] = "LowerF";
    CharCodes2[CharCodes2["UpperZ"] = 90] = "UpperZ";
    CharCodes2[CharCodes2["LowerZ"] = 122] = "LowerZ";
    CharCodes2[CharCodes2["LowerX"] = 120] = "LowerX";
    CharCodes2[CharCodes2["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
  })(CharCodes || (CharCodes = {}));
  var State;
  (function(State2) {
    State2[State2["Text"] = 1] = "Text";
    State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
    State2[State2["InTagName"] = 3] = "InTagName";
    State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
    State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
    State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
    State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
    State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
    State2[State2["InAttributeName"] = 9] = "InAttributeName";
    State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
    State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
    State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
    State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
    State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
    State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
    State2[State2["InDeclaration"] = 16] = "InDeclaration";
    State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
    State2[State2["BeforeComment"] = 18] = "BeforeComment";
    State2[State2["CDATASequence"] = 19] = "CDATASequence";
    State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
    State2[State2["InCommentLike"] = 21] = "InCommentLike";
    State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
    State2[State2["SpecialStartSequence"] = 23] = "SpecialStartSequence";
    State2[State2["InSpecialTag"] = 24] = "InSpecialTag";
    State2[State2["BeforeEntity"] = 25] = "BeforeEntity";
    State2[State2["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
    State2[State2["InNamedEntity"] = 27] = "InNamedEntity";
    State2[State2["InNumericEntity"] = 28] = "InNumericEntity";
    State2[State2["InHexEntity"] = 29] = "InHexEntity";
  })(State || (State = {}));
  var QuoteType;
  (function(QuoteType2) {
    QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
    QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
    QuoteType2[QuoteType2["Single"] = 2] = "Single";
    QuoteType2[QuoteType2["Double"] = 3] = "Double";
  })(QuoteType = exports.QuoteType || (exports.QuoteType = {}));
  var Sequences = {
    Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
    CdataEnd: new Uint8Array([93, 93, 62]),
    CommentEnd: new Uint8Array([45, 45, 62]),
    ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
    StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
    TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
  };
  var Tokenizer = function() {
    function Tokenizer2(_a, cbs) {
      var _b = _a.xmlMode, xmlMode = _b === undefined ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === undefined ? true : _c;
      this.cbs = cbs;
      this.state = State.Text;
      this.buffer = "";
      this.sectionStart = 0;
      this.index = 0;
      this.baseState = State.Text;
      this.isSpecial = false;
      this.running = true;
      this.offset = 0;
      this.currentSequence = undefined;
      this.sequenceIndex = 0;
      this.trieIndex = 0;
      this.trieCurrent = 0;
      this.entityResult = 0;
      this.entityExcess = 0;
      this.xmlMode = xmlMode;
      this.decodeEntities = decodeEntities;
      this.entityTrie = xmlMode ? decode_js_1.xmlDecodeTree : decode_js_1.htmlDecodeTree;
    }
    Tokenizer2.prototype.reset = function() {
      this.state = State.Text;
      this.buffer = "";
      this.sectionStart = 0;
      this.index = 0;
      this.baseState = State.Text;
      this.currentSequence = undefined;
      this.running = true;
      this.offset = 0;
    };
    Tokenizer2.prototype.write = function(chunk) {
      this.offset += this.buffer.length;
      this.buffer = chunk;
      this.parse();
    };
    Tokenizer2.prototype.end = function() {
      if (this.running)
        this.finish();
    };
    Tokenizer2.prototype.pause = function() {
      this.running = false;
    };
    Tokenizer2.prototype.resume = function() {
      this.running = true;
      if (this.index < this.buffer.length + this.offset) {
        this.parse();
      }
    };
    Tokenizer2.prototype.getIndex = function() {
      return this.index;
    };
    Tokenizer2.prototype.getSectionStart = function() {
      return this.sectionStart;
    };
    Tokenizer2.prototype.stateText = function(c) {
      if (c === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
        if (this.index > this.sectionStart) {
          this.cbs.ontext(this.sectionStart, this.index);
        }
        this.state = State.BeforeTagName;
        this.sectionStart = this.index;
      } else if (this.decodeEntities && c === CharCodes.Amp) {
        this.state = State.BeforeEntity;
      }
    };
    Tokenizer2.prototype.stateSpecialStartSequence = function(c) {
      var isEnd = this.sequenceIndex === this.currentSequence.length;
      var isMatch = isEnd ? isEndOfTagSection(c) : (c | 32) === this.currentSequence[this.sequenceIndex];
      if (!isMatch) {
        this.isSpecial = false;
      } else if (!isEnd) {
        this.sequenceIndex++;
        return;
      }
      this.sequenceIndex = 0;
      this.state = State.InTagName;
      this.stateInTagName(c);
    };
    Tokenizer2.prototype.stateInSpecialTag = function(c) {
      if (this.sequenceIndex === this.currentSequence.length) {
        if (c === CharCodes.Gt || isWhitespace(c)) {
          var endOfText = this.index - this.currentSequence.length;
          if (this.sectionStart < endOfText) {
            var actualIndex = this.index;
            this.index = endOfText;
            this.cbs.ontext(this.sectionStart, endOfText);
            this.index = actualIndex;
          }
          this.isSpecial = false;
          this.sectionStart = endOfText + 2;
          this.stateInClosingTagName(c);
          return;
        }
        this.sequenceIndex = 0;
      }
      if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
        this.sequenceIndex += 1;
      } else if (this.sequenceIndex === 0) {
        if (this.currentSequence === Sequences.TitleEnd) {
          if (this.decodeEntities && c === CharCodes.Amp) {
            this.state = State.BeforeEntity;
          }
        } else if (this.fastForwardTo(CharCodes.Lt)) {
          this.sequenceIndex = 1;
        }
      } else {
        this.sequenceIndex = Number(c === CharCodes.Lt);
      }
    };
    Tokenizer2.prototype.stateCDATASequence = function(c) {
      if (c === Sequences.Cdata[this.sequenceIndex]) {
        if (++this.sequenceIndex === Sequences.Cdata.length) {
          this.state = State.InCommentLike;
          this.currentSequence = Sequences.CdataEnd;
          this.sequenceIndex = 0;
          this.sectionStart = this.index + 1;
        }
      } else {
        this.sequenceIndex = 0;
        this.state = State.InDeclaration;
        this.stateInDeclaration(c);
      }
    };
    Tokenizer2.prototype.fastForwardTo = function(c) {
      while (++this.index < this.buffer.length + this.offset) {
        if (this.buffer.charCodeAt(this.index - this.offset) === c) {
          return true;
        }
      }
      this.index = this.buffer.length + this.offset - 1;
      return false;
    };
    Tokenizer2.prototype.stateInCommentLike = function(c) {
      if (c === this.currentSequence[this.sequenceIndex]) {
        if (++this.sequenceIndex === this.currentSequence.length) {
          if (this.currentSequence === Sequences.CdataEnd) {
            this.cbs.oncdata(this.sectionStart, this.index, 2);
          } else {
            this.cbs.oncomment(this.sectionStart, this.index, 2);
          }
          this.sequenceIndex = 0;
          this.sectionStart = this.index + 1;
          this.state = State.Text;
        }
      } else if (this.sequenceIndex === 0) {
        if (this.fastForwardTo(this.currentSequence[0])) {
          this.sequenceIndex = 1;
        }
      } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
        this.sequenceIndex = 0;
      }
    };
    Tokenizer2.prototype.isTagStartChar = function(c) {
      return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
    };
    Tokenizer2.prototype.startSpecial = function(sequence, offset) {
      this.isSpecial = true;
      this.currentSequence = sequence;
      this.sequenceIndex = offset;
      this.state = State.SpecialStartSequence;
    };
    Tokenizer2.prototype.stateBeforeTagName = function(c) {
      if (c === CharCodes.ExclamationMark) {
        this.state = State.BeforeDeclaration;
        this.sectionStart = this.index + 1;
      } else if (c === CharCodes.Questionmark) {
        this.state = State.InProcessingInstruction;
        this.sectionStart = this.index + 1;
      } else if (this.isTagStartChar(c)) {
        var lower = c | 32;
        this.sectionStart = this.index;
        if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
          this.startSpecial(Sequences.TitleEnd, 3);
        } else {
          this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
        }
      } else if (c === CharCodes.Slash) {
        this.state = State.BeforeClosingTagName;
      } else {
        this.state = State.Text;
        this.stateText(c);
      }
    };
    Tokenizer2.prototype.stateInTagName = function(c) {
      if (isEndOfTagSection(c)) {
        this.cbs.onopentagname(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c);
      }
    };
    Tokenizer2.prototype.stateBeforeClosingTagName = function(c) {
      if (isWhitespace(c)) {
      } else if (c === CharCodes.Gt) {
        this.state = State.Text;
      } else {
        this.state = this.isTagStartChar(c) ? State.InClosingTagName : State.InSpecialComment;
        this.sectionStart = this.index;
      }
    };
    Tokenizer2.prototype.stateInClosingTagName = function(c) {
      if (c === CharCodes.Gt || isWhitespace(c)) {
        this.cbs.onclosetag(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = State.AfterClosingTagName;
        this.stateAfterClosingTagName(c);
      }
    };
    Tokenizer2.prototype.stateAfterClosingTagName = function(c) {
      if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
        this.state = State.Text;
        this.baseState = State.Text;
        this.sectionStart = this.index + 1;
      }
    };
    Tokenizer2.prototype.stateBeforeAttributeName = function(c) {
      if (c === CharCodes.Gt) {
        this.cbs.onopentagend(this.index);
        if (this.isSpecial) {
          this.state = State.InSpecialTag;
          this.sequenceIndex = 0;
        } else {
          this.state = State.Text;
        }
        this.baseState = this.state;
        this.sectionStart = this.index + 1;
      } else if (c === CharCodes.Slash) {
        this.state = State.InSelfClosingTag;
      } else if (!isWhitespace(c)) {
        this.state = State.InAttributeName;
        this.sectionStart = this.index;
      }
    };
    Tokenizer2.prototype.stateInSelfClosingTag = function(c) {
      if (c === CharCodes.Gt) {
        this.cbs.onselfclosingtag(this.index);
        this.state = State.Text;
        this.baseState = State.Text;
        this.sectionStart = this.index + 1;
        this.isSpecial = false;
      } else if (!isWhitespace(c)) {
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c);
      }
    };
    Tokenizer2.prototype.stateInAttributeName = function(c) {
      if (c === CharCodes.Eq || isEndOfTagSection(c)) {
        this.cbs.onattribname(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = State.AfterAttributeName;
        this.stateAfterAttributeName(c);
      }
    };
    Tokenizer2.prototype.stateAfterAttributeName = function(c) {
      if (c === CharCodes.Eq) {
        this.state = State.BeforeAttributeValue;
      } else if (c === CharCodes.Slash || c === CharCodes.Gt) {
        this.cbs.onattribend(QuoteType.NoValue, this.index);
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c);
      } else if (!isWhitespace(c)) {
        this.cbs.onattribend(QuoteType.NoValue, this.index);
        this.state = State.InAttributeName;
        this.sectionStart = this.index;
      }
    };
    Tokenizer2.prototype.stateBeforeAttributeValue = function(c) {
      if (c === CharCodes.DoubleQuote) {
        this.state = State.InAttributeValueDq;
        this.sectionStart = this.index + 1;
      } else if (c === CharCodes.SingleQuote) {
        this.state = State.InAttributeValueSq;
        this.sectionStart = this.index + 1;
      } else if (!isWhitespace(c)) {
        this.sectionStart = this.index;
        this.state = State.InAttributeValueNq;
        this.stateInAttributeValueNoQuotes(c);
      }
    };
    Tokenizer2.prototype.handleInAttributeValue = function(c, quote) {
      if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
        this.state = State.BeforeAttributeName;
      } else if (this.decodeEntities && c === CharCodes.Amp) {
        this.baseState = this.state;
        this.state = State.BeforeEntity;
      }
    };
    Tokenizer2.prototype.stateInAttributeValueDoubleQuotes = function(c) {
      this.handleInAttributeValue(c, CharCodes.DoubleQuote);
    };
    Tokenizer2.prototype.stateInAttributeValueSingleQuotes = function(c) {
      this.handleInAttributeValue(c, CharCodes.SingleQuote);
    };
    Tokenizer2.prototype.stateInAttributeValueNoQuotes = function(c) {
      if (isWhitespace(c) || c === CharCodes.Gt) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.cbs.onattribend(QuoteType.Unquoted, this.index);
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c);
      } else if (this.decodeEntities && c === CharCodes.Amp) {
        this.baseState = this.state;
        this.state = State.BeforeEntity;
      }
    };
    Tokenizer2.prototype.stateBeforeDeclaration = function(c) {
      if (c === CharCodes.OpeningSquareBracket) {
        this.state = State.CDATASequence;
        this.sequenceIndex = 0;
      } else {
        this.state = c === CharCodes.Dash ? State.BeforeComment : State.InDeclaration;
      }
    };
    Tokenizer2.prototype.stateInDeclaration = function(c) {
      if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
        this.cbs.ondeclaration(this.sectionStart, this.index);
        this.state = State.Text;
        this.sectionStart = this.index + 1;
      }
    };
    Tokenizer2.prototype.stateInProcessingInstruction = function(c) {
      if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
        this.cbs.onprocessinginstruction(this.sectionStart, this.index);
        this.state = State.Text;
        this.sectionStart = this.index + 1;
      }
    };
    Tokenizer2.prototype.stateBeforeComment = function(c) {
      if (c === CharCodes.Dash) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CommentEnd;
        this.sequenceIndex = 2;
        this.sectionStart = this.index + 1;
      } else {
        this.state = State.InDeclaration;
      }
    };
    Tokenizer2.prototype.stateInSpecialComment = function(c) {
      if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
        this.cbs.oncomment(this.sectionStart, this.index, 0);
        this.state = State.Text;
        this.sectionStart = this.index + 1;
      }
    };
    Tokenizer2.prototype.stateBeforeSpecialS = function(c) {
      var lower = c | 32;
      if (lower === Sequences.ScriptEnd[3]) {
        this.startSpecial(Sequences.ScriptEnd, 4);
      } else if (lower === Sequences.StyleEnd[3]) {
        this.startSpecial(Sequences.StyleEnd, 4);
      } else {
        this.state = State.InTagName;
        this.stateInTagName(c);
      }
    };
    Tokenizer2.prototype.stateBeforeEntity = function(c) {
      this.entityExcess = 1;
      this.entityResult = 0;
      if (c === CharCodes.Number) {
        this.state = State.BeforeNumericEntity;
      } else if (c === CharCodes.Amp) {
      } else {
        this.trieIndex = 0;
        this.trieCurrent = this.entityTrie[0];
        this.state = State.InNamedEntity;
        this.stateInNamedEntity(c);
      }
    };
    Tokenizer2.prototype.stateInNamedEntity = function(c) {
      this.entityExcess += 1;
      this.trieIndex = (0, decode_js_1.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
      if (this.trieIndex < 0) {
        this.emitNamedEntity();
        this.index--;
        return;
      }
      this.trieCurrent = this.entityTrie[this.trieIndex];
      var masked = this.trieCurrent & decode_js_1.BinTrieFlags.VALUE_LENGTH;
      if (masked) {
        var valueLength = (masked >> 14) - 1;
        if (!this.allowLegacyEntity() && c !== CharCodes.Semi) {
          this.trieIndex += valueLength;
        } else {
          var entityStart = this.index - this.entityExcess + 1;
          if (entityStart > this.sectionStart) {
            this.emitPartial(this.sectionStart, entityStart);
          }
          this.entityResult = this.trieIndex;
          this.trieIndex += valueLength;
          this.entityExcess = 0;
          this.sectionStart = this.index + 1;
          if (valueLength === 0) {
            this.emitNamedEntity();
          }
        }
      }
    };
    Tokenizer2.prototype.emitNamedEntity = function() {
      this.state = this.baseState;
      if (this.entityResult === 0) {
        return;
      }
      var valueLength = (this.entityTrie[this.entityResult] & decode_js_1.BinTrieFlags.VALUE_LENGTH) >> 14;
      switch (valueLength) {
        case 1: {
          this.emitCodePoint(this.entityTrie[this.entityResult] & ~decode_js_1.BinTrieFlags.VALUE_LENGTH);
          break;
        }
        case 2: {
          this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
          break;
        }
        case 3: {
          this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
          this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
        }
      }
    };
    Tokenizer2.prototype.stateBeforeNumericEntity = function(c) {
      if ((c | 32) === CharCodes.LowerX) {
        this.entityExcess++;
        this.state = State.InHexEntity;
      } else {
        this.state = State.InNumericEntity;
        this.stateInNumericEntity(c);
      }
    };
    Tokenizer2.prototype.emitNumericEntity = function(strict) {
      var entityStart = this.index - this.entityExcess - 1;
      var numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
      if (numberStart !== this.index) {
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        this.sectionStart = this.index + Number(strict);
        this.emitCodePoint((0, decode_js_1.replaceCodePoint)(this.entityResult));
      }
      this.state = this.baseState;
    };
    Tokenizer2.prototype.stateInNumericEntity = function(c) {
      if (c === CharCodes.Semi) {
        this.emitNumericEntity(true);
      } else if (isNumber(c)) {
        this.entityResult = this.entityResult * 10 + (c - CharCodes.Zero);
        this.entityExcess++;
      } else {
        if (this.allowLegacyEntity()) {
          this.emitNumericEntity(false);
        } else {
          this.state = this.baseState;
        }
        this.index--;
      }
    };
    Tokenizer2.prototype.stateInHexEntity = function(c) {
      if (c === CharCodes.Semi) {
        this.emitNumericEntity(true);
      } else if (isNumber(c)) {
        this.entityResult = this.entityResult * 16 + (c - CharCodes.Zero);
        this.entityExcess++;
      } else if (isHexDigit(c)) {
        this.entityResult = this.entityResult * 16 + ((c | 32) - CharCodes.LowerA + 10);
        this.entityExcess++;
      } else {
        if (this.allowLegacyEntity()) {
          this.emitNumericEntity(false);
        } else {
          this.state = this.baseState;
        }
        this.index--;
      }
    };
    Tokenizer2.prototype.allowLegacyEntity = function() {
      return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
    };
    Tokenizer2.prototype.cleanup = function() {
      if (this.running && this.sectionStart !== this.index) {
        if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
          this.cbs.ontext(this.sectionStart, this.index);
          this.sectionStart = this.index;
        } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = this.index;
        }
      }
    };
    Tokenizer2.prototype.shouldContinue = function() {
      return this.index < this.buffer.length + this.offset && this.running;
    };
    Tokenizer2.prototype.parse = function() {
      while (this.shouldContinue()) {
        var c = this.buffer.charCodeAt(this.index - this.offset);
        switch (this.state) {
          case State.Text: {
            this.stateText(c);
            break;
          }
          case State.SpecialStartSequence: {
            this.stateSpecialStartSequence(c);
            break;
          }
          case State.InSpecialTag: {
            this.stateInSpecialTag(c);
            break;
          }
          case State.CDATASequence: {
            this.stateCDATASequence(c);
            break;
          }
          case State.InAttributeValueDq: {
            this.stateInAttributeValueDoubleQuotes(c);
            break;
          }
          case State.InAttributeName: {
            this.stateInAttributeName(c);
            break;
          }
          case State.InCommentLike: {
            this.stateInCommentLike(c);
            break;
          }
          case State.InSpecialComment: {
            this.stateInSpecialComment(c);
            break;
          }
          case State.BeforeAttributeName: {
            this.stateBeforeAttributeName(c);
            break;
          }
          case State.InTagName: {
            this.stateInTagName(c);
            break;
          }
          case State.InClosingTagName: {
            this.stateInClosingTagName(c);
            break;
          }
          case State.BeforeTagName: {
            this.stateBeforeTagName(c);
            break;
          }
          case State.AfterAttributeName: {
            this.stateAfterAttributeName(c);
            break;
          }
          case State.InAttributeValueSq: {
            this.stateInAttributeValueSingleQuotes(c);
            break;
          }
          case State.BeforeAttributeValue: {
            this.stateBeforeAttributeValue(c);
            break;
          }
          case State.BeforeClosingTagName: {
            this.stateBeforeClosingTagName(c);
            break;
          }
          case State.AfterClosingTagName: {
            this.stateAfterClosingTagName(c);
            break;
          }
          case State.BeforeSpecialS: {
            this.stateBeforeSpecialS(c);
            break;
          }
          case State.InAttributeValueNq: {
            this.stateInAttributeValueNoQuotes(c);
            break;
          }
          case State.InSelfClosingTag: {
            this.stateInSelfClosingTag(c);
            break;
          }
          case State.InDeclaration: {
            this.stateInDeclaration(c);
            break;
          }
          case State.BeforeDeclaration: {
            this.stateBeforeDeclaration(c);
            break;
          }
          case State.BeforeComment: {
            this.stateBeforeComment(c);
            break;
          }
          case State.InProcessingInstruction: {
            this.stateInProcessingInstruction(c);
            break;
          }
          case State.InNamedEntity: {
            this.stateInNamedEntity(c);
            break;
          }
          case State.BeforeEntity: {
            this.stateBeforeEntity(c);
            break;
          }
          case State.InHexEntity: {
            this.stateInHexEntity(c);
            break;
          }
          case State.InNumericEntity: {
            this.stateInNumericEntity(c);
            break;
          }
          default: {
            this.stateBeforeNumericEntity(c);
          }
        }
        this.index++;
      }
      this.cleanup();
    };
    Tokenizer2.prototype.finish = function() {
      if (this.state === State.InNamedEntity) {
        this.emitNamedEntity();
      }
      if (this.sectionStart < this.index) {
        this.handleTrailingData();
      }
      this.cbs.onend();
    };
    Tokenizer2.prototype.handleTrailingData = function() {
      var endIndex = this.buffer.length + this.offset;
      if (this.state === State.InCommentLike) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, endIndex, 0);
        } else {
          this.cbs.oncomment(this.sectionStart, endIndex, 0);
        }
      } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
      } else {
        this.cbs.ontext(this.sectionStart, endIndex);
      }
    };
    Tokenizer2.prototype.emitPartial = function(start, endIndex) {
      if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
        this.cbs.onattribdata(start, endIndex);
      } else {
        this.cbs.ontext(start, endIndex);
      }
    };
    Tokenizer2.prototype.emitCodePoint = function(cp) {
      if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
        this.cbs.onattribentity(cp);
      } else {
        this.cbs.ontextentity(cp);
      }
    };
    return Tokenizer2;
  }();
  exports.default = Tokenizer;
});

// node_modules/htmlparser2/lib/Parser.js
var require_Parser = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Parser = undefined;
  var Tokenizer_js_1 = __importStar(require_Tokenizer());
  var decode_js_1 = require_decode();
  var formTags = new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea"
  ]);
  var pTag = new Set(["p"]);
  var tableSectionTags = new Set(["thead", "tbody"]);
  var ddtTags = new Set(["dd", "dt"]);
  var rtpTags = new Set(["rt", "rp"]);
  var openImpliesClose = new Map([
    ["tr", new Set(["tr", "th", "td"])],
    ["th", new Set(["th"])],
    ["td", new Set(["thead", "th", "td"])],
    ["body", new Set(["head", "link", "script"])],
    ["li", new Set(["li"])],
    ["p", pTag],
    ["h1", pTag],
    ["h2", pTag],
    ["h3", pTag],
    ["h4", pTag],
    ["h5", pTag],
    ["h6", pTag],
    ["select", formTags],
    ["input", formTags],
    ["output", formTags],
    ["button", formTags],
    ["datalist", formTags],
    ["textarea", formTags],
    ["option", new Set(["option"])],
    ["optgroup", new Set(["optgroup", "option"])],
    ["dd", ddtTags],
    ["dt", ddtTags],
    ["address", pTag],
    ["article", pTag],
    ["aside", pTag],
    ["blockquote", pTag],
    ["details", pTag],
    ["div", pTag],
    ["dl", pTag],
    ["fieldset", pTag],
    ["figcaption", pTag],
    ["figure", pTag],
    ["footer", pTag],
    ["form", pTag],
    ["header", pTag],
    ["hr", pTag],
    ["main", pTag],
    ["nav", pTag],
    ["ol", pTag],
    ["pre", pTag],
    ["section", pTag],
    ["table", pTag],
    ["ul", pTag],
    ["rt", rtpTags],
    ["rp", rtpTags],
    ["tbody", tableSectionTags],
    ["tfoot", tableSectionTags]
  ]);
  var voidElements = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  var foreignContextElements = new Set(["math", "svg"]);
  var htmlIntegrationElements = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignobject",
    "desc",
    "title"
  ]);
  var reNameEnd = /\s|\//;
  var Parser = function() {
    function Parser2(cbs, options) {
      if (options === undefined) {
        options = {};
      }
      var _a, _b, _c, _d, _e;
      this.options = options;
      this.startIndex = 0;
      this.endIndex = 0;
      this.openTagStart = 0;
      this.tagname = "";
      this.attribname = "";
      this.attribvalue = "";
      this.attribs = null;
      this.stack = [];
      this.foreignContext = [];
      this.buffers = [];
      this.bufferOffset = 0;
      this.writeIndex = 0;
      this.ended = false;
      this.cbs = cbs !== null && cbs !== undefined ? cbs : {};
      this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== undefined ? _a : !options.xmlMode;
      this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== undefined ? _b : !options.xmlMode;
      this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== undefined ? _c : Tokenizer_js_1.default)(this.options, this);
      (_e = (_d = this.cbs).onparserinit) === null || _e === undefined || _e.call(_d, this);
    }
    Parser2.prototype.ontext = function(start, endIndex) {
      var _a, _b;
      var data = this.getSlice(start, endIndex);
      this.endIndex = endIndex - 1;
      (_b = (_a = this.cbs).ontext) === null || _b === undefined || _b.call(_a, data);
      this.startIndex = endIndex;
    };
    Parser2.prototype.ontextentity = function(cp) {
      var _a, _b;
      var index = this.tokenizer.getSectionStart();
      this.endIndex = index - 1;
      (_b = (_a = this.cbs).ontext) === null || _b === undefined || _b.call(_a, (0, decode_js_1.fromCodePoint)(cp));
      this.startIndex = index;
    };
    Parser2.prototype.isVoidElement = function(name) {
      return !this.options.xmlMode && voidElements.has(name);
    };
    Parser2.prototype.onopentagname = function(start, endIndex) {
      this.endIndex = endIndex;
      var name = this.getSlice(start, endIndex);
      if (this.lowerCaseTagNames) {
        name = name.toLowerCase();
      }
      this.emitOpenTag(name);
    };
    Parser2.prototype.emitOpenTag = function(name) {
      var _a, _b, _c, _d;
      this.openTagStart = this.startIndex;
      this.tagname = name;
      var impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
      if (impliesClose) {
        while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
          var element = this.stack.pop();
          (_b = (_a = this.cbs).onclosetag) === null || _b === undefined || _b.call(_a, element, true);
        }
      }
      if (!this.isVoidElement(name)) {
        this.stack.push(name);
        if (foreignContextElements.has(name)) {
          this.foreignContext.push(true);
        } else if (htmlIntegrationElements.has(name)) {
          this.foreignContext.push(false);
        }
      }
      (_d = (_c = this.cbs).onopentagname) === null || _d === undefined || _d.call(_c, name);
      if (this.cbs.onopentag)
        this.attribs = {};
    };
    Parser2.prototype.endOpenTag = function(isImplied) {
      var _a, _b;
      this.startIndex = this.openTagStart;
      if (this.attribs) {
        (_b = (_a = this.cbs).onopentag) === null || _b === undefined || _b.call(_a, this.tagname, this.attribs, isImplied);
        this.attribs = null;
      }
      if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
        this.cbs.onclosetag(this.tagname, true);
      }
      this.tagname = "";
    };
    Parser2.prototype.onopentagend = function(endIndex) {
      this.endIndex = endIndex;
      this.endOpenTag(false);
      this.startIndex = endIndex + 1;
    };
    Parser2.prototype.onclosetag = function(start, endIndex) {
      var _a, _b, _c, _d, _e, _f;
      this.endIndex = endIndex;
      var name = this.getSlice(start, endIndex);
      if (this.lowerCaseTagNames) {
        name = name.toLowerCase();
      }
      if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
        this.foreignContext.pop();
      }
      if (!this.isVoidElement(name)) {
        var pos = this.stack.lastIndexOf(name);
        if (pos !== -1) {
          if (this.cbs.onclosetag) {
            var count = this.stack.length - pos;
            while (count--) {
              this.cbs.onclosetag(this.stack.pop(), count !== 0);
            }
          } else
            this.stack.length = pos;
        } else if (!this.options.xmlMode && name === "p") {
          this.emitOpenTag("p");
          this.closeCurrentTag(true);
        }
      } else if (!this.options.xmlMode && name === "br") {
        (_b = (_a = this.cbs).onopentagname) === null || _b === undefined || _b.call(_a, "br");
        (_d = (_c = this.cbs).onopentag) === null || _d === undefined || _d.call(_c, "br", {}, true);
        (_f = (_e = this.cbs).onclosetag) === null || _f === undefined || _f.call(_e, "br", false);
      }
      this.startIndex = endIndex + 1;
    };
    Parser2.prototype.onselfclosingtag = function(endIndex) {
      this.endIndex = endIndex;
      if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
        this.closeCurrentTag(false);
        this.startIndex = endIndex + 1;
      } else {
        this.onopentagend(endIndex);
      }
    };
    Parser2.prototype.closeCurrentTag = function(isOpenImplied) {
      var _a, _b;
      var name = this.tagname;
      this.endOpenTag(isOpenImplied);
      if (this.stack[this.stack.length - 1] === name) {
        (_b = (_a = this.cbs).onclosetag) === null || _b === undefined || _b.call(_a, name, !isOpenImplied);
        this.stack.pop();
      }
    };
    Parser2.prototype.onattribname = function(start, endIndex) {
      this.startIndex = start;
      var name = this.getSlice(start, endIndex);
      this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
    };
    Parser2.prototype.onattribdata = function(start, endIndex) {
      this.attribvalue += this.getSlice(start, endIndex);
    };
    Parser2.prototype.onattribentity = function(cp) {
      this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);
    };
    Parser2.prototype.onattribend = function(quote, endIndex) {
      var _a, _b;
      this.endIndex = endIndex;
      (_b = (_a = this.cbs).onattribute) === null || _b === undefined || _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double ? '"' : quote === Tokenizer_js_1.QuoteType.Single ? "'" : quote === Tokenizer_js_1.QuoteType.NoValue ? undefined : null);
      if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
        this.attribs[this.attribname] = this.attribvalue;
      }
      this.attribvalue = "";
    };
    Parser2.prototype.getInstructionName = function(value) {
      var index = value.search(reNameEnd);
      var name = index < 0 ? value : value.substr(0, index);
      if (this.lowerCaseTagNames) {
        name = name.toLowerCase();
      }
      return name;
    };
    Parser2.prototype.ondeclaration = function(start, endIndex) {
      this.endIndex = endIndex;
      var value = this.getSlice(start, endIndex);
      if (this.cbs.onprocessinginstruction) {
        var name = this.getInstructionName(value);
        this.cbs.onprocessinginstruction("!".concat(name), "!".concat(value));
      }
      this.startIndex = endIndex + 1;
    };
    Parser2.prototype.onprocessinginstruction = function(start, endIndex) {
      this.endIndex = endIndex;
      var value = this.getSlice(start, endIndex);
      if (this.cbs.onprocessinginstruction) {
        var name = this.getInstructionName(value);
        this.cbs.onprocessinginstruction("?".concat(name), "?".concat(value));
      }
      this.startIndex = endIndex + 1;
    };
    Parser2.prototype.oncomment = function(start, endIndex, offset) {
      var _a, _b, _c, _d;
      this.endIndex = endIndex;
      (_b = (_a = this.cbs).oncomment) === null || _b === undefined || _b.call(_a, this.getSlice(start, endIndex - offset));
      (_d = (_c = this.cbs).oncommentend) === null || _d === undefined || _d.call(_c);
      this.startIndex = endIndex + 1;
    };
    Parser2.prototype.oncdata = function(start, endIndex, offset) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      this.endIndex = endIndex;
      var value = this.getSlice(start, endIndex - offset);
      if (this.options.xmlMode || this.options.recognizeCDATA) {
        (_b = (_a = this.cbs).oncdatastart) === null || _b === undefined || _b.call(_a);
        (_d = (_c = this.cbs).ontext) === null || _d === undefined || _d.call(_c, value);
        (_f = (_e = this.cbs).oncdataend) === null || _f === undefined || _f.call(_e);
      } else {
        (_h = (_g = this.cbs).oncomment) === null || _h === undefined || _h.call(_g, "[CDATA[".concat(value, "]]"));
        (_k = (_j = this.cbs).oncommentend) === null || _k === undefined || _k.call(_j);
      }
      this.startIndex = endIndex + 1;
    };
    Parser2.prototype.onend = function() {
      var _a, _b;
      if (this.cbs.onclosetag) {
        this.endIndex = this.startIndex;
        for (var index = this.stack.length;index > 0; this.cbs.onclosetag(this.stack[--index], true))
          ;
      }
      (_b = (_a = this.cbs).onend) === null || _b === undefined || _b.call(_a);
    };
    Parser2.prototype.reset = function() {
      var _a, _b, _c, _d;
      (_b = (_a = this.cbs).onreset) === null || _b === undefined || _b.call(_a);
      this.tokenizer.reset();
      this.tagname = "";
      this.attribname = "";
      this.attribs = null;
      this.stack.length = 0;
      this.startIndex = 0;
      this.endIndex = 0;
      (_d = (_c = this.cbs).onparserinit) === null || _d === undefined || _d.call(_c, this);
      this.buffers.length = 0;
      this.bufferOffset = 0;
      this.writeIndex = 0;
      this.ended = false;
    };
    Parser2.prototype.parseComplete = function(data) {
      this.reset();
      this.end(data);
    };
    Parser2.prototype.getSlice = function(start, end) {
      while (start - this.bufferOffset >= this.buffers[0].length) {
        this.shiftBuffer();
      }
      var slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
      while (end - this.bufferOffset > this.buffers[0].length) {
        this.shiftBuffer();
        slice += this.buffers[0].slice(0, end - this.bufferOffset);
      }
      return slice;
    };
    Parser2.prototype.shiftBuffer = function() {
      this.bufferOffset += this.buffers[0].length;
      this.writeIndex--;
      this.buffers.shift();
    };
    Parser2.prototype.write = function(chunk) {
      var _a, _b;
      if (this.ended) {
        (_b = (_a = this.cbs).onerror) === null || _b === undefined || _b.call(_a, new Error(".write() after done!"));
        return;
      }
      this.buffers.push(chunk);
      if (this.tokenizer.running) {
        this.tokenizer.write(chunk);
        this.writeIndex++;
      }
    };
    Parser2.prototype.end = function(chunk) {
      var _a, _b;
      if (this.ended) {
        (_b = (_a = this.cbs).onerror) === null || _b === undefined || _b.call(_a, new Error(".end() after done!"));
        return;
      }
      if (chunk)
        this.write(chunk);
      this.ended = true;
      this.tokenizer.end();
    };
    Parser2.prototype.pause = function() {
      this.tokenizer.pause();
    };
    Parser2.prototype.resume = function() {
      this.tokenizer.resume();
      while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
        this.tokenizer.write(this.buffers[this.writeIndex++]);
      }
      if (this.ended)
        this.tokenizer.end();
    };
    Parser2.prototype.parseChunk = function(chunk) {
      this.write(chunk);
    };
    Parser2.prototype.done = function(chunk) {
      this.end(chunk);
    };
    return Parser2;
  }();
  exports.Parser = Parser;
});

// node_modules/domelementtype/lib/index.js
var require_lib = __commonJS((exports) => {
  var isTag = function(elem) {
    return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = undefined;
  var ElementType;
  (function(ElementType2) {
    ElementType2["Root"] = "root";
    ElementType2["Text"] = "text";
    ElementType2["Directive"] = "directive";
    ElementType2["Comment"] = "comment";
    ElementType2["Script"] = "script";
    ElementType2["Style"] = "style";
    ElementType2["Tag"] = "tag";
    ElementType2["CDATA"] = "cdata";
    ElementType2["Doctype"] = "doctype";
  })(ElementType = exports.ElementType || (exports.ElementType = {}));
  exports.isTag = isTag;
  exports.Root = ElementType.Root;
  exports.Text = ElementType.Text;
  exports.Directive = ElementType.Directive;
  exports.Comment = ElementType.Comment;
  exports.Script = ElementType.Script;
  exports.Style = ElementType.Style;
  exports.Tag = ElementType.Tag;
  exports.CDATA = ElementType.CDATA;
  exports.Doctype = ElementType.Doctype;
});

// node_modules/domhandler/lib/node.js
var require_node = __commonJS((exports) => {
  var isTag = function(node) {
    return (0, domelementtype_1.isTag)(node);
  };
  var isCDATA = function(node) {
    return node.type === domelementtype_1.ElementType.CDATA;
  };
  var isText = function(node) {
    return node.type === domelementtype_1.ElementType.Text;
  };
  var isComment = function(node) {
    return node.type === domelementtype_1.ElementType.Comment;
  };
  var isDirective = function(node) {
    return node.type === domelementtype_1.ElementType.Directive;
  };
  var isDocument = function(node) {
    return node.type === domelementtype_1.ElementType.Root;
  };
  var hasChildren = function(node) {
    return Object.prototype.hasOwnProperty.call(node, "children");
  };
  var cloneNode = function(node, recursive) {
    if (recursive === undefined) {
      recursive = false;
    }
    var result;
    if (isText(node)) {
      result = new Text(node.data);
    } else if (isComment(node)) {
      result = new Comment(node.data);
    } else if (isTag(node)) {
      var children = recursive ? cloneChildren(node.children) : [];
      var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
      children.forEach(function(child) {
        return child.parent = clone_1;
      });
      if (node.namespace != null) {
        clone_1.namespace = node.namespace;
      }
      if (node["x-attribsNamespace"]) {
        clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
      }
      if (node["x-attribsPrefix"]) {
        clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
      }
      result = clone_1;
    } else if (isCDATA(node)) {
      var children = recursive ? cloneChildren(node.children) : [];
      var clone_2 = new CDATA(children);
      children.forEach(function(child) {
        return child.parent = clone_2;
      });
      result = clone_2;
    } else if (isDocument(node)) {
      var children = recursive ? cloneChildren(node.children) : [];
      var clone_3 = new Document(children);
      children.forEach(function(child) {
        return child.parent = clone_3;
      });
      if (node["x-mode"]) {
        clone_3["x-mode"] = node["x-mode"];
      }
      result = clone_3;
    } else if (isDirective(node)) {
      var instruction = new ProcessingInstruction(node.name, node.data);
      if (node["x-name"] != null) {
        instruction["x-name"] = node["x-name"];
        instruction["x-publicId"] = node["x-publicId"];
        instruction["x-systemId"] = node["x-systemId"];
      }
      result = instruction;
    } else {
      throw new Error("Not implemented yet: ".concat(node.type));
    }
    result.startIndex = node.startIndex;
    result.endIndex = node.endIndex;
    if (node.sourceCodeLocation != null) {
      result.sourceCodeLocation = node.sourceCodeLocation;
    }
    return result;
  };
  var cloneChildren = function(childs) {
    var children = childs.map(function(child) {
      return cloneNode(child, true);
    });
    for (var i = 1;i < children.length; i++) {
      children[i].prev = children[i - 1];
      children[i - 1].next = children[i];
    }
    return children;
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = undefined;
  var domelementtype_1 = require_lib();
  var Node = function() {
    function Node2() {
      this.parent = null;
      this.prev = null;
      this.next = null;
      this.startIndex = null;
      this.endIndex = null;
    }
    Object.defineProperty(Node2.prototype, "parentNode", {
      get: function() {
        return this.parent;
      },
      set: function(parent) {
        this.parent = parent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "previousSibling", {
      get: function() {
        return this.prev;
      },
      set: function(prev) {
        this.prev = prev;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "nextSibling", {
      get: function() {
        return this.next;
      },
      set: function(next) {
        this.next = next;
      },
      enumerable: false,
      configurable: true
    });
    Node2.prototype.cloneNode = function(recursive) {
      if (recursive === undefined) {
        recursive = false;
      }
      return cloneNode(this, recursive);
    };
    return Node2;
  }();
  exports.Node = Node;
  var DataNode = function(_super) {
    __extends(DataNode2, _super);
    function DataNode2(data) {
      var _this = _super.call(this) || this;
      _this.data = data;
      return _this;
    }
    Object.defineProperty(DataNode2.prototype, "nodeValue", {
      get: function() {
        return this.data;
      },
      set: function(data) {
        this.data = data;
      },
      enumerable: false,
      configurable: true
    });
    return DataNode2;
  }(Node);
  exports.DataNode = DataNode;
  var Text = function(_super) {
    __extends(Text2, _super);
    function Text2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1.ElementType.Text;
      return _this;
    }
    Object.defineProperty(Text2.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: false,
      configurable: true
    });
    return Text2;
  }(DataNode);
  exports.Text = Text;
  var Comment = function(_super) {
    __extends(Comment2, _super);
    function Comment2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1.ElementType.Comment;
      return _this;
    }
    Object.defineProperty(Comment2.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: false,
      configurable: true
    });
    return Comment2;
  }(DataNode);
  exports.Comment = Comment;
  var ProcessingInstruction = function(_super) {
    __extends(ProcessingInstruction2, _super);
    function ProcessingInstruction2(name, data) {
      var _this = _super.call(this, data) || this;
      _this.name = name;
      _this.type = domelementtype_1.ElementType.Directive;
      return _this;
    }
    Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    return ProcessingInstruction2;
  }(DataNode);
  exports.ProcessingInstruction = ProcessingInstruction;
  var NodeWithChildren = function(_super) {
    __extends(NodeWithChildren2, _super);
    function NodeWithChildren2(children) {
      var _this = _super.call(this) || this;
      _this.children = children;
      return _this;
    }
    Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
      get: function() {
        var _a;
        return (_a = this.children[0]) !== null && _a !== undefined ? _a : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
      get: function() {
        return this.children;
      },
      set: function(children) {
        this.children = children;
      },
      enumerable: false,
      configurable: true
    });
    return NodeWithChildren2;
  }(Node);
  exports.NodeWithChildren = NodeWithChildren;
  var CDATA = function(_super) {
    __extends(CDATA2, _super);
    function CDATA2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1.ElementType.CDATA;
      return _this;
    }
    Object.defineProperty(CDATA2.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: false,
      configurable: true
    });
    return CDATA2;
  }(NodeWithChildren);
  exports.CDATA = CDATA;
  var Document = function(_super) {
    __extends(Document2, _super);
    function Document2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1.ElementType.Root;
      return _this;
    }
    Object.defineProperty(Document2.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: false,
      configurable: true
    });
    return Document2;
  }(NodeWithChildren);
  exports.Document = Document;
  var Element = function(_super) {
    __extends(Element2, _super);
    function Element2(name, attribs, children, type) {
      if (children === undefined) {
        children = [];
      }
      if (type === undefined) {
        type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
      }
      var _this = _super.call(this, children) || this;
      _this.name = name;
      _this.attribs = attribs;
      _this.type = type;
      return _this;
    }
    Object.defineProperty(Element2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "tagName", {
      get: function() {
        return this.name;
      },
      set: function(name) {
        this.name = name;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "attributes", {
      get: function() {
        var _this = this;
        return Object.keys(this.attribs).map(function(name) {
          var _a, _b;
          return {
            name,
            value: _this.attribs[name],
            namespace: (_a = _this["x-attribsNamespace"]) === null || _a === undefined ? undefined : _a[name],
            prefix: (_b = _this["x-attribsPrefix"]) === null || _b === undefined ? undefined : _b[name]
          };
        });
      },
      enumerable: false,
      configurable: true
    });
    return Element2;
  }(NodeWithChildren);
  exports.Element = Element;
  exports.isTag = isTag;
  exports.isCDATA = isCDATA;
  exports.isText = isText;
  exports.isComment = isComment;
  exports.isDirective = isDirective;
  exports.isDocument = isDocument;
  exports.hasChildren = hasChildren;
  exports.cloneNode = cloneNode;
});

// node_modules/domhandler/lib/index.js
var require_lib2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DomHandler = undefined;
  var domelementtype_1 = require_lib();
  var node_js_1 = require_node();
  __exportStar(require_node(), exports);
  var defaultOpts = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
  };
  var DomHandler = function() {
    function DomHandler2(callback, options, elementCB) {
      this.dom = [];
      this.root = new node_js_1.Document(this.dom);
      this.done = false;
      this.tagStack = [this.root];
      this.lastNode = null;
      this.parser = null;
      if (typeof options === "function") {
        elementCB = options;
        options = defaultOpts;
      }
      if (typeof callback === "object") {
        options = callback;
        callback = undefined;
      }
      this.callback = callback !== null && callback !== undefined ? callback : null;
      this.options = options !== null && options !== undefined ? options : defaultOpts;
      this.elementCB = elementCB !== null && elementCB !== undefined ? elementCB : null;
    }
    DomHandler2.prototype.onparserinit = function(parser) {
      this.parser = parser;
    };
    DomHandler2.prototype.onreset = function() {
      this.dom = [];
      this.root = new node_js_1.Document(this.dom);
      this.done = false;
      this.tagStack = [this.root];
      this.lastNode = null;
      this.parser = null;
    };
    DomHandler2.prototype.onend = function() {
      if (this.done)
        return;
      this.done = true;
      this.parser = null;
      this.handleCallback(null);
    };
    DomHandler2.prototype.onerror = function(error) {
      this.handleCallback(error);
    };
    DomHandler2.prototype.onclosetag = function() {
      this.lastNode = null;
      var elem = this.tagStack.pop();
      if (this.options.withEndIndices) {
        elem.endIndex = this.parser.endIndex;
      }
      if (this.elementCB)
        this.elementCB(elem);
    };
    DomHandler2.prototype.onopentag = function(name, attribs) {
      var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
      var element = new node_js_1.Element(name, attribs, undefined, type);
      this.addNode(element);
      this.tagStack.push(element);
    };
    DomHandler2.prototype.ontext = function(data) {
      var lastNode = this.lastNode;
      if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
        lastNode.data += data;
        if (this.options.withEndIndices) {
          lastNode.endIndex = this.parser.endIndex;
        }
      } else {
        var node = new node_js_1.Text(data);
        this.addNode(node);
        this.lastNode = node;
      }
    };
    DomHandler2.prototype.oncomment = function(data) {
      if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
        this.lastNode.data += data;
        return;
      }
      var node = new node_js_1.Comment(data);
      this.addNode(node);
      this.lastNode = node;
    };
    DomHandler2.prototype.oncommentend = function() {
      this.lastNode = null;
    };
    DomHandler2.prototype.oncdatastart = function() {
      var text = new node_js_1.Text("");
      var node = new node_js_1.CDATA([text]);
      this.addNode(node);
      text.parent = node;
      this.lastNode = text;
    };
    DomHandler2.prototype.oncdataend = function() {
      this.lastNode = null;
    };
    DomHandler2.prototype.onprocessinginstruction = function(name, data) {
      var node = new node_js_1.ProcessingInstruction(name, data);
      this.addNode(node);
    };
    DomHandler2.prototype.handleCallback = function(error) {
      if (typeof this.callback === "function") {
        this.callback(error, this.dom);
      } else if (error) {
        throw error;
      }
    };
    DomHandler2.prototype.addNode = function(node) {
      var parent = this.tagStack[this.tagStack.length - 1];
      var previousSibling = parent.children[parent.children.length - 1];
      if (this.options.withStartIndices) {
        node.startIndex = this.parser.startIndex;
      }
      if (this.options.withEndIndices) {
        node.endIndex = this.parser.endIndex;
      }
      parent.children.push(node);
      if (previousSibling) {
        node.prev = previousSibling;
        previousSibling.next = node;
      }
      node.parent = parent;
      this.lastNode = null;
    };
    return DomHandler2;
  }();
  exports.DomHandler = DomHandler;
  exports.default = DomHandler;
});

// node_modules/entities/lib/generated/encode-html.js
var require_encode_html = __commonJS((exports) => {
  var restoreDiff = function(arr) {
    for (var i = 1;i < arr.length; i++) {
      arr[i][0] += arr[i - 1][0] + 1;
    }
    return arr;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = new Map(restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
});

// node_modules/entities/lib/escape.js
var require_escape = __commonJS((exports) => {
  var encodeXML = function(str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = exports.xmlReplacer.exec(str)) !== null) {
      var i = match.index;
      var char = str.charCodeAt(i);
      var next = xmlCodeMap.get(char);
      if (next !== undefined) {
        ret += str.substring(lastIdx, i) + next;
        lastIdx = i + 1;
      } else {
        ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports.getCodePoint)(str, i).toString(16), ";");
        lastIdx = exports.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
      }
    }
    return ret + str.substr(lastIdx);
  };
  var getEscaper = function(regex, map) {
    return function escape(data) {
      var match;
      var lastIdx = 0;
      var result = "";
      while (match = regex.exec(data)) {
        if (lastIdx !== match.index) {
          result += data.substring(lastIdx, match.index);
        }
        result += map.get(match[0].charCodeAt(0));
        lastIdx = match.index + 1;
      }
      return result + data.substring(lastIdx);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = undefined;
  exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  var xmlCodeMap = new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  exports.getCodePoint = String.prototype.codePointAt != null ? function(str, index) {
    return str.codePointAt(index);
  } : function(c, index) {
    return (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index);
  };
  exports.encodeXML = encodeXML;
  exports.escape = encodeXML;
  exports.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  exports.escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  exports.escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
});

// node_modules/entities/lib/encode.js
var require_encode = __commonJS((exports) => {
  var encodeHTML = function(data) {
    return encodeHTMLTrieRe(htmlReplacer, data);
  };
  var encodeNonAsciiHTML = function(data) {
    return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
  };
  var encodeHTMLTrieRe = function(regExp, str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = regExp.exec(str)) !== null) {
      var i = match.index;
      ret += str.substring(lastIdx, i);
      var char = str.charCodeAt(i);
      var next = encode_html_js_1.default.get(char);
      if (typeof next === "object") {
        if (i + 1 < str.length) {
          var nextChar = str.charCodeAt(i + 1);
          var value = typeof next.n === "number" ? next.n === nextChar ? next.o : undefined : next.n.get(nextChar);
          if (value !== undefined) {
            ret += value;
            lastIdx = regExp.lastIndex += 1;
            continue;
          }
        }
        next = next.v;
      }
      if (next !== undefined) {
        ret += next;
        lastIdx = i + 1;
      } else {
        var cp = (0, escape_js_1.getCodePoint)(str, i);
        ret += "&#x".concat(cp.toString(16), ";");
        lastIdx = regExp.lastIndex += Number(cp !== char);
      }
    }
    return ret + str.substr(lastIdx);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodeNonAsciiHTML = exports.encodeHTML = undefined;
  var encode_html_js_1 = __importDefault(require_encode_html());
  var escape_js_1 = require_escape();
  var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
  exports.encodeHTML = encodeHTML;
  exports.encodeNonAsciiHTML = encodeNonAsciiHTML;
});

// node_modules/entities/lib/index.js
var require_lib3 = __commonJS((exports) => {
  var decode = function(data, options) {
    if (options === undefined) {
      options = EntityLevel.XML;
    }
    var level = typeof options === "number" ? options : options.level;
    if (level === EntityLevel.HTML) {
      var mode = typeof options === "object" ? options.mode : undefined;
      return (0, decode_js_1.decodeHTML)(data, mode);
    }
    return (0, decode_js_1.decodeXML)(data);
  };
  var decodeStrict = function(data, options) {
    var _a;
    if (options === undefined) {
      options = EntityLevel.XML;
    }
    var opts = typeof options === "number" ? { level: options } : options;
    (_a = opts.mode) !== null && _a !== undefined || (opts.mode = decode_js_1.DecodingMode.Strict);
    return decode(data, opts);
  };
  var encode = function(data, options) {
    if (options === undefined) {
      options = EntityLevel.XML;
    }
    var opts = typeof options === "number" ? { level: options } : options;
    if (opts.mode === EncodingMode.UTF8)
      return (0, escape_js_1.escapeUTF8)(data);
    if (opts.mode === EncodingMode.Attribute)
      return (0, escape_js_1.escapeAttribute)(data);
    if (opts.mode === EncodingMode.Text)
      return (0, escape_js_1.escapeText)(data);
    if (opts.level === EntityLevel.HTML) {
      if (opts.mode === EncodingMode.ASCII) {
        return (0, encode_js_1.encodeNonAsciiHTML)(data);
      }
      return (0, encode_js_1.encodeHTML)(data);
    }
    return (0, escape_js_1.encodeXML)(data);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLAttribute = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.DecodingMode = exports.EntityDecoder = exports.encodeHTML5 = exports.encodeHTML4 = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = exports.EncodingMode = exports.EntityLevel = undefined;
  var decode_js_1 = require_decode();
  var encode_js_1 = require_encode();
  var escape_js_1 = require_escape();
  var EntityLevel;
  (function(EntityLevel2) {
    EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
    EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
  })(EntityLevel = exports.EntityLevel || (exports.EntityLevel = {}));
  var EncodingMode;
  (function(EncodingMode2) {
    EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
    EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
    EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
    EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
    EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
  })(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));
  exports.decode = decode;
  exports.decodeStrict = decodeStrict;
  exports.encode = encode;
  var escape_js_2 = require_escape();
  Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
    return escape_js_2.encodeXML;
  } });
  Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
    return escape_js_2.escape;
  } });
  Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
    return escape_js_2.escapeUTF8;
  } });
  Object.defineProperty(exports, "escapeAttribute", { enumerable: true, get: function() {
    return escape_js_2.escapeAttribute;
  } });
  Object.defineProperty(exports, "escapeText", { enumerable: true, get: function() {
    return escape_js_2.escapeText;
  } });
  var encode_js_2 = require_encode();
  Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeNonAsciiHTML;
  } });
  Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  var decode_js_2 = require_decode();
  Object.defineProperty(exports, "EntityDecoder", { enumerable: true, get: function() {
    return decode_js_2.EntityDecoder;
  } });
  Object.defineProperty(exports, "DecodingMode", { enumerable: true, get: function() {
    return decode_js_2.DecodingMode;
  } });
  Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
  Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTMLAttribute", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLAttribute;
  } });
  Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
});

// node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.attributeNames = exports.elementNames = undefined;
  exports.elementNames = new Map([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
  ].map(function(val) {
    return [val.toLowerCase(), val];
  }));
  exports.attributeNames = new Map([
    "definitionURL",
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan"
  ].map(function(val) {
    return [val.toLowerCase(), val];
  }));
});

// node_modules/dom-serializer/lib/index.js
var require_lib4 = __commonJS((exports) => {
  var replaceQuotes = function(value) {
    return value.replace(/"/g, "&quot;");
  };
  var formatAttributes = function(attributes, opts) {
    var _a;
    if (!attributes)
      return;
    var encode = ((_a = opts.encodeEntities) !== null && _a !== undefined ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1.encodeXML : entities_1.escapeAttribute;
    return Object.keys(attributes).map(function(key) {
      var _a2, _b;
      var value = (_a2 = attributes[key]) !== null && _a2 !== undefined ? _a2 : "";
      if (opts.xmlMode === "foreign") {
        key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== undefined ? _b : key;
      }
      if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
        return key;
      }
      return "".concat(key, "=\"").concat(encode(value), "\"");
    }).join(" ");
  };
  var render = function(node, options) {
    if (options === undefined) {
      options = {};
    }
    var nodes = "length" in node ? node : [node];
    var output = "";
    for (var i = 0;i < nodes.length; i++) {
      output += renderNode(nodes[i], options);
    }
    return output;
  };
  var renderNode = function(node, options) {
    switch (node.type) {
      case ElementType.Root:
        return render(node.children, options);
      case ElementType.Doctype:
      case ElementType.Directive:
        return renderDirective(node);
      case ElementType.Comment:
        return renderComment(node);
      case ElementType.CDATA:
        return renderCdata(node);
      case ElementType.Script:
      case ElementType.Style:
      case ElementType.Tag:
        return renderTag(node, options);
      case ElementType.Text:
        return renderText(node, options);
    }
  };
  var renderTag = function(elem, opts) {
    var _a;
    if (opts.xmlMode === "foreign") {
      elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== undefined ? _a : elem.name;
      if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: false });
      }
    }
    if (!opts.xmlMode && foreignElements.has(elem.name)) {
      opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
    }
    var tag = "<".concat(elem.name);
    var attribs = formatAttributes(elem.attribs, opts);
    if (attribs) {
      tag += " ".concat(attribs);
    }
    if (elem.children.length === 0 && (opts.xmlMode ? opts.selfClosingTags !== false : opts.selfClosingTags && singleTag.has(elem.name))) {
      if (!opts.xmlMode)
        tag += " ";
      tag += "/>";
    } else {
      tag += ">";
      if (elem.children.length > 0) {
        tag += render(elem.children, opts);
      }
      if (opts.xmlMode || !singleTag.has(elem.name)) {
        tag += "</".concat(elem.name, ">");
      }
    }
    return tag;
  };
  var renderDirective = function(elem) {
    return "<".concat(elem.data, ">");
  };
  var renderText = function(elem, opts) {
    var _a;
    var data = elem.data || "";
    if (((_a = opts.encodeEntities) !== null && _a !== undefined ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
      data = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(data) : (0, entities_1.escapeText)(data);
    }
    return data;
  };
  var renderCdata = function(elem) {
    return "<![CDATA[".concat(elem.children[0].data, "]]>");
  };
  var renderComment = function(elem) {
    return "<!--".concat(elem.data, "-->");
  };
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.render = undefined;
  var ElementType = __importStar(require_lib());
  var entities_1 = require_lib3();
  var foreignNames_js_1 = require_foreignNames();
  var unencodedElements = new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript"
  ]);
  var singleTag = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  exports.render = render;
  exports.default = render;
  var foreignModeIntegrationPoints = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title"
  ]);
  var foreignElements = new Set(["svg", "math"]);
});

// node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS((exports) => {
  var getOuterHTML = function(node, options) {
    return (0, dom_serializer_1.default)(node, options);
  };
  var getInnerHTML = function(node, options) {
    return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
      return getOuterHTML(node2, options);
    }).join("") : "";
  };
  var getText = function(node) {
    if (Array.isArray(node))
      return node.map(getText).join("");
    if ((0, domhandler_1.isTag)(node))
      return node.name === "br" ? "\n" : getText(node.children);
    if ((0, domhandler_1.isCDATA)(node))
      return getText(node.children);
    if ((0, domhandler_1.isText)(node))
      return node.data;
    return "";
  };
  var textContent = function(node) {
    if (Array.isArray(node))
      return node.map(textContent).join("");
    if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
      return textContent(node.children);
    }
    if ((0, domhandler_1.isText)(node))
      return node.data;
    return "";
  };
  var innerText = function(node) {
    if (Array.isArray(node))
      return node.map(innerText).join("");
    if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
      return innerText(node.children);
    }
    if ((0, domhandler_1.isText)(node))
      return node.data;
    return "";
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = undefined;
  var domhandler_1 = require_lib2();
  var dom_serializer_1 = __importDefault(require_lib4());
  var domelementtype_1 = require_lib();
  exports.getOuterHTML = getOuterHTML;
  exports.getInnerHTML = getInnerHTML;
  exports.getText = getText;
  exports.textContent = textContent;
  exports.innerText = innerText;
});

// node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS((exports) => {
  var getChildren = function(elem) {
    return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
  };
  var getParent = function(elem) {
    return elem.parent || null;
  };
  var getSiblings = function(elem) {
    var _a, _b;
    var parent = getParent(elem);
    if (parent != null)
      return getChildren(parent);
    var siblings = [elem];
    var { prev, next } = elem;
    while (prev != null) {
      siblings.unshift(prev);
      _a = prev, prev = _a.prev;
    }
    while (next != null) {
      siblings.push(next);
      _b = next, next = _b.next;
    }
    return siblings;
  };
  var getAttributeValue = function(elem, name) {
    var _a;
    return (_a = elem.attribs) === null || _a === undefined ? undefined : _a[name];
  };
  var hasAttrib = function(elem, name) {
    return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
  };
  var getName = function(elem) {
    return elem.name;
  };
  var nextElementSibling = function(elem) {
    var _a;
    var next = elem.next;
    while (next !== null && !(0, domhandler_1.isTag)(next))
      _a = next, next = _a.next;
    return next;
  };
  var prevElementSibling = function(elem) {
    var _a;
    var prev = elem.prev;
    while (prev !== null && !(0, domhandler_1.isTag)(prev))
      _a = prev, prev = _a.prev;
    return prev;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = undefined;
  var domhandler_1 = require_lib2();
  exports.getChildren = getChildren;
  exports.getParent = getParent;
  exports.getSiblings = getSiblings;
  exports.getAttributeValue = getAttributeValue;
  exports.hasAttrib = hasAttrib;
  exports.getName = getName;
  exports.nextElementSibling = nextElementSibling;
  exports.prevElementSibling = prevElementSibling;
});

// node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS((exports) => {
  var removeElement = function(elem) {
    if (elem.prev)
      elem.prev.next = elem.next;
    if (elem.next)
      elem.next.prev = elem.prev;
    if (elem.parent) {
      var childs = elem.parent.children;
      var childsIndex = childs.lastIndexOf(elem);
      if (childsIndex >= 0) {
        childs.splice(childsIndex, 1);
      }
    }
    elem.next = null;
    elem.prev = null;
    elem.parent = null;
  };
  var replaceElement = function(elem, replacement) {
    var prev = replacement.prev = elem.prev;
    if (prev) {
      prev.next = replacement;
    }
    var next = replacement.next = elem.next;
    if (next) {
      next.prev = replacement;
    }
    var parent = replacement.parent = elem.parent;
    if (parent) {
      var childs = parent.children;
      childs[childs.lastIndexOf(elem)] = replacement;
      elem.parent = null;
    }
  };
  var appendChild = function(parent, child) {
    removeElement(child);
    child.next = null;
    child.parent = parent;
    if (parent.children.push(child) > 1) {
      var sibling = parent.children[parent.children.length - 2];
      sibling.next = child;
      child.prev = sibling;
    } else {
      child.prev = null;
    }
  };
  var append = function(elem, next) {
    removeElement(next);
    var parent = elem.parent;
    var currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
      currNext.prev = next;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.lastIndexOf(currNext), 0, next);
      }
    } else if (parent) {
      parent.children.push(next);
    }
  };
  var prependChild = function(parent, child) {
    removeElement(child);
    child.parent = parent;
    child.prev = null;
    if (parent.children.unshift(child) !== 1) {
      var sibling = parent.children[1];
      sibling.prev = child;
      child.next = sibling;
    } else {
      child.next = null;
    }
  };
  var prepend = function(elem, prev) {
    removeElement(prev);
    var parent = elem.parent;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.indexOf(elem), 0, prev);
    }
    if (elem.prev) {
      elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = undefined;
  exports.removeElement = removeElement;
  exports.replaceElement = replaceElement;
  exports.appendChild = appendChild;
  exports.append = append;
  exports.prependChild = prependChild;
  exports.prepend = prepend;
});

// node_modules/domutils/lib/querying.js
var require_querying = __commonJS((exports) => {
  var filter = function(test, node, recurse, limit) {
    if (recurse === undefined) {
      recurse = true;
    }
    if (limit === undefined) {
      limit = Infinity;
    }
    return find(test, Array.isArray(node) ? node : [node], recurse, limit);
  };
  var find = function(test, nodes, recurse, limit) {
    var result = [];
    var nodeStack = [nodes];
    var indexStack = [0];
    for (;; ) {
      if (indexStack[0] >= nodeStack[0].length) {
        if (indexStack.length === 1) {
          return result;
        }
        nodeStack.shift();
        indexStack.shift();
        continue;
      }
      var elem = nodeStack[0][indexStack[0]++];
      if (test(elem)) {
        result.push(elem);
        if (--limit <= 0)
          return result;
      }
      if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
        indexStack.unshift(0);
        nodeStack.unshift(elem.children);
      }
    }
  };
  var findOneChild = function(test, nodes) {
    return nodes.find(test);
  };
  var findOne = function(test, nodes, recurse) {
    if (recurse === undefined) {
      recurse = true;
    }
    var elem = null;
    for (var i = 0;i < nodes.length && !elem; i++) {
      var node = nodes[i];
      if (!(0, domhandler_1.isTag)(node)) {
        continue;
      } else if (test(node)) {
        elem = node;
      } else if (recurse && node.children.length > 0) {
        elem = findOne(test, node.children, true);
      }
    }
    return elem;
  };
  var existsOne = function(test, nodes) {
    return nodes.some(function(checked) {
      return (0, domhandler_1.isTag)(checked) && (test(checked) || existsOne(test, checked.children));
    });
  };
  var findAll = function(test, nodes) {
    var result = [];
    var nodeStack = [nodes];
    var indexStack = [0];
    for (;; ) {
      if (indexStack[0] >= nodeStack[0].length) {
        if (nodeStack.length === 1) {
          return result;
        }
        nodeStack.shift();
        indexStack.shift();
        continue;
      }
      var elem = nodeStack[0][indexStack[0]++];
      if (!(0, domhandler_1.isTag)(elem))
        continue;
      if (test(elem))
        result.push(elem);
      if (elem.children.length > 0) {
        indexStack.unshift(0);
        nodeStack.unshift(elem.children);
      }
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = undefined;
  var domhandler_1 = require_lib2();
  exports.filter = filter;
  exports.find = find;
  exports.findOneChild = findOneChild;
  exports.findOne = findOne;
  exports.existsOne = existsOne;
  exports.findAll = findAll;
});

// node_modules/domutils/lib/legacy.js
var require_legacy = __commonJS((exports) => {
  var getAttribCheck = function(attrib, value) {
    if (typeof value === "function") {
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
      };
    }
    return function(elem) {
      return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
    };
  };
  var combineFuncs = function(a, b) {
    return function(elem) {
      return a(elem) || b(elem);
    };
  };
  var compileTest = function(options) {
    var funcs = Object.keys(options).map(function(key) {
      var value = options[key];
      return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
  };
  var testElement = function(options, node) {
    var test = compileTest(options);
    return test ? test(node) : true;
  };
  var getElements = function(options, nodes, recurse, limit) {
    if (limit === undefined) {
      limit = Infinity;
    }
    var test = compileTest(options);
    return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
  };
  var getElementById = function(id, nodes, recurse) {
    if (recurse === undefined) {
      recurse = true;
    }
    if (!Array.isArray(nodes))
      nodes = [nodes];
    return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
  };
  var getElementsByTagName = function(tagName, nodes, recurse, limit) {
    if (recurse === undefined) {
      recurse = true;
    }
    if (limit === undefined) {
      limit = Infinity;
    }
    return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
  };
  var getElementsByTagType = function(type, nodes, recurse, limit) {
    if (recurse === undefined) {
      recurse = true;
    }
    if (limit === undefined) {
      limit = Infinity;
    }
    return (0, querying_js_1.filter)(Checks["tag_type"](type), nodes, recurse, limit);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = undefined;
  var domhandler_1 = require_lib2();
  var querying_js_1 = require_querying();
  var Checks = {
    tag_name: function(name) {
      if (typeof name === "function") {
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && name(elem.name);
        };
      } else if (name === "*") {
        return domhandler_1.isTag;
      }
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.name === name;
      };
    },
    tag_type: function(type) {
      if (typeof type === "function") {
        return function(elem) {
          return type(elem.type);
        };
      }
      return function(elem) {
        return elem.type === type;
      };
    },
    tag_contains: function(data) {
      if (typeof data === "function") {
        return function(elem) {
          return (0, domhandler_1.isText)(elem) && data(elem.data);
        };
      }
      return function(elem) {
        return (0, domhandler_1.isText)(elem) && elem.data === data;
      };
    }
  };
  exports.testElement = testElement;
  exports.getElements = getElements;
  exports.getElementById = getElementById;
  exports.getElementsByTagName = getElementsByTagName;
  exports.getElementsByTagType = getElementsByTagType;
});

// node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS((exports) => {
  var removeSubsets = function(nodes) {
    var idx = nodes.length;
    while (--idx >= 0) {
      var node = nodes[idx];
      if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
        nodes.splice(idx, 1);
        continue;
      }
      for (var ancestor = node.parent;ancestor; ancestor = ancestor.parent) {
        if (nodes.includes(ancestor)) {
          nodes.splice(idx, 1);
          break;
        }
      }
    }
    return nodes;
  };
  var compareDocumentPosition = function(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
      return 0;
    }
    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return DocumentPosition.DISCONNECTED;
    }
    var sharedParent = aParents[idx - 1];
    var siblings = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
      }
      return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
      return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
  };
  var uniqueSort = function(nodes) {
    nodes = nodes.filter(function(node, i, arr) {
      return !arr.includes(node, i + 1);
    });
    nodes.sort(function(a, b) {
      var relative = compareDocumentPosition(a, b);
      if (relative & DocumentPosition.PRECEDING) {
        return -1;
      } else if (relative & DocumentPosition.FOLLOWING) {
        return 1;
      }
      return 0;
    });
    return nodes;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uniqueSort = exports.compareDocumentPosition = exports.DocumentPosition = exports.removeSubsets = undefined;
  var domhandler_1 = require_lib2();
  exports.removeSubsets = removeSubsets;
  var DocumentPosition;
  (function(DocumentPosition2) {
    DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition = exports.DocumentPosition || (exports.DocumentPosition = {}));
  exports.compareDocumentPosition = compareDocumentPosition;
  exports.uniqueSort = uniqueSort;
});

// node_modules/domutils/lib/feeds.js
var require_feeds = __commonJS((exports) => {
  var getFeed = function(doc) {
    var feedRoot = getOneElement(isValidFeed, doc);
    return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
  };
  var getAtomFeed = function(feedRoot) {
    var _a;
    var childs = feedRoot.children;
    var feed = {
      type: "atom",
      items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
        var _a2;
        var children = item.children;
        var entry = { media: getMediaElements(children) };
        addConditionally(entry, "id", "id", children);
        addConditionally(entry, "title", "title", children);
        var href2 = (_a2 = getOneElement("link", children)) === null || _a2 === undefined ? undefined : _a2.attribs["href"];
        if (href2) {
          entry.link = href2;
        }
        var description = fetch("summary", children) || fetch("content", children);
        if (description) {
          entry.description = description;
        }
        var pubDate = fetch("updated", children);
        if (pubDate) {
          entry.pubDate = new Date(pubDate);
        }
        return entry;
      })
    };
    addConditionally(feed, "id", "id", childs);
    addConditionally(feed, "title", "title", childs);
    var href = (_a = getOneElement("link", childs)) === null || _a === undefined ? undefined : _a.attribs["href"];
    if (href) {
      feed.link = href;
    }
    addConditionally(feed, "description", "subtitle", childs);
    var updated = fetch("updated", childs);
    if (updated) {
      feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "email", childs, true);
    return feed;
  };
  var getRssFeed = function(feedRoot) {
    var _a, _b;
    var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === undefined ? undefined : _a.children) !== null && _b !== undefined ? _b : [];
    var feed = {
      type: feedRoot.name.substr(0, 3),
      id: "",
      items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
        var children = item.children;
        var entry = { media: getMediaElements(children) };
        addConditionally(entry, "id", "guid", children);
        addConditionally(entry, "title", "title", children);
        addConditionally(entry, "link", "link", children);
        addConditionally(entry, "description", "description", children);
        var pubDate = fetch("pubDate", children) || fetch("dc:date", children);
        if (pubDate)
          entry.pubDate = new Date(pubDate);
        return entry;
      })
    };
    addConditionally(feed, "title", "title", childs);
    addConditionally(feed, "link", "link", childs);
    addConditionally(feed, "description", "description", childs);
    var updated = fetch("lastBuildDate", childs);
    if (updated) {
      feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "managingEditor", childs, true);
    return feed;
  };
  var getMediaElements = function(where) {
    return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function(elem) {
      var attribs = elem.attribs;
      var media = {
        medium: attribs["medium"],
        isDefault: !!attribs["isDefault"]
      };
      for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING;_i < MEDIA_KEYS_STRING_1.length; _i++) {
        var attrib = MEDIA_KEYS_STRING_1[_i];
        if (attribs[attrib]) {
          media[attrib] = attribs[attrib];
        }
      }
      for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT;_a < MEDIA_KEYS_INT_1.length; _a++) {
        var attrib = MEDIA_KEYS_INT_1[_a];
        if (attribs[attrib]) {
          media[attrib] = parseInt(attribs[attrib], 10);
        }
      }
      if (attribs["expression"]) {
        media.expression = attribs["expression"];
      }
      return media;
    });
  };
  var getOneElement = function(tagName, node) {
    return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
  };
  var fetch = function(tagName, where, recurse) {
    if (recurse === undefined) {
      recurse = false;
    }
    return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
  };
  var addConditionally = function(obj, prop, tagName, where, recurse) {
    if (recurse === undefined) {
      recurse = false;
    }
    var val = fetch(tagName, where, recurse);
    if (val)
      obj[prop] = val;
  };
  var isValidFeed = function(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getFeed = undefined;
  var stringify_js_1 = require_stringify();
  var legacy_js_1 = require_legacy();
  exports.getFeed = getFeed;
  var MEDIA_KEYS_STRING = ["url", "type", "lang"];
  var MEDIA_KEYS_INT = [
    "fileSize",
    "bitrate",
    "framerate",
    "samplingrate",
    "channels",
    "duration",
    "height",
    "width"
  ];
});

// node_modules/domutils/lib/index.js
var require_lib5 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = undefined;
  __exportStar(require_stringify(), exports);
  __exportStar(require_traversal(), exports);
  __exportStar(require_manipulation(), exports);
  __exportStar(require_querying(), exports);
  __exportStar(require_legacy(), exports);
  __exportStar(require_helpers(), exports);
  __exportStar(require_feeds(), exports);
  var domhandler_1 = require_lib2();
  Object.defineProperty(exports, "isTag", { enumerable: true, get: function() {
    return domhandler_1.isTag;
  } });
  Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function() {
    return domhandler_1.isCDATA;
  } });
  Object.defineProperty(exports, "isText", { enumerable: true, get: function() {
    return domhandler_1.isText;
  } });
  Object.defineProperty(exports, "isComment", { enumerable: true, get: function() {
    return domhandler_1.isComment;
  } });
  Object.defineProperty(exports, "isDocument", { enumerable: true, get: function() {
    return domhandler_1.isDocument;
  } });
  Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function() {
    return domhandler_1.hasChildren;
  } });
});

// node_modules/htmlparser2/lib/index.js
var require_lib6 = __commonJS((exports) => {
  var parseDocument = function(data, options) {
    var handler = new domhandler_1.DomHandler(undefined, options);
    new Parser_js_1.Parser(handler, options).end(data);
    return handler.root;
  };
  var parseDOM = function(data, options) {
    return parseDocument(data, options).children;
  };
  var createDomStream = function(callback, options, elementCallback) {
    var handler = new domhandler_1.DomHandler(callback, options, elementCallback);
    return new Parser_js_1.Parser(handler, options);
  };
  var parseFeed = function(feed, options) {
    if (options === undefined) {
      options = parseFeedDefaultOptions;
    }
    return (0, domutils_1.getFeed)(parseDOM(feed, options));
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DomUtils = exports.parseFeed = exports.getFeed = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.parseDocument = exports.DefaultHandler = exports.DomHandler = exports.Parser = undefined;
  var Parser_js_1 = require_Parser();
  var Parser_js_2 = require_Parser();
  Object.defineProperty(exports, "Parser", { enumerable: true, get: function() {
    return Parser_js_2.Parser;
  } });
  var domhandler_1 = require_lib2();
  var domhandler_2 = require_lib2();
  Object.defineProperty(exports, "DomHandler", { enumerable: true, get: function() {
    return domhandler_2.DomHandler;
  } });
  Object.defineProperty(exports, "DefaultHandler", { enumerable: true, get: function() {
    return domhandler_2.DomHandler;
  } });
  exports.parseDocument = parseDocument;
  exports.parseDOM = parseDOM;
  exports.createDomStream = createDomStream;
  var Tokenizer_js_1 = require_Tokenizer();
  Object.defineProperty(exports, "Tokenizer", { enumerable: true, get: function() {
    return __importDefault(Tokenizer_js_1).default;
  } });
  exports.ElementType = __importStar(require_lib());
  var domutils_1 = require_lib5();
  var domutils_2 = require_lib5();
  Object.defineProperty(exports, "getFeed", { enumerable: true, get: function() {
    return domutils_2.getFeed;
  } });
  var parseFeedDefaultOptions = { xmlMode: true };
  exports.parseFeed = parseFeed;
  exports.DomUtils = __importStar(require_lib5());
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS((exports, module) => {
  module.exports = (string) => {
    if (typeof string !== "string") {
      throw new TypeError("Expected a string");
    }
    return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  };
});

// node_modules/is-plain-object/dist/is-plain-object.js
var require_is_plain_object = __commonJS((exports) => {
  var isObject = function(o) {
    return Object.prototype.toString.call(o) === "[object Object]";
  };
  var isPlainObject = function(o) {
    var ctor, prot;
    if (isObject(o) === false)
      return false;
    ctor = o.constructor;
    if (ctor === undefined)
      return true;
    prot = ctor.prototype;
    if (isObject(prot) === false)
      return false;
    if (prot.hasOwnProperty("isPrototypeOf") === false) {
      return false;
    }
    return true;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  /*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  exports.isPlainObject = isPlainObject;
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS((exports, module) => {
  var isNonNullObject = function(value) {
    return !!value && typeof value === "object";
  };
  var isSpecial = function(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
  };
  var isReactElement = function(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  };
  var emptyTarget = function(val) {
    return Array.isArray(val) ? [] : {};
  };
  var cloneUnlessOtherwiseSpecified = function(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  };
  var defaultArrayMerge = function(target, source, options) {
    return target.concat(source).map(function(element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  };
  var getMergeFunction = function(key, options) {
    if (!options.customMerge) {
      return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === "function" ? customMerge : deepmerge;
  };
  var getEnumerableOwnPropertySymbols = function(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
      return Object.propertyIsEnumerable.call(target, symbol);
    }) : [];
  };
  var getKeys = function(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  };
  var propertyIsOnObject = function(object, property) {
    try {
      return property in object;
    } catch (_) {
      return false;
    }
  };
  var propertyIsUnsafe = function(target, key) {
    return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
  };
  var mergeObject = function(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys(source).forEach(function(key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  };
  var deepmerge = function(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  };
  var isMergeableObject = function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
  deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) {
      throw new Error("first argument should be an array");
    }
    return array.reduce(function(prev, next) {
      return deepmerge(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge;
  module.exports = deepmerge_1;
});

// node_modules/parse-srcset/src/parse-srcset.js
var require_parse_srcset = __commonJS((exports, module) => {
  (function(root, factory) {
    if (typeof define === "function" && define.amd) {
      define([], factory);
    } else if (typeof module === "object" && exports) {
      module.exports = factory();
    } else {
      root.parseSrcset = factory();
    }
  })(exports, function() {
    return function(input) {
      function isSpace(c2) {
        return c2 === " " || c2 === "\t" || c2 === `
` || c2 === "\f" || c2 === `\r`;
      }
      function collectCharacters(regEx) {
        var chars, match = regEx.exec(input.substring(pos));
        if (match) {
          chars = match[0];
          pos += chars.length;
          return chars;
        }
      }
      var inputLength = input.length, regexLeadingSpaces = /^[ \t\n\r\u000c]+/, regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/, regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/, regexTrailingCommas = /[,]+$/, regexNonNegativeInteger = /^\d+$/, regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, url, descriptors, currentDescriptor, state, c, pos = 0, candidates = [];
      while (true) {
        collectCharacters(regexLeadingCommasOrSpaces);
        if (pos >= inputLength) {
          return candidates;
        }
        url = collectCharacters(regexLeadingNotSpaces);
        descriptors = [];
        if (url.slice(-1) === ",") {
          url = url.replace(regexTrailingCommas, "");
          parseDescriptors();
        } else {
          tokenize();
        }
      }
      function tokenize() {
        collectCharacters(regexLeadingSpaces);
        currentDescriptor = "";
        state = "in descriptor";
        while (true) {
          c = input.charAt(pos);
          if (state === "in descriptor") {
            if (isSpace(c)) {
              if (currentDescriptor) {
                descriptors.push(currentDescriptor);
                currentDescriptor = "";
                state = "after descriptor";
              }
            } else if (c === ",") {
              pos += 1;
              if (currentDescriptor) {
                descriptors.push(currentDescriptor);
              }
              parseDescriptors();
              return;
            } else if (c === "(") {
              currentDescriptor = currentDescriptor + c;
              state = "in parens";
            } else if (c === "") {
              if (currentDescriptor) {
                descriptors.push(currentDescriptor);
              }
              parseDescriptors();
              return;
            } else {
              currentDescriptor = currentDescriptor + c;
            }
          } else if (state === "in parens") {
            if (c === ")") {
              currentDescriptor = currentDescriptor + c;
              state = "in descriptor";
            } else if (c === "") {
              descriptors.push(currentDescriptor);
              parseDescriptors();
              return;
            } else {
              currentDescriptor = currentDescriptor + c;
            }
          } else if (state === "after descriptor") {
            if (isSpace(c)) {
            } else if (c === "") {
              parseDescriptors();
              return;
            } else {
              state = "in descriptor";
              pos -= 1;
            }
          }
          pos += 1;
        }
      }
      function parseDescriptors() {
        var pError = false, w, d, h, i, candidate = {}, desc, lastChar, value, intVal, floatVal;
        for (i = 0;i < descriptors.length; i++) {
          desc = descriptors[i];
          lastChar = desc[desc.length - 1];
          value = desc.substring(0, desc.length - 1);
          intVal = parseInt(value, 10);
          floatVal = parseFloat(value);
          if (regexNonNegativeInteger.test(value) && lastChar === "w") {
            if (w || d) {
              pError = true;
            }
            if (intVal === 0) {
              pError = true;
            } else {
              w = intVal;
            }
          } else if (regexFloatingPoint.test(value) && lastChar === "x") {
            if (w || d || h) {
              pError = true;
            }
            if (floatVal < 0) {
              pError = true;
            } else {
              d = floatVal;
            }
          } else if (regexNonNegativeInteger.test(value) && lastChar === "h") {
            if (h || d) {
              pError = true;
            }
            if (intVal === 0) {
              pError = true;
            } else {
              h = intVal;
            }
          } else {
            pError = true;
          }
        }
        if (!pError) {
          candidate.url = url;
          if (w) {
            candidate.w = w;
          }
          if (d) {
            candidate.d = d;
          }
          if (h) {
            candidate.h = h;
          }
          candidates.push(candidate);
        } else if (console && console.log) {
          console.log("Invalid srcset descriptor found in '" + input + "' at '" + desc + "'.");
        }
      }
    };
  });
});

// node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS((exports, module) => {
  var tty = import.meta.require("node:tty");
  var isColorSupported = !(("NO_COLOR" in process.env) || process.argv.includes("--no-color")) && (("FORCE_COLOR" in process.env) || process.argv.includes("--color") || process.platform === "win32" || tty.isatty(1) && true || ("CI" in process.env));
  var formatter = (open, close, replace = open) => (input) => {
    let string = "" + input;
    let index = string.indexOf(close, open.length);
    return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
  };
  var replaceClose = (string, close, replace, index) => {
    let start = string.substring(0, index) + replace;
    let end = string.substring(index + close.length);
    let nextIndex = end.indexOf(close);
    return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;
  };
  var createColors = (enabled = isColorSupported) => ({
    isColorSupported: enabled,
    reset: enabled ? (s) => `\x1B[0m${s}\x1B[0m` : String,
    bold: enabled ? formatter("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m") : String,
    dim: enabled ? formatter("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m") : String,
    italic: enabled ? formatter("\x1B[3m", "\x1B[23m") : String,
    underline: enabled ? formatter("\x1B[4m", "\x1B[24m") : String,
    inverse: enabled ? formatter("\x1B[7m", "\x1B[27m") : String,
    hidden: enabled ? formatter("\x1B[8m", "\x1B[28m") : String,
    strikethrough: enabled ? formatter("\x1B[9m", "\x1B[29m") : String,
    black: enabled ? formatter("\x1B[30m", "\x1B[39m") : String,
    red: enabled ? formatter("\x1B[31m", "\x1B[39m") : String,
    green: enabled ? formatter("\x1B[32m", "\x1B[39m") : String,
    yellow: enabled ? formatter("\x1B[33m", "\x1B[39m") : String,
    blue: enabled ? formatter("\x1B[34m", "\x1B[39m") : String,
    magenta: enabled ? formatter("\x1B[35m", "\x1B[39m") : String,
    cyan: enabled ? formatter("\x1B[36m", "\x1B[39m") : String,
    white: enabled ? formatter("\x1B[37m", "\x1B[39m") : String,
    gray: enabled ? formatter("\x1B[90m", "\x1B[39m") : String,
    bgBlack: enabled ? formatter("\x1B[40m", "\x1B[49m") : String,
    bgRed: enabled ? formatter("\x1B[41m", "\x1B[49m") : String,
    bgGreen: enabled ? formatter("\x1B[42m", "\x1B[49m") : String,
    bgYellow: enabled ? formatter("\x1B[43m", "\x1B[49m") : String,
    bgBlue: enabled ? formatter("\x1B[44m", "\x1B[49m") : String,
    bgMagenta: enabled ? formatter("\x1B[45m", "\x1B[49m") : String,
    bgCyan: enabled ? formatter("\x1B[46m", "\x1B[49m") : String,
    bgWhite: enabled ? formatter("\x1B[47m", "\x1B[49m") : String
  });
  module.exports = createColors();
  module.exports.createColors = createColors;
});

// node_modules/postcss/lib/tokenize.js
var require_tokenize = __commonJS((exports, module) => {
  var SINGLE_QUOTE = "'".charCodeAt(0);
  var DOUBLE_QUOTE = '"'.charCodeAt(0);
  var BACKSLASH = "\\".charCodeAt(0);
  var SLASH = "/".charCodeAt(0);
  var NEWLINE = "\n".charCodeAt(0);
  var SPACE = " ".charCodeAt(0);
  var FEED = "\f".charCodeAt(0);
  var TAB = "\t".charCodeAt(0);
  var CR = "\r".charCodeAt(0);
  var OPEN_SQUARE = "[".charCodeAt(0);
  var CLOSE_SQUARE = "]".charCodeAt(0);
  var OPEN_PARENTHESES = "(".charCodeAt(0);
  var CLOSE_PARENTHESES = ")".charCodeAt(0);
  var OPEN_CURLY = "{".charCodeAt(0);
  var CLOSE_CURLY = "}".charCodeAt(0);
  var SEMICOLON = ";".charCodeAt(0);
  var ASTERISK = "*".charCodeAt(0);
  var COLON = ":".charCodeAt(0);
  var AT = "@".charCodeAt(0);
  var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
  var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
  var RE_BAD_BRACKET = /.[\n"'(/\\]/;
  var RE_HEX_ESCAPE = /[\da-f]/i;
  module.exports = function tokenizer(input, options = {}) {
    let css = input.css.valueOf();
    let ignore = options.ignoreErrors;
    let code, next, quote, content, escape;
    let escaped, escapePos, prev, n, currentToken;
    let length = css.length;
    let pos = 0;
    let buffer = [];
    let returned = [];
    function position() {
      return pos;
    }
    function unclosed(what) {
      throw input.error("Unclosed " + what, pos);
    }
    function endOfFile() {
      return returned.length === 0 && pos >= length;
    }
    function nextToken(opts) {
      if (returned.length)
        return returned.pop();
      if (pos >= length)
        return;
      let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
      code = css.charCodeAt(pos);
      switch (code) {
        case NEWLINE:
        case SPACE:
        case TAB:
        case CR:
        case FEED: {
          next = pos;
          do {
            next += 1;
            code = css.charCodeAt(next);
          } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
          currentToken = ["space", css.slice(pos, next)];
          pos = next - 1;
          break;
        }
        case OPEN_SQUARE:
        case CLOSE_SQUARE:
        case OPEN_CURLY:
        case CLOSE_CURLY:
        case COLON:
        case SEMICOLON:
        case CLOSE_PARENTHESES: {
          let controlChar = String.fromCharCode(code);
          currentToken = [controlChar, controlChar, pos];
          break;
        }
        case OPEN_PARENTHESES: {
          prev = buffer.length ? buffer.pop()[1] : "";
          n = css.charCodeAt(pos + 1);
          if (prev === "url" && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
            next = pos;
            do {
              escaped = false;
              next = css.indexOf(")", next + 1);
              if (next === -1) {
                if (ignore || ignoreUnclosed) {
                  next = pos;
                  break;
                } else {
                  unclosed("bracket");
                }
              }
              escapePos = next;
              while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped);
            currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
            pos = next;
          } else {
            next = css.indexOf(")", pos + 1);
            content = css.slice(pos, next + 1);
            if (next === -1 || RE_BAD_BRACKET.test(content)) {
              currentToken = ["(", "(", pos];
            } else {
              currentToken = ["brackets", content, pos, next];
              pos = next;
            }
          }
          break;
        }
        case SINGLE_QUOTE:
        case DOUBLE_QUOTE: {
          quote = code === SINGLE_QUOTE ? "'" : '"';
          next = pos;
          do {
            escaped = false;
            next = css.indexOf(quote, next + 1);
            if (next === -1) {
              if (ignore || ignoreUnclosed) {
                next = pos + 1;
                break;
              } else {
                unclosed("string");
              }
            }
            escapePos = next;
            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
              escapePos -= 1;
              escaped = !escaped;
            }
          } while (escaped);
          currentToken = ["string", css.slice(pos, next + 1), pos, next];
          pos = next;
          break;
        }
        case AT: {
          RE_AT_END.lastIndex = pos + 1;
          RE_AT_END.test(css);
          if (RE_AT_END.lastIndex === 0) {
            next = css.length - 1;
          } else {
            next = RE_AT_END.lastIndex - 2;
          }
          currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
          pos = next;
          break;
        }
        case BACKSLASH: {
          next = pos;
          escape = true;
          while (css.charCodeAt(next + 1) === BACKSLASH) {
            next += 1;
            escape = !escape;
          }
          code = css.charCodeAt(next + 1);
          if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
            next += 1;
            if (RE_HEX_ESCAPE.test(css.charAt(next))) {
              while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                next += 1;
              }
              if (css.charCodeAt(next + 1) === SPACE) {
                next += 1;
              }
            }
          }
          currentToken = ["word", css.slice(pos, next + 1), pos, next];
          pos = next;
          break;
        }
        default: {
          if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
            next = css.indexOf("*/", pos + 2) + 1;
            if (next === 0) {
              if (ignore || ignoreUnclosed) {
                next = css.length;
              } else {
                unclosed("comment");
              }
            }
            currentToken = ["comment", css.slice(pos, next + 1), pos, next];
            pos = next;
          } else {
            RE_WORD_END.lastIndex = pos + 1;
            RE_WORD_END.test(css);
            if (RE_WORD_END.lastIndex === 0) {
              next = css.length - 1;
            } else {
              next = RE_WORD_END.lastIndex - 2;
            }
            currentToken = ["word", css.slice(pos, next + 1), pos, next];
            buffer.push(currentToken);
            pos = next;
          }
          break;
        }
      }
      pos++;
      return currentToken;
    }
    function back(token) {
      returned.push(token);
    }
    return {
      back,
      endOfFile,
      nextToken,
      position
    };
  };
});

// node_modules/postcss/lib/terminal-highlight.js
var require_terminal_highlight = __commonJS((exports, module) => {
  var registerInput = function(dependant) {
    Input = dependant;
  };
  var getTokenType = function([type, value], processor) {
    if (type === "word") {
      if (value[0] === ".") {
        return "class";
      }
      if (value[0] === "#") {
        return "hash";
      }
    }
    if (!processor.endOfFile()) {
      let next = processor.nextToken();
      processor.back(next);
      if (next[0] === "brackets" || next[0] === "(")
        return "call";
    }
    return type;
  };
  var terminalHighlight = function(css) {
    let processor = tokenizer(new Input(css), { ignoreErrors: true });
    let result = "";
    while (!processor.endOfFile()) {
      let token = processor.nextToken();
      let color = HIGHLIGHT_THEME[getTokenType(token, processor)];
      if (color) {
        result += token[1].split(/\r?\n/).map((i) => color(i)).join("\n");
      } else {
        result += token[1];
      }
    }
    return result;
  };
  var pico = require_picocolors();
  var tokenizer = require_tokenize();
  var Input;
  var HIGHLIGHT_THEME = {
    ";": pico.yellow,
    ":": pico.yellow,
    "(": pico.cyan,
    ")": pico.cyan,
    "[": pico.yellow,
    "]": pico.yellow,
    "{": pico.yellow,
    "}": pico.yellow,
    "at-word": pico.cyan,
    brackets: pico.cyan,
    call: pico.cyan,
    class: pico.yellow,
    comment: pico.gray,
    hash: pico.magenta,
    string: pico.green
  };
  terminalHighlight.registerInput = registerInput;
  module.exports = terminalHighlight;
});

// node_modules/postcss/lib/css-syntax-error.js
var require_css_syntax_error = __commonJS((exports, module) => {
  var pico = require_picocolors();
  var terminalHighlight = require_terminal_highlight();

  class CssSyntaxError extends Error {
    constructor(message, line, column, source, file, plugin) {
      super(message);
      this.name = "CssSyntaxError";
      this.reason = message;
      if (file) {
        this.file = file;
      }
      if (source) {
        this.source = source;
      }
      if (plugin) {
        this.plugin = plugin;
      }
      if (typeof line !== "undefined" && typeof column !== "undefined") {
        if (typeof line === "number") {
          this.line = line;
          this.column = column;
        } else {
          this.line = line.line;
          this.column = line.column;
          this.endLine = column.line;
          this.endColumn = column.column;
        }
      }
      this.setMessage();
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, CssSyntaxError);
      }
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "";
      this.message += this.file ? this.file : "<css input>";
      if (typeof this.line !== "undefined") {
        this.message += ":" + this.line + ":" + this.column;
      }
      this.message += ": " + this.reason;
    }
    showSourceCode(color) {
      if (!this.source)
        return "";
      let css = this.source;
      if (color == null)
        color = pico.isColorSupported;
      if (terminalHighlight) {
        if (color)
          css = terminalHighlight(css);
      }
      let lines = css.split(/\r?\n/);
      let start = Math.max(this.line - 3, 0);
      let end = Math.min(this.line + 2, lines.length);
      let maxWidth = String(end).length;
      let mark, aside;
      if (color) {
        let { bold, gray, red } = pico.createColors(true);
        mark = (text) => bold(red(text));
        aside = (text) => gray(text);
      } else {
        mark = aside = (str) => str;
      }
      return lines.slice(start, end).map((line, index) => {
        let number = start + 1 + index;
        let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
        if (number === this.line) {
          let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
        }
        return " " + aside(gutter) + line;
      }).join("\n");
    }
    toString() {
      let code = this.showSourceCode();
      if (code) {
        code = "\n\n" + code + "\n";
      }
      return this.name + ": " + this.message + code;
    }
  }
  module.exports = CssSyntaxError;
  CssSyntaxError.default = CssSyntaxError;
});

// node_modules/postcss/lib/symbols.js
var require_symbols = __commonJS((exports, module) => {
  exports.isClean = Symbol("isClean");
  exports.my = Symbol("my");
});

// node_modules/postcss/lib/stringifier.js
var require_stringifier = __commonJS((exports, module) => {
  var capitalize = function(str) {
    return str[0].toUpperCase() + str.slice(1);
  };
  var DEFAULT_RAW = {
    after: "\n",
    beforeClose: "\n",
    beforeComment: "\n",
    beforeDecl: "\n",
    beforeOpen: " ",
    beforeRule: "\n",
    colon: ": ",
    commentLeft: " ",
    commentRight: " ",
    emptyBody: "",
    indent: "    ",
    semicolon: false
  };

  class Stringifier {
    constructor(builder) {
      this.builder = builder;
    }
    atrule(node, semicolon) {
      let name = "@" + node.name;
      let params = node.params ? this.rawValue(node, "params") : "";
      if (typeof node.raws.afterName !== "undefined") {
        name += node.raws.afterName;
      } else if (params) {
        name += " ";
      }
      if (node.nodes) {
        this.block(node, name + params);
      } else {
        let end = (node.raws.between || "") + (semicolon ? ";" : "");
        this.builder(name + params + end, node);
      }
    }
    beforeAfter(node, detect) {
      let value;
      if (node.type === "decl") {
        value = this.raw(node, null, "beforeDecl");
      } else if (node.type === "comment") {
        value = this.raw(node, null, "beforeComment");
      } else if (detect === "before") {
        value = this.raw(node, null, "beforeRule");
      } else {
        value = this.raw(node, null, "beforeClose");
      }
      let buf = node.parent;
      let depth = 0;
      while (buf && buf.type !== "root") {
        depth += 1;
        buf = buf.parent;
      }
      if (value.includes("\n")) {
        let indent = this.raw(node, null, "indent");
        if (indent.length) {
          for (let step = 0;step < depth; step++)
            value += indent;
        }
      }
      return value;
    }
    block(node, start) {
      let between = this.raw(node, "between", "beforeOpen");
      this.builder(start + between + "{", node, "start");
      let after;
      if (node.nodes && node.nodes.length) {
        this.body(node);
        after = this.raw(node, "after");
      } else {
        after = this.raw(node, "after", "emptyBody");
      }
      if (after)
        this.builder(after);
      this.builder("}", node, "end");
    }
    body(node) {
      let last = node.nodes.length - 1;
      while (last > 0) {
        if (node.nodes[last].type !== "comment")
          break;
        last -= 1;
      }
      let semicolon = this.raw(node, "semicolon");
      for (let i = 0;i < node.nodes.length; i++) {
        let child = node.nodes[i];
        let before = this.raw(child, "before");
        if (before)
          this.builder(before);
        this.stringify(child, last !== i || semicolon);
      }
    }
    comment(node) {
      let left = this.raw(node, "left", "commentLeft");
      let right = this.raw(node, "right", "commentRight");
      this.builder("/*" + left + node.text + right + "*/", node);
    }
    decl(node, semicolon) {
      let between = this.raw(node, "between", "colon");
      let string = node.prop + between + this.rawValue(node, "value");
      if (node.important) {
        string += node.raws.important || " !important";
      }
      if (semicolon)
        string += ";";
      this.builder(string, node);
    }
    document(node) {
      this.body(node);
    }
    raw(node, own, detect) {
      let value;
      if (!detect)
        detect = own;
      if (own) {
        value = node.raws[own];
        if (typeof value !== "undefined")
          return value;
      }
      let parent = node.parent;
      if (detect === "before") {
        if (!parent || parent.type === "root" && parent.first === node) {
          return "";
        }
        if (parent && parent.type === "document") {
          return "";
        }
      }
      if (!parent)
        return DEFAULT_RAW[detect];
      let root = node.root();
      if (!root.rawCache)
        root.rawCache = {};
      if (typeof root.rawCache[detect] !== "undefined") {
        return root.rawCache[detect];
      }
      if (detect === "before" || detect === "after") {
        return this.beforeAfter(node, detect);
      } else {
        let method = "raw" + capitalize(detect);
        if (this[method]) {
          value = this[method](root, node);
        } else {
          root.walk((i) => {
            value = i.raws[own];
            if (typeof value !== "undefined")
              return false;
          });
        }
      }
      if (typeof value === "undefined")
        value = DEFAULT_RAW[detect];
      root.rawCache[detect] = value;
      return value;
    }
    rawBeforeClose(root) {
      let value;
      root.walk((i) => {
        if (i.nodes && i.nodes.length > 0) {
          if (typeof i.raws.after !== "undefined") {
            value = i.raws.after;
            if (value.includes("\n")) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        }
      });
      if (value)
        value = value.replace(/\S/g, "");
      return value;
    }
    rawBeforeComment(root, node) {
      let value;
      root.walkComments((i) => {
        if (typeof i.raws.before !== "undefined") {
          value = i.raws.before;
          if (value.includes("\n")) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      });
      if (typeof value === "undefined") {
        value = this.raw(node, null, "beforeDecl");
      } else if (value) {
        value = value.replace(/\S/g, "");
      }
      return value;
    }
    rawBeforeDecl(root, node) {
      let value;
      root.walkDecls((i) => {
        if (typeof i.raws.before !== "undefined") {
          value = i.raws.before;
          if (value.includes("\n")) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      });
      if (typeof value === "undefined") {
        value = this.raw(node, null, "beforeRule");
      } else if (value) {
        value = value.replace(/\S/g, "");
      }
      return value;
    }
    rawBeforeOpen(root) {
      let value;
      root.walk((i) => {
        if (i.type !== "decl") {
          value = i.raws.between;
          if (typeof value !== "undefined")
            return false;
        }
      });
      return value;
    }
    rawBeforeRule(root) {
      let value;
      root.walk((i) => {
        if (i.nodes && (i.parent !== root || root.first !== i)) {
          if (typeof i.raws.before !== "undefined") {
            value = i.raws.before;
            if (value.includes("\n")) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        }
      });
      if (value)
        value = value.replace(/\S/g, "");
      return value;
    }
    rawColon(root) {
      let value;
      root.walkDecls((i) => {
        if (typeof i.raws.between !== "undefined") {
          value = i.raws.between.replace(/[^\s:]/g, "");
          return false;
        }
      });
      return value;
    }
    rawEmptyBody(root) {
      let value;
      root.walk((i) => {
        if (i.nodes && i.nodes.length === 0) {
          value = i.raws.after;
          if (typeof value !== "undefined")
            return false;
        }
      });
      return value;
    }
    rawIndent(root) {
      if (root.raws.indent)
        return root.raws.indent;
      let value;
      root.walk((i) => {
        let p = i.parent;
        if (p && p !== root && p.parent && p.parent === root) {
          if (typeof i.raws.before !== "undefined") {
            let parts = i.raws.before.split("\n");
            value = parts[parts.length - 1];
            value = value.replace(/\S/g, "");
            return false;
          }
        }
      });
      return value;
    }
    rawSemicolon(root) {
      let value;
      root.walk((i) => {
        if (i.nodes && i.nodes.length && i.last.type === "decl") {
          value = i.raws.semicolon;
          if (typeof value !== "undefined")
            return false;
        }
      });
      return value;
    }
    rawValue(node, prop) {
      let value = node[prop];
      let raw = node.raws[prop];
      if (raw && raw.value === value) {
        return raw.raw;
      }
      return value;
    }
    root(node) {
      this.body(node);
      if (node.raws.after)
        this.builder(node.raws.after);
    }
    rule(node) {
      this.block(node, this.rawValue(node, "selector"));
      if (node.raws.ownSemicolon) {
        this.builder(node.raws.ownSemicolon, node, "end");
      }
    }
    stringify(node, semicolon) {
      if (!this[node.type]) {
        throw new Error("Unknown AST node type " + node.type + ". Maybe you need to change PostCSS stringifier.");
      }
      this[node.type](node, semicolon);
    }
  }
  module.exports = Stringifier;
  Stringifier.default = Stringifier;
});

// node_modules/postcss/lib/stringify.js
var require_stringify2 = __commonJS((exports, module) => {
  var stringify = function(node, builder) {
    let str = new Stringifier(builder);
    str.stringify(node);
  };
  var Stringifier = require_stringifier();
  module.exports = stringify;
  stringify.default = stringify;
});

// node_modules/postcss/lib/node.js
var require_node2 = __commonJS((exports, module) => {
  var cloneNode = function(obj, parent) {
    let cloned = new obj.constructor;
    for (let i in obj) {
      if (!Object.prototype.hasOwnProperty.call(obj, i)) {
        continue;
      }
      if (i === "proxyCache")
        continue;
      let value = obj[i];
      let type = typeof value;
      if (i === "parent" && type === "object") {
        if (parent)
          cloned[i] = parent;
      } else if (i === "source") {
        cloned[i] = value;
      } else if (Array.isArray(value)) {
        cloned[i] = value.map((j) => cloneNode(j, cloned));
      } else {
        if (type === "object" && value !== null)
          value = cloneNode(value);
        cloned[i] = value;
      }
    }
    return cloned;
  };
  var { isClean, my } = require_symbols();
  var CssSyntaxError = require_css_syntax_error();
  var Stringifier = require_stringifier();
  var stringify = require_stringify2();

  class Node {
    constructor(defaults = {}) {
      this.raws = {};
      this[isClean] = false;
      this[my] = true;
      for (let name in defaults) {
        if (name === "nodes") {
          this.nodes = [];
          for (let node of defaults[name]) {
            if (typeof node.clone === "function") {
              this.append(node.clone());
            } else {
              this.append(node);
            }
          }
        } else {
          this[name] = defaults[name];
        }
      }
    }
    addToError(error) {
      error.postcssNode = this;
      if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
        let s = this.source;
        error.stack = error.stack.replace(/\n\s{4}at /, `\$&${s.input.from}:${s.start.line}:${s.start.column}\$&`);
      }
      return error;
    }
    after(add) {
      this.parent.insertAfter(this, add);
      return this;
    }
    assign(overrides = {}) {
      for (let name in overrides) {
        this[name] = overrides[name];
      }
      return this;
    }
    before(add) {
      this.parent.insertBefore(this, add);
      return this;
    }
    cleanRaws(keepBetween) {
      delete this.raws.before;
      delete this.raws.after;
      if (!keepBetween)
        delete this.raws.between;
    }
    clone(overrides = {}) {
      let cloned = cloneNode(this);
      for (let name in overrides) {
        cloned[name] = overrides[name];
      }
      return cloned;
    }
    cloneAfter(overrides = {}) {
      let cloned = this.clone(overrides);
      this.parent.insertAfter(this, cloned);
      return cloned;
    }
    cloneBefore(overrides = {}) {
      let cloned = this.clone(overrides);
      this.parent.insertBefore(this, cloned);
      return cloned;
    }
    error(message, opts = {}) {
      if (this.source) {
        let { end, start } = this.rangeBy(opts);
        return this.source.input.error(message, { column: start.column, line: start.line }, { column: end.column, line: end.line }, opts);
      }
      return new CssSyntaxError(message);
    }
    getProxyProcessor() {
      return {
        get(node, prop) {
          if (prop === "proxyOf") {
            return node;
          } else if (prop === "root") {
            return () => node.root().toProxy();
          } else {
            return node[prop];
          }
        },
        set(node, prop, value) {
          if (node[prop] === value)
            return true;
          node[prop] = value;
          if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || prop === "text") {
            node.markDirty();
          }
          return true;
        }
      };
    }
    markDirty() {
      if (this[isClean]) {
        this[isClean] = false;
        let next = this;
        while (next = next.parent) {
          next[isClean] = false;
        }
      }
    }
    next() {
      if (!this.parent)
        return;
      let index = this.parent.index(this);
      return this.parent.nodes[index + 1];
    }
    positionBy(opts, stringRepresentation) {
      let pos = this.source.start;
      if (opts.index) {
        pos = this.positionInside(opts.index, stringRepresentation);
      } else if (opts.word) {
        stringRepresentation = this.toString();
        let index = stringRepresentation.indexOf(opts.word);
        if (index !== -1)
          pos = this.positionInside(index, stringRepresentation);
      }
      return pos;
    }
    positionInside(index, stringRepresentation) {
      let string = stringRepresentation || this.toString();
      let column = this.source.start.column;
      let line = this.source.start.line;
      for (let i = 0;i < index; i++) {
        if (string[i] === "\n") {
          column = 1;
          line += 1;
        } else {
          column += 1;
        }
      }
      return { column, line };
    }
    prev() {
      if (!this.parent)
        return;
      let index = this.parent.index(this);
      return this.parent.nodes[index - 1];
    }
    get proxyOf() {
      return this;
    }
    rangeBy(opts) {
      let start = {
        column: this.source.start.column,
        line: this.source.start.line
      };
      let end = this.source.end ? {
        column: this.source.end.column + 1,
        line: this.source.end.line
      } : {
        column: start.column + 1,
        line: start.line
      };
      if (opts.word) {
        let stringRepresentation = this.toString();
        let index = stringRepresentation.indexOf(opts.word);
        if (index !== -1) {
          start = this.positionInside(index, stringRepresentation);
          end = this.positionInside(index + opts.word.length, stringRepresentation);
        }
      } else {
        if (opts.start) {
          start = {
            column: opts.start.column,
            line: opts.start.line
          };
        } else if (opts.index) {
          start = this.positionInside(opts.index);
        }
        if (opts.end) {
          end = {
            column: opts.end.column,
            line: opts.end.line
          };
        } else if (opts.endIndex) {
          end = this.positionInside(opts.endIndex);
        } else if (opts.index) {
          end = this.positionInside(opts.index + 1);
        }
      }
      if (end.line < start.line || end.line === start.line && end.column <= start.column) {
        end = { column: start.column + 1, line: start.line };
      }
      return { end, start };
    }
    raw(prop, defaultType) {
      let str = new Stringifier;
      return str.raw(this, prop, defaultType);
    }
    remove() {
      if (this.parent) {
        this.parent.removeChild(this);
      }
      this.parent = undefined;
      return this;
    }
    replaceWith(...nodes) {
      if (this.parent) {
        let bookmark = this;
        let foundSelf = false;
        for (let node of nodes) {
          if (node === this) {
            foundSelf = true;
          } else if (foundSelf) {
            this.parent.insertAfter(bookmark, node);
            bookmark = node;
          } else {
            this.parent.insertBefore(bookmark, node);
          }
        }
        if (!foundSelf) {
          this.remove();
        }
      }
      return this;
    }
    root() {
      let result = this;
      while (result.parent && result.parent.type !== "document") {
        result = result.parent;
      }
      return result;
    }
    toJSON(_, inputs) {
      let fixed = {};
      let emitInputs = inputs == null;
      inputs = inputs || new Map;
      let inputsNextIndex = 0;
      for (let name in this) {
        if (!Object.prototype.hasOwnProperty.call(this, name)) {
          continue;
        }
        if (name === "parent" || name === "proxyCache")
          continue;
        let value = this[name];
        if (Array.isArray(value)) {
          fixed[name] = value.map((i) => {
            if (typeof i === "object" && i.toJSON) {
              return i.toJSON(null, inputs);
            } else {
              return i;
            }
          });
        } else if (typeof value === "object" && value.toJSON) {
          fixed[name] = value.toJSON(null, inputs);
        } else if (name === "source") {
          let inputId = inputs.get(value.input);
          if (inputId == null) {
            inputId = inputsNextIndex;
            inputs.set(value.input, inputsNextIndex);
            inputsNextIndex++;
          }
          fixed[name] = {
            end: value.end,
            inputId,
            start: value.start
          };
        } else {
          fixed[name] = value;
        }
      }
      if (emitInputs) {
        fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
      }
      return fixed;
    }
    toProxy() {
      if (!this.proxyCache) {
        this.proxyCache = new Proxy(this, this.getProxyProcessor());
      }
      return this.proxyCache;
    }
    toString(stringifier = stringify) {
      if (stringifier.stringify)
        stringifier = stringifier.stringify;
      let result = "";
      stringifier(this, (i) => {
        result += i;
      });
      return result;
    }
    warn(result, text, opts) {
      let data = { node: this };
      for (let i in opts)
        data[i] = opts[i];
      return result.warn(text, data);
    }
  }
  module.exports = Node;
  Node.default = Node;
});

// node_modules/postcss/lib/declaration.js
var require_declaration = __commonJS((exports, module) => {
  var Node = require_node2();

  class Declaration extends Node {
    constructor(defaults) {
      if (defaults && typeof defaults.value !== "undefined" && typeof defaults.value !== "string") {
        defaults = { ...defaults, value: String(defaults.value) };
      }
      super(defaults);
      this.type = "decl";
    }
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
  }
  module.exports = Declaration;
  Declaration.default = Declaration;
});

// node_modules/source-map-js/lib/base64.js
var require_base64 = __commonJS((exports) => {
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  exports.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };
  exports.decode = function(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
});

// node_modules/source-map-js/lib/base64-vlq.js
var require_base64_vlq = __commonJS((exports) => {
  var toVLQSigned = function(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  };
  var fromVLQSigned = function(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  };
  var base64 = require_base64();
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
});

// node_modules/source-map-js/lib/util.js
var require_util = __commonJS((exports) => {
  var getArg = function(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  };
  var urlParse = function(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  };
  var urlGenerate = function(aParsedUrl) {
    var url = "";
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ":";
    }
    url += "//";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@";
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  };
  var lruMemoize = function(f) {
    var cache = [];
    return function(input) {
      for (var i = 0;i < cache.length; i++) {
        if (cache[i].input === input) {
          var temp = cache[0];
          cache[0] = cache[i];
          cache[i] = temp;
          return cache[0].result;
        }
      }
      var result = f(input);
      cache.unshift({
        input,
        result
      });
      if (cache.length > MAX_CACHED_INPUTS) {
        cache.pop();
      }
      return result;
    };
  };
  var join = function(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || "/";
    }
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  };
  var relative = function(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, "");
    var level = 0;
    while (aPath.indexOf(aRoot + "/") !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }
      ++level;
    }
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  };
  var identity = function(s) {
    return s;
  };
  var toSetString = function(aStr) {
    if (isProtoString(aStr)) {
      return "$" + aStr;
    }
    return aStr;
  };
  var fromSetString = function(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }
    return aStr;
  };
  var isProtoString = function(s) {
    if (!s) {
      return false;
    }
    var length = s.length;
    if (length < 9) {
      return false;
    }
    if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
      return false;
    }
    for (var i = length - 10;i >= 0; i--) {
      if (s.charCodeAt(i) !== 36) {
        return false;
      }
    }
    return true;
  };
  var compareByOriginalPositions = function(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var compareByOriginalPositionsNoSource = function(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var compareByGeneratedPositionsDeflated = function(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var compareByGeneratedPositionsDeflatedNoLine = function(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var strcmp = function(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }
    if (aStr1 === null) {
      return 1;
    }
    if (aStr2 === null) {
      return -1;
    }
    if (aStr1 > aStr2) {
      return 1;
    }
    return -1;
  };
  var compareByGeneratedPositionsInflated = function(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  };
  var parseSourceMapInput = function(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
  };
  var computeSourceURL = function(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || "";
    if (sourceRoot) {
      if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
        sourceRoot += "/";
      }
      sourceURL = sourceRoot + sourceURL;
    }
    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);
      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
        var index = parsed.path.lastIndexOf("/");
        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }
      sourceURL = join(urlGenerate(parsed), sourceURL);
    }
    return normalize(sourceURL);
  };
  exports.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;
  exports.urlParse = urlParse;
  exports.urlGenerate = urlGenerate;
  var MAX_CACHED_INPUTS = 32;
  var normalize = lruMemoize(function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = exports.isAbsolute(path);
    var parts = [];
    var start = 0;
    var i = 0;
    while (true) {
      start = i;
      i = path.indexOf("/", start);
      if (i === -1) {
        parts.push(path.slice(start));
        break;
      } else {
        parts.push(path.slice(start, i));
        while (i < path.length && path[i] === "/") {
          i++;
        }
      }
    }
    for (var part, up = 0, i = parts.length - 1;i >= 0; i--) {
      part = parts[i];
      if (part === ".") {
        parts.splice(i, 1);
      } else if (part === "..") {
        up++;
      } else if (up > 0) {
        if (part === "") {
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join("/");
    if (path === "") {
      path = isAbsolute ? "/" : ".";
    }
    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  });
  exports.normalize = normalize;
  exports.join = join;
  exports.isAbsolute = function(aPath) {
    return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
  };
  exports.relative = relative;
  var supportsNullProto = function() {
    var obj = Object.create(null);
    return !("__proto__" in obj);
  }();
  exports.toSetString = supportsNullProto ? identity : toSetString;
  exports.fromSetString = supportsNullProto ? identity : fromSetString;
  exports.compareByOriginalPositions = compareByOriginalPositions;
  exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
  exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  exports.parseSourceMapInput = parseSourceMapInput;
  exports.computeSourceURL = computeSourceURL;
});

// node_modules/source-map-js/lib/array-set.js
var require_array_set = __commonJS((exports) => {
  var ArraySet = function() {
    this._array = [];
    this._set = hasNativeMap ? new Map : Object.create(null);
  };
  var util = require_util();
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet;
    for (var i = 0, len = aArray.length;i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  exports.ArraySet = ArraySet;
});

// node_modules/source-map-js/lib/mapping-list.js
var require_mapping_list = __commonJS((exports) => {
  var generatedPositionAfter = function(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  };
  var MappingList = function() {
    this._array = [];
    this._sorted = true;
    this._last = { generatedLine: -1, generatedColumn: 0 };
  };
  var util = require_util();
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  exports.MappingList = MappingList;
});

// node_modules/source-map-js/lib/source-map-generator.js
var require_source_map_generator = __commonJS((exports) => {
  var SourceMapGenerator = function(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, "file", null);
    this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util.getArg(aArgs, "skipValidation", false);
    this._sources = new ArraySet;
    this._names = new ArraySet;
    this._mappings = new MappingList;
    this._sourcesContents = null;
  };
  var base64VLQ = require_base64_vlq();
  var util = require_util();
  var ArraySet = require_array_set().ArraySet;
  var MappingList = require_mapping_list().MappingList;
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot
    });
    aSourceMapConsumer.eachMapping(function(mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }
      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, "generated");
    var original = util.getArg(aArgs, "original", null);
    var source = util.getArg(aArgs, "source", null);
    var name = util.getArg(aArgs, "name", null);
    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }
    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }
    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source,
      name
    });
  };
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    var newSources = new ArraySet;
    var newNames = new ArraySet;
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }
      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function(sourceFile2) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile2 = util.join(aSourceMapPath, sourceFile2);
        }
        if (sourceRoot != null) {
          sourceFile2 = util.relative(sourceRoot, sourceFile2);
        }
        this.setSourceContent(sourceFile2, content);
      }
    }, this);
  };
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
      throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    }
    if (aGenerated && ("line" in aGenerated) && ("column" in aGenerated) && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && ("line" in aGenerated) && ("column" in aGenerated) && aOriginal && ("line" in aOriginal) && ("column" in aOriginal) && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = "";
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length;i < len; i++) {
      mapping = mappings[i];
      next = "";
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ",";
        }
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
  };
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  exports.SourceMapGenerator = SourceMapGenerator;
});

// node_modules/source-map-js/lib/binary-search.js
var require_binary_search = __commonJS((exports) => {
  var recursiveSearch = function(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      return mid;
    } else if (cmp > 0) {
      if (aHigh - mid > 1) {
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    } else {
      if (mid - aLow > 1) {
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  };
  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;
  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }
    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }
    return index;
  };
});

// node_modules/source-map-js/lib/quick-sort.js
var require_quick_sort = __commonJS((exports) => {
  var SortTemplate = function(comparator) {
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator2, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p;j < r; j++) {
          if (comparator2(ary[j], pivot, false) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator2, p, q - 1);
        doQuickSort(ary, comparator2, q + 1, r);
      }
    }
    return doQuickSort;
  };
  var cloneSort = function(comparator) {
    let template = SortTemplate.toString();
    let templateFn = new Function(`return ${template}`)();
    return templateFn(comparator);
  };
  var sortCache = new WeakMap;
  exports.quickSort = function(ary, comparator, start = 0) {
    let doQuickSort = sortCache.get(comparator);
    if (doQuickSort === undefined) {
      doQuickSort = cloneSort(comparator);
      sortCache.set(comparator, doQuickSort);
    }
    doQuickSort(ary, comparator, start, ary.length - 1);
  };
});

// node_modules/source-map-js/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS((exports) => {
  var SourceMapConsumer = function(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  };
  var BasicSourceMapConsumer = function(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, "version");
    var sources = util.getArg(sourceMap, "sources");
    var names = util.getArg(sourceMap, "names", []);
    var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
    var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
    var mappings = util.getArg(sourceMap, "mappings");
    var file = util.getArg(sourceMap, "file", null);
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    if (sourceRoot) {
      sourceRoot = util.normalize(sourceRoot);
    }
    sources = sources.map(String).map(util.normalize).map(function(source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function(s) {
      return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
  };
  var Mapping = function() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  };
  var sortGenerated = function(array, start) {
    let l2 = array.length;
    let n = array.length - start;
    if (n <= 1) {
      return;
    } else if (n == 2) {
      let a = array[start];
      let b = array[start + 1];
      if (compareGenerated(a, b) > 0) {
        array[start] = b;
        array[start + 1] = a;
      }
    } else if (n < 20) {
      for (let i = start;i < l2; i++) {
        for (let j = i;j > start; j--) {
          let a = array[j - 1];
          let b = array[j];
          if (compareGenerated(a, b) <= 0) {
            break;
          }
          array[j - 1] = b;
          array[j] = a;
        }
      }
    } else {
      quickSort(array, compareGenerated, start);
    }
  };
  var IndexedSourceMapConsumer = function(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, "version");
    var sections = util.getArg(sourceMap, "sections");
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    this._sources = new ArraySet;
    this._names = new ArraySet;
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function(s) {
      if (s.url) {
        throw new Error("Support for url field in sections not implemented.");
      }
      var offset = util.getArg(s, "offset");
      var offsetLine = util.getArg(offset, "line");
      var offsetColumn = util.getArg(offset, "column");
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error("Section offsets must be ordered and non-overlapping.");
      }
      lastOffset = offset;
      return {
        generatedOffset: {
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
      };
    });
  };
  var util = require_util();
  var binarySearch = require_binary_search();
  var ArraySet = require_array_set().ArraySet;
  var base64VLQ = require_base64_vlq();
  var quickSort = require_quick_sort().quickSort;
  SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };
  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappings;
    }
  });
  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };
  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    var boundCallback = aCallback.bind(context);
    var names = this._names;
    var sources = this._sources;
    var sourceMapURL = this._sourceMapURL;
    for (var i = 0, n = mappings.length;i < n; i++) {
      var mapping = mappings[i];
      var source = mapping.source === null ? null : sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, sourceMapURL);
      boundCallback({
        source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : names.at(mapping.name)
      });
    }
  };
  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, "line");
    var needle = {
      source: util.getArg(aArgs, "source"),
      originalLine: line,
      originalColumn: util.getArg(aArgs, "column", 0)
    };
    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }
    var mappings = [];
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;
        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }
    return mappings;
  };
  exports.SourceMapConsumer = SourceMapConsumer;
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }
    var i;
    for (i = 0;i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }
    return -1;
  };
  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function(s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });
    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for (var i = 0, length = generatedMappings.length;i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;
      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;
        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }
        destOriginalMappings.push(destMapping);
      }
      destGeneratedMappings.push(destMapping);
    }
    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
  };
  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  var compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;
  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;
    let subarrayStart = 0;
    while (index < length) {
      if (aStr.charAt(index) === ";") {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
        sortGenerated(generatedMappings, subarrayStart);
        subarrayStart = generatedMappings.length;
      } else if (aStr.charAt(index) === ",") {
        index++;
      } else {
        mapping = new Mapping;
        mapping.generatedLine = generatedLine;
        for (end = index;end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);
        segment = [];
        while (index < end) {
          base64VLQ.decode(aStr, index, temp);
          value = temp.value;
          index = temp.rest;
          segment.push(value);
        }
        if (segment.length === 2) {
          throw new Error("Found a source, but no line and column");
        }
        if (segment.length === 3) {
          throw new Error("Found a source and line, but no column");
        }
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;
        if (segment.length > 1) {
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          mapping.originalLine += 1;
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;
          if (segment.length > 4) {
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }
        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === "number") {
          let currentSource = mapping.source;
          while (originalMappings.length <= currentSource) {
            originalMappings.push(null);
          }
          if (originalMappings[currentSource] === null) {
            originalMappings[currentSource] = [];
          }
          originalMappings[currentSource].push(mapping);
        }
      }
    }
    sortGenerated(generatedMappings, subarrayStart);
    this.__generatedMappings = generatedMappings;
    for (var i = 0;i < originalMappings.length; i++) {
      if (originalMappings[i] != null) {
        quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);
      }
    }
    this.__originalMappings = [].concat(...originalMappings);
  };
  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
    }
    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };
  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0;index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];
        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }
      mapping.lastGeneratedColumn = Infinity;
    }
  };
  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._generatedMappings[index];
      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, "source", null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, "name", null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source,
          line: util.getArg(mapping, "originalLine", null),
          column: util.getArg(mapping, "originalColumn", null),
          name
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
      return sc == null;
    });
  };
  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }
    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    var url;
    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }
      if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };
  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, "source");
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    var needle = {
      source,
      originalLine: util.getArg(aArgs, "line"),
      originalColumn: util.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, "generatedLine", null),
          column: util.getArg(mapping, "generatedColumn", null),
          lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
        };
      }
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };
  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
    get: function() {
      var sources = [];
      for (var i = 0;i < this._sections.length; i++) {
        for (var j = 0;j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    }
  });
  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };
    var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
      var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
      if (cmp) {
        return cmp;
      }
      return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];
    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }
    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function(s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };
  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0;i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0;i < this._sections.length; i++) {
      var section = this._sections[i];
      if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }
    return {
      line: null,
      column: null
    };
  };
  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0;i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0;j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];
        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);
        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }
        var adjustedMapping = {
          source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name
        };
        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === "number") {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }
    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };
  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
});

// node_modules/source-map-js/lib/source-node.js
var require_source_node = __commonJS((exports) => {
  var SourceNode = function(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null)
      this.add(aChunks);
  };
  var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
  var util = require_util();
  var REGEX_NEWLINE = /(\r?\n)/;
  var NEWLINE_CODE = 10;
  var isSourceNode = "$$$isSourceNode$$$";
  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node = new SourceNode;
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      var newLine = getNextLine() || "";
      return lineContents + newLine;
      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
      }
    };
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function(mapping) {
      if (lastMapping !== null) {
        if (lastGeneratedLine < mapping.generatedLine) {
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
        } else {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          lastMapping = mapping;
          return;
        }
      }
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || "";
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });
    return node;
    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
  };
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function(chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1;i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length;i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== "") {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0;i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === "string") {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push("".replace(aPattern, aReplacement));
    }
    return this;
  };
  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };
  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length;i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }
    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length;i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function(chunk) {
      str += chunk;
    });
    return str;
  };
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function(chunk, original) {
      generated.code += chunk;
      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length;idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });
    return { code: generated.code, map };
  };
  exports.SourceNode = SourceNode;
});

// node_modules/source-map-js/source-map.js
var require_source_map = __commonJS((exports) => {
  exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
  exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
  exports.SourceNode = require_source_node().SourceNode;
});

// node_modules/nanoid/non-secure/index.cjs
var require_non_secure = __commonJS((exports, module) => {
  var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  var customAlphabet = (alphabet, defaultSize = 21) => {
    return (size = defaultSize) => {
      let id = "";
      let i = size;
      while (i--) {
        id += alphabet[Math.random() * alphabet.length | 0];
      }
      return id;
    };
  };
  var nanoid = (size = 21) => {
    let id = "";
    let i = size;
    while (i--) {
      id += urlAlphabet[Math.random() * 64 | 0];
    }
    return id;
  };
  module.exports = { nanoid, customAlphabet };
});

// node_modules/postcss/lib/previous-map.js
var require_previous_map = __commonJS((exports, module) => {
  var fromBase64 = function(str) {
    if (Buffer) {
      return Buffer.from(str, "base64").toString();
    } else {
      return window.atob(str);
    }
  };
  var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
  var { existsSync, readFileSync } = import.meta.require("node:fs");
  var { dirname, join } = import.meta.require("node:path");

  class PreviousMap {
    constructor(css, opts) {
      if (opts.map === false)
        return;
      this.loadAnnotation(css);
      this.inline = this.startWith(this.annotation, "data:");
      let prev = opts.map ? opts.map.prev : undefined;
      let text = this.loadMap(opts.from, prev);
      if (!this.mapFile && opts.from) {
        this.mapFile = opts.from;
      }
      if (this.mapFile)
        this.root = dirname(this.mapFile);
      if (text)
        this.text = text;
    }
    consumer() {
      if (!this.consumerCache) {
        this.consumerCache = new SourceMapConsumer(this.text);
      }
      return this.consumerCache;
    }
    decodeInline(text) {
      let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
      let baseUri = /^data:application\/json;base64,/;
      let charsetUri = /^data:application\/json;charset=utf-?8,/;
      let uri = /^data:application\/json,/;
      if (charsetUri.test(text) || uri.test(text)) {
        return decodeURIComponent(text.substr(RegExp.lastMatch.length));
      }
      if (baseCharsetUri.test(text) || baseUri.test(text)) {
        return fromBase64(text.substr(RegExp.lastMatch.length));
      }
      let encoding = text.match(/data:application\/json;([^,]+),/)[1];
      throw new Error("Unsupported source map encoding " + encoding);
    }
    getAnnotationURL(sourceMapString) {
      return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
    }
    isMap(map) {
      if (typeof map !== "object")
        return false;
      return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
    }
    loadAnnotation(css) {
      let comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
      if (!comments)
        return;
      let start = css.lastIndexOf(comments.pop());
      let end = css.indexOf("*/", start);
      if (start > -1 && end > -1) {
        this.annotation = this.getAnnotationURL(css.substring(start, end));
      }
    }
    loadFile(path) {
      this.root = dirname(path);
      if (existsSync(path)) {
        this.mapFile = path;
        return readFileSync(path, "utf-8").toString().trim();
      }
    }
    loadMap(file, prev) {
      if (prev === false)
        return false;
      if (prev) {
        if (typeof prev === "string") {
          return prev;
        } else if (typeof prev === "function") {
          let prevPath = prev(file);
          if (prevPath) {
            let map = this.loadFile(prevPath);
            if (!map) {
              throw new Error("Unable to load previous source map: " + prevPath.toString());
            }
            return map;
          }
        } else if (prev instanceof SourceMapConsumer) {
          return SourceMapGenerator.fromSourceMap(prev).toString();
        } else if (prev instanceof SourceMapGenerator) {
          return prev.toString();
        } else if (this.isMap(prev)) {
          return JSON.stringify(prev);
        } else {
          throw new Error("Unsupported previous source map format: " + prev.toString());
        }
      } else if (this.inline) {
        return this.decodeInline(this.annotation);
      } else if (this.annotation) {
        let map = this.annotation;
        if (file)
          map = join(dirname(file), map);
        return this.loadFile(map);
      }
    }
    startWith(string, start) {
      if (!string)
        return false;
      return string.substr(0, start.length) === start;
    }
    withContent() {
      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    }
  }
  module.exports = PreviousMap;
  PreviousMap.default = PreviousMap;
});

// node_modules/postcss/lib/input.js
var require_input = __commonJS((exports, module) => {
  var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
  var { fileURLToPath, pathToFileURL } = import.meta.require("node:url");
  var { isAbsolute, resolve } = import.meta.require("node:path");
  var { nanoid } = require_non_secure();
  var terminalHighlight = require_terminal_highlight();
  var CssSyntaxError = require_css_syntax_error();
  var PreviousMap = require_previous_map();
  var fromOffsetCache = Symbol("fromOffsetCache");
  var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
  var pathAvailable = Boolean(resolve && isAbsolute);

  class Input {
    constructor(css, opts = {}) {
      if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
        throw new Error(`PostCSS received ${css} instead of CSS string`);
      }
      this.css = css.toString();
      if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
        this.hasBOM = true;
        this.css = this.css.slice(1);
      } else {
        this.hasBOM = false;
      }
      if (opts.from) {
        if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
          this.file = opts.from;
        } else {
          this.file = resolve(opts.from);
        }
      }
      if (pathAvailable && sourceMapAvailable) {
        let map = new PreviousMap(this.css, opts);
        if (map.text) {
          this.map = map;
          let file = map.consumer().file;
          if (!this.file && file)
            this.file = this.mapResolve(file);
        }
      }
      if (!this.file) {
        this.id = "<input css " + nanoid(6) + ">";
      }
      if (this.map)
        this.map.file = this.from;
    }
    error(message, line, column, opts = {}) {
      let result, endLine, endColumn;
      if (line && typeof line === "object") {
        let start = line;
        let end = column;
        if (typeof start.offset === "number") {
          let pos = this.fromOffset(start.offset);
          line = pos.line;
          column = pos.col;
        } else {
          line = start.line;
          column = start.column;
        }
        if (typeof end.offset === "number") {
          let pos = this.fromOffset(end.offset);
          endLine = pos.line;
          endColumn = pos.col;
        } else {
          endLine = end.line;
          endColumn = end.column;
        }
      } else if (!column) {
        let pos = this.fromOffset(line);
        line = pos.line;
        column = pos.col;
      }
      let origin = this.origin(line, column, endLine, endColumn);
      if (origin) {
        result = new CssSyntaxError(message, origin.endLine === undefined ? origin.line : { column: origin.column, line: origin.line }, origin.endLine === undefined ? origin.column : { column: origin.endColumn, line: origin.endLine }, origin.source, origin.file, opts.plugin);
      } else {
        result = new CssSyntaxError(message, endLine === undefined ? line : { column, line }, endLine === undefined ? column : { column: endColumn, line: endLine }, this.css, this.file, opts.plugin);
      }
      result.input = { column, endColumn, endLine, line, source: this.css };
      if (this.file) {
        if (pathToFileURL) {
          result.input.url = pathToFileURL(this.file).toString();
        }
        result.input.file = this.file;
      }
      return result;
    }
    get from() {
      return this.file || this.id;
    }
    fromOffset(offset) {
      let lastLine, lineToIndex;
      if (!this[fromOffsetCache]) {
        let lines = this.css.split("\n");
        lineToIndex = new Array(lines.length);
        let prevIndex = 0;
        for (let i = 0, l2 = lines.length;i < l2; i++) {
          lineToIndex[i] = prevIndex;
          prevIndex += lines[i].length + 1;
        }
        this[fromOffsetCache] = lineToIndex;
      } else {
        lineToIndex = this[fromOffsetCache];
      }
      lastLine = lineToIndex[lineToIndex.length - 1];
      let min = 0;
      if (offset >= lastLine) {
        min = lineToIndex.length - 1;
      } else {
        let max = lineToIndex.length - 2;
        let mid;
        while (min < max) {
          mid = min + (max - min >> 1);
          if (offset < lineToIndex[mid]) {
            max = mid - 1;
          } else if (offset >= lineToIndex[mid + 1]) {
            min = mid + 1;
          } else {
            min = mid;
            break;
          }
        }
      }
      return {
        col: offset - lineToIndex[min] + 1,
        line: min + 1
      };
    }
    mapResolve(file) {
      if (/^\w+:\/\//.test(file)) {
        return file;
      }
      return resolve(this.map.consumer().sourceRoot || this.map.root || ".", file);
    }
    origin(line, column, endLine, endColumn) {
      if (!this.map)
        return false;
      let consumer = this.map.consumer();
      let from = consumer.originalPositionFor({ column, line });
      if (!from.source)
        return false;
      let to;
      if (typeof endLine === "number") {
        to = consumer.originalPositionFor({ column: endColumn, line: endLine });
      }
      let fromUrl;
      if (isAbsolute(from.source)) {
        fromUrl = pathToFileURL(from.source);
      } else {
        fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile));
      }
      let result = {
        column: from.column,
        endColumn: to && to.column,
        endLine: to && to.line,
        line: from.line,
        url: fromUrl.toString()
      };
      if (fromUrl.protocol === "file:") {
        if (fileURLToPath) {
          result.file = fileURLToPath(fromUrl);
        } else {
          throw new Error(`file: protocol is not available in this PostCSS build`);
        }
      }
      let source = consumer.sourceContentFor(from.source);
      if (source)
        result.source = source;
      return result;
    }
    toJSON() {
      let json = {};
      for (let name of ["hasBOM", "css", "file", "id"]) {
        if (this[name] != null) {
          json[name] = this[name];
        }
      }
      if (this.map) {
        json.map = { ...this.map };
        if (json.map.consumerCache) {
          json.map.consumerCache = undefined;
        }
      }
      return json;
    }
  }
  module.exports = Input;
  Input.default = Input;
  if (terminalHighlight && terminalHighlight.registerInput) {
    terminalHighlight.registerInput(Input);
  }
});

// node_modules/postcss/lib/map-generator.js
var require_map_generator = __commonJS((exports, module) => {
  var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
  var { dirname, relative, resolve, sep } = import.meta.require("node:path");
  var { pathToFileURL } = import.meta.require("node:url");
  var Input = require_input();
  var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
  var pathAvailable = Boolean(dirname && resolve && relative && sep);

  class MapGenerator {
    constructor(stringify, root, opts, cssString) {
      this.stringify = stringify;
      this.mapOpts = opts.map || {};
      this.root = root;
      this.opts = opts;
      this.css = cssString;
      this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
    }
    addAnnotation() {
      let content;
      if (this.isInline()) {
        content = "data:application/json;base64," + this.toBase64(this.map.toString());
      } else if (typeof this.mapOpts.annotation === "string") {
        content = this.mapOpts.annotation;
      } else if (typeof this.mapOpts.annotation === "function") {
        content = this.mapOpts.annotation(this.opts.to, this.root);
      } else {
        content = this.outputFile() + ".map";
      }
      let eol = "\n";
      if (this.css.includes("\r\n"))
        eol = "\r\n";
      this.css += eol + "/*# sourceMappingURL=" + content + " */";
    }
    applyPrevMaps() {
      for (let prev of this.previous()) {
        let from = this.toUrl(this.path(prev.file));
        let root = prev.root || dirname(prev.file);
        let map;
        if (this.mapOpts.sourcesContent === false) {
          map = new SourceMapConsumer(prev.text);
          if (map.sourcesContent) {
            map.sourcesContent = map.sourcesContent.map(() => null);
          }
        } else {
          map = prev.consumer();
        }
        this.map.applySourceMap(map, from, this.toUrl(this.path(root)));
      }
    }
    clearAnnotation() {
      if (this.mapOpts.annotation === false)
        return;
      if (this.root) {
        let node;
        for (let i = this.root.nodes.length - 1;i >= 0; i--) {
          node = this.root.nodes[i];
          if (node.type !== "comment")
            continue;
          if (node.text.indexOf("# sourceMappingURL=") === 0) {
            this.root.removeChild(i);
          }
        }
      } else if (this.css) {
        this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, "");
      }
    }
    generate() {
      this.clearAnnotation();
      if (pathAvailable && sourceMapAvailable && this.isMap()) {
        return this.generateMap();
      } else {
        let result = "";
        this.stringify(this.root, (i) => {
          result += i;
        });
        return [result];
      }
    }
    generateMap() {
      if (this.root) {
        this.generateString();
      } else if (this.previous().length === 1) {
        let prev = this.previous()[0].consumer();
        prev.file = this.outputFile();
        this.map = SourceMapGenerator.fromSourceMap(prev);
      } else {
        this.map = new SourceMapGenerator({ file: this.outputFile() });
        this.map.addMapping({
          generated: { column: 0, line: 1 },
          original: { column: 0, line: 1 },
          source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
        });
      }
      if (this.isSourcesContent())
        this.setSourcesContent();
      if (this.root && this.previous().length > 0)
        this.applyPrevMaps();
      if (this.isAnnotation())
        this.addAnnotation();
      if (this.isInline()) {
        return [this.css];
      } else {
        return [this.css, this.map];
      }
    }
    generateString() {
      this.css = "";
      this.map = new SourceMapGenerator({ file: this.outputFile() });
      let line = 1;
      let column = 1;
      let noSource = "<no source>";
      let mapping = {
        generated: { column: 0, line: 0 },
        original: { column: 0, line: 0 },
        source: ""
      };
      let lines, last;
      this.stringify(this.root, (str, node, type) => {
        this.css += str;
        if (node && type !== "end") {
          mapping.generated.line = line;
          mapping.generated.column = column - 1;
          if (node.source && node.source.start) {
            mapping.source = this.sourcePath(node);
            mapping.original.line = node.source.start.line;
            mapping.original.column = node.source.start.column - 1;
            this.map.addMapping(mapping);
          } else {
            mapping.source = noSource;
            mapping.original.line = 1;
            mapping.original.column = 0;
            this.map.addMapping(mapping);
          }
        }
        lines = str.match(/\n/g);
        if (lines) {
          line += lines.length;
          last = str.lastIndexOf("\n");
          column = str.length - last;
        } else {
          column += str.length;
        }
        if (node && type !== "start") {
          let p = node.parent || { raws: {} };
          let childless = node.type === "decl" || node.type === "atrule" && !node.nodes;
          if (!childless || node !== p.last || p.raws.semicolon) {
            if (node.source && node.source.end) {
              mapping.source = this.sourcePath(node);
              mapping.original.line = node.source.end.line;
              mapping.original.column = node.source.end.column - 1;
              mapping.generated.line = line;
              mapping.generated.column = column - 2;
              this.map.addMapping(mapping);
            } else {
              mapping.source = noSource;
              mapping.original.line = 1;
              mapping.original.column = 0;
              mapping.generated.line = line;
              mapping.generated.column = column - 1;
              this.map.addMapping(mapping);
            }
          }
        }
      });
    }
    isAnnotation() {
      if (this.isInline()) {
        return true;
      }
      if (typeof this.mapOpts.annotation !== "undefined") {
        return this.mapOpts.annotation;
      }
      if (this.previous().length) {
        return this.previous().some((i) => i.annotation);
      }
      return true;
    }
    isInline() {
      if (typeof this.mapOpts.inline !== "undefined") {
        return this.mapOpts.inline;
      }
      let annotation = this.mapOpts.annotation;
      if (typeof annotation !== "undefined" && annotation !== true) {
        return false;
      }
      if (this.previous().length) {
        return this.previous().some((i) => i.inline);
      }
      return true;
    }
    isMap() {
      if (typeof this.opts.map !== "undefined") {
        return !!this.opts.map;
      }
      return this.previous().length > 0;
    }
    isSourcesContent() {
      if (typeof this.mapOpts.sourcesContent !== "undefined") {
        return this.mapOpts.sourcesContent;
      }
      if (this.previous().length) {
        return this.previous().some((i) => i.withContent());
      }
      return true;
    }
    outputFile() {
      if (this.opts.to) {
        return this.path(this.opts.to);
      } else if (this.opts.from) {
        return this.path(this.opts.from);
      } else {
        return "to.css";
      }
    }
    path(file) {
      if (file.indexOf("<") === 0)
        return file;
      if (/^\w+:\/\//.test(file))
        return file;
      if (this.mapOpts.absolute)
        return file;
      let from = this.opts.to ? dirname(this.opts.to) : ".";
      if (typeof this.mapOpts.annotation === "string") {
        from = dirname(resolve(from, this.mapOpts.annotation));
      }
      file = relative(from, file);
      return file;
    }
    previous() {
      if (!this.previousMaps) {
        this.previousMaps = [];
        if (this.root) {
          this.root.walk((node) => {
            if (node.source && node.source.input.map) {
              let map = node.source.input.map;
              if (!this.previousMaps.includes(map)) {
                this.previousMaps.push(map);
              }
            }
          });
        } else {
          let input = new Input(this.css, this.opts);
          if (input.map)
            this.previousMaps.push(input.map);
        }
      }
      return this.previousMaps;
    }
    setSourcesContent() {
      let already = {};
      if (this.root) {
        this.root.walk((node) => {
          if (node.source) {
            let from = node.source.input.from;
            if (from && !already[from]) {
              already[from] = true;
              let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
              this.map.setSourceContent(fromUrl, node.source.input.css);
            }
          }
        });
      } else if (this.css) {
        let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
        this.map.setSourceContent(from, this.css);
      }
    }
    sourcePath(node) {
      if (this.mapOpts.from) {
        return this.toUrl(this.mapOpts.from);
      } else if (this.usesFileUrls) {
        return this.toFileUrl(node.source.input.from);
      } else {
        return this.toUrl(this.path(node.source.input.from));
      }
    }
    toBase64(str) {
      if (Buffer) {
        return Buffer.from(str).toString("base64");
      } else {
        return window.btoa(unescape(encodeURIComponent(str)));
      }
    }
    toFileUrl(path) {
      if (pathToFileURL) {
        return pathToFileURL(path).toString();
      } else {
        throw new Error("`map.absolute` option is not available in this PostCSS build");
      }
    }
    toUrl(path) {
      if (sep === "\\") {
        path = path.replace(/\\/g, "/");
      }
      return encodeURI(path).replace(/[#?]/g, encodeURIComponent);
    }
  }
  module.exports = MapGenerator;
});

// node_modules/postcss/lib/comment.js
var require_comment = __commonJS((exports, module) => {
  var Node = require_node2();

  class Comment extends Node {
    constructor(defaults) {
      super(defaults);
      this.type = "comment";
    }
  }
  module.exports = Comment;
  Comment.default = Comment;
});

// node_modules/postcss/lib/container.js
var require_container = __commonJS((exports, module) => {
  var cleanSource = function(nodes) {
    return nodes.map((i) => {
      if (i.nodes)
        i.nodes = cleanSource(i.nodes);
      delete i.source;
      return i;
    });
  };
  var markDirtyUp = function(node) {
    node[isClean] = false;
    if (node.proxyOf.nodes) {
      for (let i of node.proxyOf.nodes) {
        markDirtyUp(i);
      }
    }
  };
  var { isClean, my } = require_symbols();
  var Declaration = require_declaration();
  var Comment = require_comment();
  var Node = require_node2();
  var parse;
  var Rule;
  var AtRule;
  var Root;

  class Container extends Node {
    append(...children) {
      for (let child of children) {
        let nodes = this.normalize(child, this.last);
        for (let node of nodes)
          this.proxyOf.nodes.push(node);
      }
      this.markDirty();
      return this;
    }
    cleanRaws(keepBetween) {
      super.cleanRaws(keepBetween);
      if (this.nodes) {
        for (let node of this.nodes)
          node.cleanRaws(keepBetween);
      }
    }
    each(callback) {
      if (!this.proxyOf.nodes)
        return;
      let iterator = this.getIterator();
      let index, result;
      while (this.indexes[iterator] < this.proxyOf.nodes.length) {
        index = this.indexes[iterator];
        result = callback(this.proxyOf.nodes[index], index);
        if (result === false)
          break;
        this.indexes[iterator] += 1;
      }
      delete this.indexes[iterator];
      return result;
    }
    every(condition) {
      return this.nodes.every(condition);
    }
    get first() {
      if (!this.proxyOf.nodes)
        return;
      return this.proxyOf.nodes[0];
    }
    getIterator() {
      if (!this.lastEach)
        this.lastEach = 0;
      if (!this.indexes)
        this.indexes = {};
      this.lastEach += 1;
      let iterator = this.lastEach;
      this.indexes[iterator] = 0;
      return iterator;
    }
    getProxyProcessor() {
      return {
        get(node, prop) {
          if (prop === "proxyOf") {
            return node;
          } else if (!node[prop]) {
            return node[prop];
          } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
            return (...args) => {
              return node[prop](...args.map((i) => {
                if (typeof i === "function") {
                  return (child, index) => i(child.toProxy(), index);
                } else {
                  return i;
                }
              }));
            };
          } else if (prop === "every" || prop === "some") {
            return (cb) => {
              return node[prop]((child, ...other) => cb(child.toProxy(), ...other));
            };
          } else if (prop === "root") {
            return () => node.root().toProxy();
          } else if (prop === "nodes") {
            return node.nodes.map((i) => i.toProxy());
          } else if (prop === "first" || prop === "last") {
            return node[prop].toProxy();
          } else {
            return node[prop];
          }
        },
        set(node, prop, value) {
          if (node[prop] === value)
            return true;
          node[prop] = value;
          if (prop === "name" || prop === "params" || prop === "selector") {
            node.markDirty();
          }
          return true;
        }
      };
    }
    index(child) {
      if (typeof child === "number")
        return child;
      if (child.proxyOf)
        child = child.proxyOf;
      return this.proxyOf.nodes.indexOf(child);
    }
    insertAfter(exist, add) {
      let existIndex = this.index(exist);
      let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
      existIndex = this.index(exist);
      for (let node of nodes)
        this.proxyOf.nodes.splice(existIndex + 1, 0, node);
      let index;
      for (let id in this.indexes) {
        index = this.indexes[id];
        if (existIndex < index) {
          this.indexes[id] = index + nodes.length;
        }
      }
      this.markDirty();
      return this;
    }
    insertBefore(exist, add) {
      let existIndex = this.index(exist);
      let type = existIndex === 0 ? "prepend" : false;
      let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
      existIndex = this.index(exist);
      for (let node of nodes)
        this.proxyOf.nodes.splice(existIndex, 0, node);
      let index;
      for (let id in this.indexes) {
        index = this.indexes[id];
        if (existIndex <= index) {
          this.indexes[id] = index + nodes.length;
        }
      }
      this.markDirty();
      return this;
    }
    get last() {
      if (!this.proxyOf.nodes)
        return;
      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
    normalize(nodes, sample) {
      if (typeof nodes === "string") {
        nodes = cleanSource(parse(nodes).nodes);
      } else if (Array.isArray(nodes)) {
        nodes = nodes.slice(0);
        for (let i of nodes) {
          if (i.parent)
            i.parent.removeChild(i, "ignore");
        }
      } else if (nodes.type === "root" && this.type !== "document") {
        nodes = nodes.nodes.slice(0);
        for (let i of nodes) {
          if (i.parent)
            i.parent.removeChild(i, "ignore");
        }
      } else if (nodes.type) {
        nodes = [nodes];
      } else if (nodes.prop) {
        if (typeof nodes.value === "undefined") {
          throw new Error("Value field is missed in node creation");
        } else if (typeof nodes.value !== "string") {
          nodes.value = String(nodes.value);
        }
        nodes = [new Declaration(nodes)];
      } else if (nodes.selector) {
        nodes = [new Rule(nodes)];
      } else if (nodes.name) {
        nodes = [new AtRule(nodes)];
      } else if (nodes.text) {
        nodes = [new Comment(nodes)];
      } else {
        throw new Error("Unknown node type in node creation");
      }
      let processed = nodes.map((i) => {
        if (!i[my])
          Container.rebuild(i);
        i = i.proxyOf;
        if (i.parent)
          i.parent.removeChild(i);
        if (i[isClean])
          markDirtyUp(i);
        if (typeof i.raws.before === "undefined") {
          if (sample && typeof sample.raws.before !== "undefined") {
            i.raws.before = sample.raws.before.replace(/\S/g, "");
          }
        }
        i.parent = this.proxyOf;
        return i;
      });
      return processed;
    }
    prepend(...children) {
      children = children.reverse();
      for (let child of children) {
        let nodes = this.normalize(child, this.first, "prepend").reverse();
        for (let node of nodes)
          this.proxyOf.nodes.unshift(node);
        for (let id in this.indexes) {
          this.indexes[id] = this.indexes[id] + nodes.length;
        }
      }
      this.markDirty();
      return this;
    }
    push(child) {
      child.parent = this;
      this.proxyOf.nodes.push(child);
      return this;
    }
    removeAll() {
      for (let node of this.proxyOf.nodes)
        node.parent = undefined;
      this.proxyOf.nodes = [];
      this.markDirty();
      return this;
    }
    removeChild(child) {
      child = this.index(child);
      this.proxyOf.nodes[child].parent = undefined;
      this.proxyOf.nodes.splice(child, 1);
      let index;
      for (let id in this.indexes) {
        index = this.indexes[id];
        if (index >= child) {
          this.indexes[id] = index - 1;
        }
      }
      this.markDirty();
      return this;
    }
    replaceValues(pattern, opts, callback) {
      if (!callback) {
        callback = opts;
        opts = {};
      }
      this.walkDecls((decl) => {
        if (opts.props && !opts.props.includes(decl.prop))
          return;
        if (opts.fast && !decl.value.includes(opts.fast))
          return;
        decl.value = decl.value.replace(pattern, callback);
      });
      this.markDirty();
      return this;
    }
    some(condition) {
      return this.nodes.some(condition);
    }
    walk(callback) {
      return this.each((child, i) => {
        let result;
        try {
          result = callback(child, i);
        } catch (e) {
          throw child.addToError(e);
        }
        if (result !== false && child.walk) {
          result = child.walk(callback);
        }
        return result;
      });
    }
    walkAtRules(name, callback) {
      if (!callback) {
        callback = name;
        return this.walk((child, i) => {
          if (child.type === "atrule") {
            return callback(child, i);
          }
        });
      }
      if (name instanceof RegExp) {
        return this.walk((child, i) => {
          if (child.type === "atrule" && name.test(child.name)) {
            return callback(child, i);
          }
        });
      }
      return this.walk((child, i) => {
        if (child.type === "atrule" && child.name === name) {
          return callback(child, i);
        }
      });
    }
    walkComments(callback) {
      return this.walk((child, i) => {
        if (child.type === "comment") {
          return callback(child, i);
        }
      });
    }
    walkDecls(prop, callback) {
      if (!callback) {
        callback = prop;
        return this.walk((child, i) => {
          if (child.type === "decl") {
            return callback(child, i);
          }
        });
      }
      if (prop instanceof RegExp) {
        return this.walk((child, i) => {
          if (child.type === "decl" && prop.test(child.prop)) {
            return callback(child, i);
          }
        });
      }
      return this.walk((child, i) => {
        if (child.type === "decl" && child.prop === prop) {
          return callback(child, i);
        }
      });
    }
    walkRules(selector, callback) {
      if (!callback) {
        callback = selector;
        return this.walk((child, i) => {
          if (child.type === "rule") {
            return callback(child, i);
          }
        });
      }
      if (selector instanceof RegExp) {
        return this.walk((child, i) => {
          if (child.type === "rule" && selector.test(child.selector)) {
            return callback(child, i);
          }
        });
      }
      return this.walk((child, i) => {
        if (child.type === "rule" && child.selector === selector) {
          return callback(child, i);
        }
      });
    }
  }
  Container.registerParse = (dependant) => {
    parse = dependant;
  };
  Container.registerRule = (dependant) => {
    Rule = dependant;
  };
  Container.registerAtRule = (dependant) => {
    AtRule = dependant;
  };
  Container.registerRoot = (dependant) => {
    Root = dependant;
  };
  module.exports = Container;
  Container.default = Container;
  Container.rebuild = (node) => {
    if (node.type === "atrule") {
      Object.setPrototypeOf(node, AtRule.prototype);
    } else if (node.type === "rule") {
      Object.setPrototypeOf(node, Rule.prototype);
    } else if (node.type === "decl") {
      Object.setPrototypeOf(node, Declaration.prototype);
    } else if (node.type === "comment") {
      Object.setPrototypeOf(node, Comment.prototype);
    } else if (node.type === "root") {
      Object.setPrototypeOf(node, Root.prototype);
    }
    node[my] = true;
    if (node.nodes) {
      node.nodes.forEach((child) => {
        Container.rebuild(child);
      });
    }
  };
});

// node_modules/postcss/lib/document.js
var require_document = __commonJS((exports, module) => {
  var Container = require_container();
  var LazyResult;
  var Processor;

  class Document extends Container {
    constructor(defaults) {
      super({ type: "document", ...defaults });
      if (!this.nodes) {
        this.nodes = [];
      }
    }
    toResult(opts = {}) {
      let lazy = new LazyResult(new Processor, this, opts);
      return lazy.stringify();
    }
  }
  Document.registerLazyResult = (dependant) => {
    LazyResult = dependant;
  };
  Document.registerProcessor = (dependant) => {
    Processor = dependant;
  };
  module.exports = Document;
  Document.default = Document;
});

// node_modules/postcss/lib/warn-once.js
var require_warn_once = __commonJS((exports, module) => {
  var printed = {};
  module.exports = function warnOnce(message) {
    if (printed[message])
      return;
    printed[message] = true;
    if (typeof console !== "undefined" && console.warn) {
      console.warn(message);
    }
  };
});

// node_modules/postcss/lib/warning.js
var require_warning = __commonJS((exports, module) => {
  class Warning {
    constructor(text, opts = {}) {
      this.type = "warning";
      this.text = text;
      if (opts.node && opts.node.source) {
        let range = opts.node.rangeBy(opts);
        this.line = range.start.line;
        this.column = range.start.column;
        this.endLine = range.end.line;
        this.endColumn = range.end.column;
      }
      for (let opt in opts)
        this[opt] = opts[opt];
    }
    toString() {
      if (this.node) {
        return this.node.error(this.text, {
          index: this.index,
          plugin: this.plugin,
          word: this.word
        }).message;
      }
      if (this.plugin) {
        return this.plugin + ": " + this.text;
      }
      return this.text;
    }
  }
  module.exports = Warning;
  Warning.default = Warning;
});

// node_modules/postcss/lib/result.js
var require_result = __commonJS((exports, module) => {
  var Warning = require_warning();

  class Result {
    constructor(processor, root, opts) {
      this.processor = processor;
      this.messages = [];
      this.root = root;
      this.opts = opts;
      this.css = undefined;
      this.map = undefined;
    }
    get content() {
      return this.css;
    }
    toString() {
      return this.css;
    }
    warn(text, opts = {}) {
      if (!opts.plugin) {
        if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
          opts.plugin = this.lastPlugin.postcssPlugin;
        }
      }
      let warning = new Warning(text, opts);
      this.messages.push(warning);
      return warning;
    }
    warnings() {
      return this.messages.filter((i) => i.type === "warning");
    }
  }
  module.exports = Result;
  Result.default = Result;
});

// node_modules/postcss/lib/at-rule.js
var require_at_rule = __commonJS((exports, module) => {
  var Container = require_container();

  class AtRule extends Container {
    constructor(defaults) {
      super(defaults);
      this.type = "atrule";
    }
    append(...children) {
      if (!this.proxyOf.nodes)
        this.nodes = [];
      return super.append(...children);
    }
    prepend(...children) {
      if (!this.proxyOf.nodes)
        this.nodes = [];
      return super.prepend(...children);
    }
  }
  module.exports = AtRule;
  AtRule.default = AtRule;
  Container.registerAtRule(AtRule);
});

// node_modules/postcss/lib/root.js
var require_root = __commonJS((exports, module) => {
  var Container = require_container();
  var LazyResult;
  var Processor;

  class Root extends Container {
    constructor(defaults) {
      super(defaults);
      this.type = "root";
      if (!this.nodes)
        this.nodes = [];
    }
    normalize(child, sample, type) {
      let nodes = super.normalize(child);
      if (sample) {
        if (type === "prepend") {
          if (this.nodes.length > 1) {
            sample.raws.before = this.nodes[1].raws.before;
          } else {
            delete sample.raws.before;
          }
        } else if (this.first !== sample) {
          for (let node of nodes) {
            node.raws.before = sample.raws.before;
          }
        }
      }
      return nodes;
    }
    removeChild(child, ignore) {
      let index = this.index(child);
      if (!ignore && index === 0 && this.nodes.length > 1) {
        this.nodes[1].raws.before = this.nodes[index].raws.before;
      }
      return super.removeChild(child);
    }
    toResult(opts = {}) {
      let lazy = new LazyResult(new Processor, this, opts);
      return lazy.stringify();
    }
  }
  Root.registerLazyResult = (dependant) => {
    LazyResult = dependant;
  };
  Root.registerProcessor = (dependant) => {
    Processor = dependant;
  };
  module.exports = Root;
  Root.default = Root;
  Container.registerRoot(Root);
});

// node_modules/postcss/lib/list.js
var require_list = __commonJS((exports, module) => {
  var list = {
    comma(string) {
      return list.split(string, [","], true);
    },
    space(string) {
      let spaces = [" ", "\n", "\t"];
      return list.split(string, spaces);
    },
    split(string, separators, last) {
      let array = [];
      let current = "";
      let split = false;
      let func = 0;
      let inQuote = false;
      let prevQuote = "";
      let escape = false;
      for (let letter of string) {
        if (escape) {
          escape = false;
        } else if (letter === "\\") {
          escape = true;
        } else if (inQuote) {
          if (letter === prevQuote) {
            inQuote = false;
          }
        } else if (letter === '"' || letter === "'") {
          inQuote = true;
          prevQuote = letter;
        } else if (letter === "(") {
          func += 1;
        } else if (letter === ")") {
          if (func > 0)
            func -= 1;
        } else if (func === 0) {
          if (separators.includes(letter))
            split = true;
        }
        if (split) {
          if (current !== "")
            array.push(current.trim());
          current = "";
          split = false;
        } else {
          current += letter;
        }
      }
      if (last || current !== "")
        array.push(current.trim());
      return array;
    }
  };
  module.exports = list;
  list.default = list;
});

// node_modules/postcss/lib/rule.js
var require_rule = __commonJS((exports, module) => {
  var Container = require_container();
  var list = require_list();

  class Rule extends Container {
    constructor(defaults) {
      super(defaults);
      this.type = "rule";
      if (!this.nodes)
        this.nodes = [];
    }
    get selectors() {
      return list.comma(this.selector);
    }
    set selectors(values) {
      let match = this.selector ? this.selector.match(/,\s*/) : null;
      let sep = match ? match[0] : "," + this.raw("between", "beforeOpen");
      this.selector = values.join(sep);
    }
  }
  module.exports = Rule;
  Rule.default = Rule;
  Container.registerRule(Rule);
});

// node_modules/postcss/lib/parser.js
var require_parser = __commonJS((exports, module) => {
  var findLastWithPosition = function(tokens) {
    for (let i = tokens.length - 1;i >= 0; i--) {
      let token = tokens[i];
      let pos = token[3] || token[2];
      if (pos)
        return pos;
    }
  };
  var Declaration = require_declaration();
  var tokenizer = require_tokenize();
  var Comment = require_comment();
  var AtRule = require_at_rule();
  var Root = require_root();
  var Rule = require_rule();
  var SAFE_COMMENT_NEIGHBOR = {
    empty: true,
    space: true
  };

  class Parser {
    constructor(input) {
      this.input = input;
      this.root = new Root;
      this.current = this.root;
      this.spaces = "";
      this.semicolon = false;
      this.customProperty = false;
      this.createTokenizer();
      this.root.source = { input, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(token) {
      let node = new AtRule;
      node.name = token[1].slice(1);
      if (node.name === "") {
        this.unnamedAtrule(node, token);
      }
      this.init(node, token[2]);
      let type;
      let prev;
      let shift;
      let last = false;
      let open = false;
      let params = [];
      let brackets = [];
      while (!this.tokenizer.endOfFile()) {
        token = this.tokenizer.nextToken();
        type = token[0];
        if (type === "(" || type === "[") {
          brackets.push(type === "(" ? ")" : "]");
        } else if (type === "{" && brackets.length > 0) {
          brackets.push("}");
        } else if (type === brackets[brackets.length - 1]) {
          brackets.pop();
        }
        if (brackets.length === 0) {
          if (type === ";") {
            node.source.end = this.getPosition(token[2]);
            this.semicolon = true;
            break;
          } else if (type === "{") {
            open = true;
            break;
          } else if (type === "}") {
            if (params.length > 0) {
              shift = params.length - 1;
              prev = params[shift];
              while (prev && prev[0] === "space") {
                prev = params[--shift];
              }
              if (prev) {
                node.source.end = this.getPosition(prev[3] || prev[2]);
              }
            }
            this.end(token);
            break;
          } else {
            params.push(token);
          }
        } else {
          params.push(token);
        }
        if (this.tokenizer.endOfFile()) {
          last = true;
          break;
        }
      }
      node.raws.between = this.spacesAndCommentsFromEnd(params);
      if (params.length) {
        node.raws.afterName = this.spacesAndCommentsFromStart(params);
        this.raw(node, "params", params);
        if (last) {
          token = params[params.length - 1];
          node.source.end = this.getPosition(token[3] || token[2]);
          this.spaces = node.raws.between;
          node.raws.between = "";
        }
      } else {
        node.raws.afterName = "";
        node.params = "";
      }
      if (open) {
        node.nodes = [];
        this.current = node;
      }
    }
    checkMissedSemicolon(tokens) {
      let colon = this.colon(tokens);
      if (colon === false)
        return;
      let founded = 0;
      let token;
      for (let j = colon - 1;j >= 0; j--) {
        token = tokens[j];
        if (token[0] !== "space") {
          founded += 1;
          if (founded === 2)
            break;
        }
      }
      throw this.input.error("Missed semicolon", token[0] === "word" ? token[3] + 1 : token[2]);
    }
    colon(tokens) {
      let brackets = 0;
      let token, type, prev;
      for (let [i, element] of tokens.entries()) {
        token = element;
        type = token[0];
        if (type === "(") {
          brackets += 1;
        }
        if (type === ")") {
          brackets -= 1;
        }
        if (brackets === 0 && type === ":") {
          if (!prev) {
            this.doubleColon(token);
          } else if (prev[0] === "word" && prev[1] === "progid") {
            continue;
          } else {
            return i;
          }
        }
        prev = token;
      }
      return false;
    }
    comment(token) {
      let node = new Comment;
      this.init(node, token[2]);
      node.source.end = this.getPosition(token[3] || token[2]);
      let text = token[1].slice(2, -2);
      if (/^\s*$/.test(text)) {
        node.text = "";
        node.raws.left = text;
        node.raws.right = "";
      } else {
        let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
        node.text = match[2];
        node.raws.left = match[1];
        node.raws.right = match[3];
      }
    }
    createTokenizer() {
      this.tokenizer = tokenizer(this.input);
    }
    decl(tokens, customProperty) {
      let node = new Declaration;
      this.init(node, tokens[0][2]);
      let last = tokens[tokens.length - 1];
      if (last[0] === ";") {
        this.semicolon = true;
        tokens.pop();
      }
      node.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));
      while (tokens[0][0] !== "word") {
        if (tokens.length === 1)
          this.unknownWord(tokens);
        node.raws.before += tokens.shift()[1];
      }
      node.source.start = this.getPosition(tokens[0][2]);
      node.prop = "";
      while (tokens.length) {
        let type = tokens[0][0];
        if (type === ":" || type === "space" || type === "comment") {
          break;
        }
        node.prop += tokens.shift()[1];
      }
      node.raws.between = "";
      let token;
      while (tokens.length) {
        token = tokens.shift();
        if (token[0] === ":") {
          node.raws.between += token[1];
          break;
        } else {
          if (token[0] === "word" && /\w/.test(token[1])) {
            this.unknownWord([token]);
          }
          node.raws.between += token[1];
        }
      }
      if (node.prop[0] === "_" || node.prop[0] === "*") {
        node.raws.before += node.prop[0];
        node.prop = node.prop.slice(1);
      }
      let firstSpaces = [];
      let next;
      while (tokens.length) {
        next = tokens[0][0];
        if (next !== "space" && next !== "comment")
          break;
        firstSpaces.push(tokens.shift());
      }
      this.precheckMissedSemicolon(tokens);
      for (let i = tokens.length - 1;i >= 0; i--) {
        token = tokens[i];
        if (token[1].toLowerCase() === "!important") {
          node.important = true;
          let string = this.stringFrom(tokens, i);
          string = this.spacesFromEnd(tokens) + string;
          if (string !== " !important")
            node.raws.important = string;
          break;
        } else if (token[1].toLowerCase() === "important") {
          let cache = tokens.slice(0);
          let str = "";
          for (let j = i;j > 0; j--) {
            let type = cache[j][0];
            if (str.trim().indexOf("!") === 0 && type !== "space") {
              break;
            }
            str = cache.pop()[1] + str;
          }
          if (str.trim().indexOf("!") === 0) {
            node.important = true;
            node.raws.important = str;
            tokens = cache;
          }
        }
        if (token[0] !== "space" && token[0] !== "comment") {
          break;
        }
      }
      let hasWord = tokens.some((i) => i[0] !== "space" && i[0] !== "comment");
      if (hasWord) {
        node.raws.between += firstSpaces.map((i) => i[1]).join("");
        firstSpaces = [];
      }
      this.raw(node, "value", firstSpaces.concat(tokens), customProperty);
      if (node.value.includes(":") && !customProperty) {
        this.checkMissedSemicolon(tokens);
      }
    }
    doubleColon(token) {
      throw this.input.error("Double colon", { offset: token[2] }, { offset: token[2] + token[1].length });
    }
    emptyRule(token) {
      let node = new Rule;
      this.init(node, token[2]);
      node.selector = "";
      node.raws.between = "";
      this.current = node;
    }
    end(token) {
      if (this.current.nodes && this.current.nodes.length) {
        this.current.raws.semicolon = this.semicolon;
      }
      this.semicolon = false;
      this.current.raws.after = (this.current.raws.after || "") + this.spaces;
      this.spaces = "";
      if (this.current.parent) {
        this.current.source.end = this.getPosition(token[2]);
        this.current = this.current.parent;
      } else {
        this.unexpectedClose(token);
      }
    }
    endFile() {
      if (this.current.parent)
        this.unclosedBlock();
      if (this.current.nodes && this.current.nodes.length) {
        this.current.raws.semicolon = this.semicolon;
      }
      this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    }
    freeSemicolon(token) {
      this.spaces += token[1];
      if (this.current.nodes) {
        let prev = this.current.nodes[this.current.nodes.length - 1];
        if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
          prev.raws.ownSemicolon = this.spaces;
          this.spaces = "";
        }
      }
    }
    getPosition(offset) {
      let pos = this.input.fromOffset(offset);
      return {
        column: pos.col,
        line: pos.line,
        offset
      };
    }
    init(node, offset) {
      this.current.push(node);
      node.source = {
        input: this.input,
        start: this.getPosition(offset)
      };
      node.raws.before = this.spaces;
      this.spaces = "";
      if (node.type !== "comment")
        this.semicolon = false;
    }
    other(start) {
      let end = false;
      let type = null;
      let colon = false;
      let bracket = null;
      let brackets = [];
      let customProperty = start[1].startsWith("--");
      let tokens = [];
      let token = start;
      while (token) {
        type = token[0];
        tokens.push(token);
        if (type === "(" || type === "[") {
          if (!bracket)
            bracket = token;
          brackets.push(type === "(" ? ")" : "]");
        } else if (customProperty && colon && type === "{") {
          if (!bracket)
            bracket = token;
          brackets.push("}");
        } else if (brackets.length === 0) {
          if (type === ";") {
            if (colon) {
              this.decl(tokens, customProperty);
              return;
            } else {
              break;
            }
          } else if (type === "{") {
            this.rule(tokens);
            return;
          } else if (type === "}") {
            this.tokenizer.back(tokens.pop());
            end = true;
            break;
          } else if (type === ":") {
            colon = true;
          }
        } else if (type === brackets[brackets.length - 1]) {
          brackets.pop();
          if (brackets.length === 0)
            bracket = null;
        }
        token = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile())
        end = true;
      if (brackets.length > 0)
        this.unclosedBracket(bracket);
      if (end && colon) {
        if (!customProperty) {
          while (tokens.length) {
            token = tokens[tokens.length - 1][0];
            if (token !== "space" && token !== "comment")
              break;
            this.tokenizer.back(tokens.pop());
          }
        }
        this.decl(tokens, customProperty);
      } else {
        this.unknownWord(tokens);
      }
    }
    parse() {
      let token;
      while (!this.tokenizer.endOfFile()) {
        token = this.tokenizer.nextToken();
        switch (token[0]) {
          case "space":
            this.spaces += token[1];
            break;
          case ";":
            this.freeSemicolon(token);
            break;
          case "}":
            this.end(token);
            break;
          case "comment":
            this.comment(token);
            break;
          case "at-word":
            this.atrule(token);
            break;
          case "{":
            this.emptyRule(token);
            break;
          default:
            this.other(token);
            break;
        }
      }
      this.endFile();
    }
    precheckMissedSemicolon() {
    }
    raw(node, prop, tokens, customProperty) {
      let token, type;
      let length = tokens.length;
      let value = "";
      let clean = true;
      let next, prev;
      for (let i = 0;i < length; i += 1) {
        token = tokens[i];
        type = token[0];
        if (type === "space" && i === length - 1 && !customProperty) {
          clean = false;
        } else if (type === "comment") {
          prev = tokens[i - 1] ? tokens[i - 1][0] : "empty";
          next = tokens[i + 1] ? tokens[i + 1][0] : "empty";
          if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
            if (value.slice(-1) === ",") {
              clean = false;
            } else {
              value += token[1];
            }
          } else {
            clean = false;
          }
        } else {
          value += token[1];
        }
      }
      if (!clean) {
        let raw = tokens.reduce((all, i) => all + i[1], "");
        node.raws[prop] = { raw, value };
      }
      node[prop] = value;
    }
    rule(tokens) {
      tokens.pop();
      let node = new Rule;
      this.init(node, tokens[0][2]);
      node.raws.between = this.spacesAndCommentsFromEnd(tokens);
      this.raw(node, "selector", tokens);
      this.current = node;
    }
    spacesAndCommentsFromEnd(tokens) {
      let lastTokenType;
      let spaces = "";
      while (tokens.length) {
        lastTokenType = tokens[tokens.length - 1][0];
        if (lastTokenType !== "space" && lastTokenType !== "comment")
          break;
        spaces = tokens.pop()[1] + spaces;
      }
      return spaces;
    }
    spacesAndCommentsFromStart(tokens) {
      let next;
      let spaces = "";
      while (tokens.length) {
        next = tokens[0][0];
        if (next !== "space" && next !== "comment")
          break;
        spaces += tokens.shift()[1];
      }
      return spaces;
    }
    spacesFromEnd(tokens) {
      let lastTokenType;
      let spaces = "";
      while (tokens.length) {
        lastTokenType = tokens[tokens.length - 1][0];
        if (lastTokenType !== "space")
          break;
        spaces = tokens.pop()[1] + spaces;
      }
      return spaces;
    }
    stringFrom(tokens, from) {
      let result = "";
      for (let i = from;i < tokens.length; i++) {
        result += tokens[i][1];
      }
      tokens.splice(from, tokens.length - from);
      return result;
    }
    unclosedBlock() {
      let pos = this.current.source.start;
      throw this.input.error("Unclosed block", pos.line, pos.column);
    }
    unclosedBracket(bracket) {
      throw this.input.error("Unclosed bracket", { offset: bracket[2] }, { offset: bracket[2] + 1 });
    }
    unexpectedClose(token) {
      throw this.input.error("Unexpected }", { offset: token[2] }, { offset: token[2] + 1 });
    }
    unknownWord(tokens) {
      throw this.input.error("Unknown word", { offset: tokens[0][2] }, { offset: tokens[0][2] + tokens[0][1].length });
    }
    unnamedAtrule(node, token) {
      throw this.input.error("At-rule without name", { offset: token[2] }, { offset: token[2] + token[1].length });
    }
  }
  module.exports = Parser;
});

// node_modules/postcss/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var parse = function(css, opts) {
    let input = new Input(css, opts);
    let parser = new Parser(input);
    try {
      parser.parse();
    } catch (e) {
      if (true) {
        if (e.name === "CssSyntaxError" && opts && opts.from) {
          if (/\.scss$/i.test(opts.from)) {
            e.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
          } else if (/\.sass/i.test(opts.from)) {
            e.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
          } else if (/\.less$/i.test(opts.from)) {
            e.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
          }
        }
      }
      throw e;
    }
    return parser.root;
  };
  var Container = require_container();
  var Parser = require_parser();
  var Input = require_input();
  module.exports = parse;
  parse.default = parse;
  Container.registerParse(parse);
});

// node_modules/postcss/lib/lazy-result.js
var require_lazy_result = __commonJS((exports, module) => {
  var isPromise = function(obj) {
    return typeof obj === "object" && typeof obj.then === "function";
  };
  var getEvents = function(node) {
    let key = false;
    let type = TYPE_TO_CLASS_NAME[node.type];
    if (node.type === "decl") {
      key = node.prop.toLowerCase();
    } else if (node.type === "atrule") {
      key = node.name.toLowerCase();
    }
    if (key && node.append) {
      return [
        type,
        type + "-" + key,
        CHILDREN,
        type + "Exit",
        type + "Exit-" + key
      ];
    } else if (key) {
      return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
    } else if (node.append) {
      return [type, CHILDREN, type + "Exit"];
    } else {
      return [type, type + "Exit"];
    }
  };
  var toStack = function(node) {
    let events;
    if (node.type === "document") {
      events = ["Document", CHILDREN, "DocumentExit"];
    } else if (node.type === "root") {
      events = ["Root", CHILDREN, "RootExit"];
    } else {
      events = getEvents(node);
    }
    return {
      eventIndex: 0,
      events,
      iterator: 0,
      node,
      visitorIndex: 0,
      visitors: []
    };
  };
  var cleanMarks = function(node) {
    node[isClean] = false;
    if (node.nodes)
      node.nodes.forEach((i) => cleanMarks(i));
    return node;
  };
  var { isClean, my } = require_symbols();
  var MapGenerator = require_map_generator();
  var stringify = require_stringify2();
  var Container = require_container();
  var Document = require_document();
  var warnOnce = require_warn_once();
  var Result = require_result();
  var parse = require_parse();
  var Root = require_root();
  var TYPE_TO_CLASS_NAME = {
    atrule: "AtRule",
    comment: "Comment",
    decl: "Declaration",
    document: "Document",
    root: "Root",
    rule: "Rule"
  };
  var PLUGIN_PROPS = {
    AtRule: true,
    AtRuleExit: true,
    Comment: true,
    CommentExit: true,
    Declaration: true,
    DeclarationExit: true,
    Document: true,
    DocumentExit: true,
    Once: true,
    OnceExit: true,
    postcssPlugin: true,
    prepare: true,
    Root: true,
    RootExit: true,
    Rule: true,
    RuleExit: true
  };
  var NOT_VISITORS = {
    Once: true,
    postcssPlugin: true,
    prepare: true
  };
  var CHILDREN = 0;
  var postcss = {};

  class LazyResult {
    constructor(processor, css, opts) {
      this.stringified = false;
      this.processed = false;
      let root;
      if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
        root = cleanMarks(css);
      } else if (css instanceof LazyResult || css instanceof Result) {
        root = cleanMarks(css.root);
        if (css.map) {
          if (typeof opts.map === "undefined")
            opts.map = {};
          if (!opts.map.inline)
            opts.map.inline = false;
          opts.map.prev = css.map;
        }
      } else {
        let parser = parse;
        if (opts.syntax)
          parser = opts.syntax.parse;
        if (opts.parser)
          parser = opts.parser;
        if (parser.parse)
          parser = parser.parse;
        try {
          root = parser(css, opts);
        } catch (error) {
          this.processed = true;
          this.error = error;
        }
        if (root && !root[my]) {
          Container.rebuild(root);
        }
      }
      this.result = new Result(processor, root, opts);
      this.helpers = { ...postcss, postcss, result: this.result };
      this.plugins = this.processor.plugins.map((plugin) => {
        if (typeof plugin === "object" && plugin.prepare) {
          return { ...plugin, ...plugin.prepare(this.result) };
        } else {
          return plugin;
        }
      });
    }
    async() {
      if (this.error)
        return Promise.reject(this.error);
      if (this.processed)
        return Promise.resolve(this.result);
      if (!this.processing) {
        this.processing = this.runAsync();
      }
      return this.processing;
    }
    catch(onRejected) {
      return this.async().catch(onRejected);
    }
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    finally(onFinally) {
      return this.async().then(onFinally, onFinally);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(error, node) {
      let plugin = this.result.lastPlugin;
      try {
        if (node)
          node.addToError(error);
        this.error = error;
        if (error.name === "CssSyntaxError" && !error.plugin) {
          error.plugin = plugin.postcssPlugin;
          error.setMessage();
        } else if (plugin.postcssVersion) {
          if (true) {
            let pluginName = plugin.postcssPlugin;
            let pluginVer = plugin.postcssVersion;
            let runtimeVer = this.result.processor.version;
            let a = pluginVer.split(".");
            let b = runtimeVer.split(".");
            if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
              console.error("Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below.");
            }
          }
        }
      } catch (err) {
        if (console && console.error)
          console.error(err);
      }
      return error;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    prepareVisitors() {
      this.listeners = {};
      let add = (plugin, type, cb) => {
        if (!this.listeners[type])
          this.listeners[type] = [];
        this.listeners[type].push([plugin, cb]);
      };
      for (let plugin of this.plugins) {
        if (typeof plugin === "object") {
          for (let event in plugin) {
            if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
              throw new Error(`Unknown event ${event} in ${plugin.postcssPlugin}. ` + `Try to update PostCSS (${this.processor.version} now).`);
            }
            if (!NOT_VISITORS[event]) {
              if (typeof plugin[event] === "object") {
                for (let filter in plugin[event]) {
                  if (filter === "*") {
                    add(plugin, event, plugin[event][filter]);
                  } else {
                    add(plugin, event + "-" + filter.toLowerCase(), plugin[event][filter]);
                  }
                }
              } else if (typeof plugin[event] === "function") {
                add(plugin, event, plugin[event]);
              }
            }
          }
        }
      }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    async runAsync() {
      this.plugin = 0;
      for (let i = 0;i < this.plugins.length; i++) {
        let plugin = this.plugins[i];
        let promise = this.runOnRoot(plugin);
        if (isPromise(promise)) {
          try {
            await promise;
          } catch (error) {
            throw this.handleError(error);
          }
        }
      }
      this.prepareVisitors();
      if (this.hasListener) {
        let root = this.result.root;
        while (!root[isClean]) {
          root[isClean] = true;
          let stack = [toStack(root)];
          while (stack.length > 0) {
            let promise = this.visitTick(stack);
            if (isPromise(promise)) {
              try {
                await promise;
              } catch (e) {
                let node = stack[stack.length - 1].node;
                throw this.handleError(e, node);
              }
            }
          }
        }
        if (this.listeners.OnceExit) {
          for (let [plugin, visitor] of this.listeners.OnceExit) {
            this.result.lastPlugin = plugin;
            try {
              if (root.type === "document") {
                let roots = root.nodes.map((subRoot) => visitor(subRoot, this.helpers));
                await Promise.all(roots);
              } else {
                await visitor(root, this.helpers);
              }
            } catch (e) {
              throw this.handleError(e);
            }
          }
        }
      }
      this.processed = true;
      return this.stringify();
    }
    runOnRoot(plugin) {
      this.result.lastPlugin = plugin;
      try {
        if (typeof plugin === "object" && plugin.Once) {
          if (this.result.root.type === "document") {
            let roots = this.result.root.nodes.map((root) => plugin.Once(root, this.helpers));
            if (isPromise(roots[0])) {
              return Promise.all(roots);
            }
            return roots;
          }
          return plugin.Once(this.result.root, this.helpers);
        } else if (typeof plugin === "function") {
          return plugin(this.result.root, this.result);
        }
      } catch (error) {
        throw this.handleError(error);
      }
    }
    stringify() {
      if (this.error)
        throw this.error;
      if (this.stringified)
        return this.result;
      this.stringified = true;
      this.sync();
      let opts = this.result.opts;
      let str = stringify;
      if (opts.syntax)
        str = opts.syntax.stringify;
      if (opts.stringifier)
        str = opts.stringifier;
      if (str.stringify)
        str = str.stringify;
      let map = new MapGenerator(str, this.result.root, this.result.opts);
      let data = map.generate();
      this.result.css = data[0];
      this.result.map = data[1];
      return this.result;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
    sync() {
      if (this.error)
        throw this.error;
      if (this.processed)
        return this.result;
      this.processed = true;
      if (this.processing) {
        throw this.getAsyncError();
      }
      for (let plugin of this.plugins) {
        let promise = this.runOnRoot(plugin);
        if (isPromise(promise)) {
          throw this.getAsyncError();
        }
      }
      this.prepareVisitors();
      if (this.hasListener) {
        let root = this.result.root;
        while (!root[isClean]) {
          root[isClean] = true;
          this.walkSync(root);
        }
        if (this.listeners.OnceExit) {
          if (root.type === "document") {
            for (let subRoot of root.nodes) {
              this.visitSync(this.listeners.OnceExit, subRoot);
            }
          } else {
            this.visitSync(this.listeners.OnceExit, root);
          }
        }
      }
      return this.result;
    }
    then(onFulfilled, onRejected) {
      if (true) {
        if (!("from" in this.opts)) {
          warnOnce("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.");
        }
      }
      return this.async().then(onFulfilled, onRejected);
    }
    toString() {
      return this.css;
    }
    visitSync(visitors, node) {
      for (let [plugin, visitor] of visitors) {
        this.result.lastPlugin = plugin;
        let promise;
        try {
          promise = visitor(node, this.helpers);
        } catch (e) {
          throw this.handleError(e, node.proxyOf);
        }
        if (node.type !== "root" && node.type !== "document" && !node.parent) {
          return true;
        }
        if (isPromise(promise)) {
          throw this.getAsyncError();
        }
      }
    }
    visitTick(stack) {
      let visit = stack[stack.length - 1];
      let { node, visitors } = visit;
      if (node.type !== "root" && node.type !== "document" && !node.parent) {
        stack.pop();
        return;
      }
      if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
        let [plugin, visitor] = visitors[visit.visitorIndex];
        visit.visitorIndex += 1;
        if (visit.visitorIndex === visitors.length) {
          visit.visitors = [];
          visit.visitorIndex = 0;
        }
        this.result.lastPlugin = plugin;
        try {
          return visitor(node.toProxy(), this.helpers);
        } catch (e) {
          throw this.handleError(e, node);
        }
      }
      if (visit.iterator !== 0) {
        let iterator = visit.iterator;
        let child;
        while (child = node.nodes[node.indexes[iterator]]) {
          node.indexes[iterator] += 1;
          if (!child[isClean]) {
            child[isClean] = true;
            stack.push(toStack(child));
            return;
          }
        }
        visit.iterator = 0;
        delete node.indexes[iterator];
      }
      let events = visit.events;
      while (visit.eventIndex < events.length) {
        let event = events[visit.eventIndex];
        visit.eventIndex += 1;
        if (event === CHILDREN) {
          if (node.nodes && node.nodes.length) {
            node[isClean] = true;
            visit.iterator = node.getIterator();
          }
          return;
        } else if (this.listeners[event]) {
          visit.visitors = this.listeners[event];
          return;
        }
      }
      stack.pop();
    }
    walkSync(node) {
      node[isClean] = true;
      let events = getEvents(node);
      for (let event of events) {
        if (event === CHILDREN) {
          if (node.nodes) {
            node.each((child) => {
              if (!child[isClean])
                this.walkSync(child);
            });
          }
        } else {
          let visitors = this.listeners[event];
          if (visitors) {
            if (this.visitSync(visitors, node.toProxy()))
              return;
          }
        }
      }
    }
    warnings() {
      return this.sync().warnings();
    }
  }
  LazyResult.registerPostcss = (dependant) => {
    postcss = dependant;
  };
  module.exports = LazyResult;
  LazyResult.default = LazyResult;
  Root.registerLazyResult(LazyResult);
  Document.registerLazyResult(LazyResult);
});

// node_modules/postcss/lib/no-work-result.js
var require_no_work_result = __commonJS((exports, module) => {
  var MapGenerator = require_map_generator();
  var stringify = require_stringify2();
  var warnOnce = require_warn_once();
  var parse = require_parse();
  var Result = require_result();

  class NoWorkResult {
    constructor(processor, css, opts) {
      css = css.toString();
      this.stringified = false;
      this._processor = processor;
      this._css = css;
      this._opts = opts;
      this._map = undefined;
      let root;
      let str = stringify;
      this.result = new Result(this._processor, root, this._opts);
      this.result.css = css;
      let self2 = this;
      Object.defineProperty(this.result, "root", {
        get() {
          return self2.root;
        }
      });
      let map = new MapGenerator(str, root, this._opts, css);
      if (map.isMap()) {
        let [generatedCSS, generatedMap] = map.generate();
        if (generatedCSS) {
          this.result.css = generatedCSS;
        }
        if (generatedMap) {
          this.result.map = generatedMap;
        }
      }
    }
    async() {
      if (this.error)
        return Promise.reject(this.error);
      return Promise.resolve(this.result);
    }
    catch(onRejected) {
      return this.async().catch(onRejected);
    }
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    finally(onFinally) {
      return this.async().then(onFinally, onFinally);
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root) {
        return this._root;
      }
      let root;
      let parser = parse;
      try {
        root = parser(this._css, this._opts);
      } catch (error) {
        this.error = error;
      }
      if (this.error) {
        throw this.error;
      } else {
        this._root = root;
        return root;
      }
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
    sync() {
      if (this.error)
        throw this.error;
      return this.result;
    }
    then(onFulfilled, onRejected) {
      if (true) {
        if (!("from" in this._opts)) {
          warnOnce("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.");
        }
      }
      return this.async().then(onFulfilled, onRejected);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
  }
  module.exports = NoWorkResult;
  NoWorkResult.default = NoWorkResult;
});

// node_modules/postcss/lib/processor.js
var require_processor = __commonJS((exports, module) => {
  var NoWorkResult = require_no_work_result();
  var LazyResult = require_lazy_result();
  var Document = require_document();
  var Root = require_root();

  class Processor {
    constructor(plugins = []) {
      this.version = "8.4.27";
      this.plugins = this.normalize(plugins);
    }
    normalize(plugins) {
      let normalized = [];
      for (let i of plugins) {
        if (i.postcss === true) {
          i = i();
        } else if (i.postcss) {
          i = i.postcss;
        }
        if (typeof i === "object" && Array.isArray(i.plugins)) {
          normalized = normalized.concat(i.plugins);
        } else if (typeof i === "object" && i.postcssPlugin) {
          normalized.push(i);
        } else if (typeof i === "function") {
          normalized.push(i);
        } else if (typeof i === "object" && (i.parse || i.stringify)) {
          if (true) {
            throw new Error("PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.");
          }
        } else {
          throw new Error(i + " is not a PostCSS plugin");
        }
      }
      return normalized;
    }
    process(css, opts = {}) {
      if (this.plugins.length === 0 && typeof opts.parser === "undefined" && typeof opts.stringifier === "undefined" && typeof opts.syntax === "undefined") {
        return new NoWorkResult(this, css, opts);
      } else {
        return new LazyResult(this, css, opts);
      }
    }
    use(plugin) {
      this.plugins = this.plugins.concat(this.normalize([plugin]));
      return this;
    }
  }
  module.exports = Processor;
  Processor.default = Processor;
  Root.registerProcessor(Processor);
  Document.registerProcessor(Processor);
});

// node_modules/postcss/lib/fromJSON.js
var require_fromJSON = __commonJS((exports, module) => {
  var fromJSON = function(json, inputs) {
    if (Array.isArray(json))
      return json.map((n) => fromJSON(n));
    let { inputs: ownInputs, ...defaults } = json;
    if (ownInputs) {
      inputs = [];
      for (let input of ownInputs) {
        let inputHydrated = { ...input, __proto__: Input.prototype };
        if (inputHydrated.map) {
          inputHydrated.map = {
            ...inputHydrated.map,
            __proto__: PreviousMap.prototype
          };
        }
        inputs.push(inputHydrated);
      }
    }
    if (defaults.nodes) {
      defaults.nodes = json.nodes.map((n) => fromJSON(n, inputs));
    }
    if (defaults.source) {
      let { inputId, ...source } = defaults.source;
      defaults.source = source;
      if (inputId != null) {
        defaults.source.input = inputs[inputId];
      }
    }
    if (defaults.type === "root") {
      return new Root(defaults);
    } else if (defaults.type === "decl") {
      return new Declaration(defaults);
    } else if (defaults.type === "rule") {
      return new Rule(defaults);
    } else if (defaults.type === "comment") {
      return new Comment(defaults);
    } else if (defaults.type === "atrule") {
      return new AtRule(defaults);
    } else {
      throw new Error("Unknown node type: " + json.type);
    }
  };
  var Declaration = require_declaration();
  var PreviousMap = require_previous_map();
  var Comment = require_comment();
  var AtRule = require_at_rule();
  var Input = require_input();
  var Root = require_root();
  var Rule = require_rule();
  module.exports = fromJSON;
  fromJSON.default = fromJSON;
});

// node_modules/postcss/lib/postcss.js
var require_postcss = __commonJS((exports, module) => {
  var postcss = function(...plugins) {
    if (plugins.length === 1 && Array.isArray(plugins[0])) {
      plugins = plugins[0];
    }
    return new Processor(plugins);
  };
  var CssSyntaxError = require_css_syntax_error();
  var Declaration = require_declaration();
  var LazyResult = require_lazy_result();
  var Container = require_container();
  var Processor = require_processor();
  var stringify = require_stringify2();
  var fromJSON = require_fromJSON();
  var Document = require_document();
  var Warning = require_warning();
  var Comment = require_comment();
  var AtRule = require_at_rule();
  var Result = require_result();
  var Input = require_input();
  var parse = require_parse();
  var list = require_list();
  var Rule = require_rule();
  var Root = require_root();
  var Node = require_node2();
  postcss.plugin = function plugin(name, initializer) {
    let warningPrinted = false;
    function creator(...args) {
      if (console && console.warn && !warningPrinted) {
        warningPrinted = true;
        console.warn(name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration");
        if ("en_US.UTF-8".startsWith("cn")) {
          console.warn(name + `: \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:
` + "https://www.w3ctech.com/topic/2226");
        }
      }
      let transformer = initializer(...args);
      transformer.postcssPlugin = name;
      transformer.postcssVersion = new Processor().version;
      return transformer;
    }
    let cache;
    Object.defineProperty(creator, "postcss", {
      get() {
        if (!cache)
          cache = creator();
        return cache;
      }
    });
    creator.process = function(css, processOpts, pluginOpts) {
      return postcss([creator(pluginOpts)]).process(css, processOpts);
    };
    return creator;
  };
  postcss.stringify = stringify;
  postcss.parse = parse;
  postcss.fromJSON = fromJSON;
  postcss.list = list;
  postcss.comment = (defaults) => new Comment(defaults);
  postcss.atRule = (defaults) => new AtRule(defaults);
  postcss.decl = (defaults) => new Declaration(defaults);
  postcss.rule = (defaults) => new Rule(defaults);
  postcss.root = (defaults) => new Root(defaults);
  postcss.document = (defaults) => new Document(defaults);
  postcss.CssSyntaxError = CssSyntaxError;
  postcss.Declaration = Declaration;
  postcss.Container = Container;
  postcss.Processor = Processor;
  postcss.Document = Document;
  postcss.Comment = Comment;
  postcss.Warning = Warning;
  postcss.AtRule = AtRule;
  postcss.Result = Result;
  postcss.Input = Input;
  postcss.Rule = Rule;
  postcss.Root = Root;
  postcss.Node = Node;
  LazyResult.registerPostcss(postcss);
  module.exports = postcss;
  postcss.default = postcss;
});

// node_modules/sanitize-html/index.js
var require_sanitize_html = __commonJS((exports, module) => {
  var each = function(obj, cb) {
    if (obj) {
      Object.keys(obj).forEach(function(key) {
        cb(obj[key], key);
      });
    }
  };
  var has = function(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  };
  var filter = function(a, cb) {
    const n = [];
    each(a, function(v) {
      if (cb(v)) {
        n.push(v);
      }
    });
    return n;
  };
  var isEmptyObject = function(obj) {
    for (const key in obj) {
      if (has(obj, key)) {
        return false;
      }
    }
    return true;
  };
  var stringifySrcset = function(parsedSrcset) {
    return parsedSrcset.map(function(part) {
      if (!part.url) {
        throw new Error("URL missing");
      }
      return part.url + (part.w ? ` ${part.w}w` : "") + (part.h ? ` ${part.h}h` : "") + (part.d ? ` ${part.d}x` : "");
    }).join(", ");
  };
  var sanitizeHtml = function(html, options, _recursing) {
    if (html == null) {
      return "";
    }
    if (typeof html === "number") {
      html = html.toString();
    }
    let result = "";
    let tempResult = "";
    function Frame(tag, attribs) {
      const that = this;
      this.tag = tag;
      this.attribs = attribs || {};
      this.tagPosition = result.length;
      this.text = "";
      this.mediaChildren = [];
      this.updateParentNodeText = function() {
        if (stack.length) {
          const parentFrame = stack[stack.length - 1];
          parentFrame.text += that.text;
        }
      };
      this.updateParentNodeMediaChildren = function() {
        if (stack.length && mediaTags.includes(this.tag)) {
          const parentFrame = stack[stack.length - 1];
          parentFrame.mediaChildren.push(this.tag);
        }
      };
    }
    options = Object.assign({}, sanitizeHtml.defaults, options);
    options.parser = Object.assign({}, htmlParserDefaults, options.parser);
    const tagAllowed = function(name) {
      return options.allowedTags === false || (options.allowedTags || []).indexOf(name) > -1;
    };
    vulnerableTags.forEach(function(tag) {
      if (tagAllowed(tag) && !options.allowVulnerableTags) {
        console.warn(`

\u26A0\uFE0F Your \`allowedTags\` option includes, \`${tag}\`, which is inherently\nvulnerable to XSS attacks. Please remove it from \`allowedTags\`.\nOr, to disable this warning, add the \`allowVulnerableTags\` option\nand ensure you are accounting for this risk.\n\n`);
      }
    });
    const nonTextTagsArray = options.nonTextTags || [
      "script",
      "style",
      "textarea",
      "option"
    ];
    let allowedAttributesMap;
    let allowedAttributesGlobMap;
    if (options.allowedAttributes) {
      allowedAttributesMap = {};
      allowedAttributesGlobMap = {};
      each(options.allowedAttributes, function(attributes, tag) {
        allowedAttributesMap[tag] = [];
        const globRegex = [];
        attributes.forEach(function(obj) {
          if (typeof obj === "string" && obj.indexOf("*") >= 0) {
            globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
          } else {
            allowedAttributesMap[tag].push(obj);
          }
        });
        if (globRegex.length) {
          allowedAttributesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
        }
      });
    }
    const allowedClassesMap = {};
    const allowedClassesGlobMap = {};
    const allowedClassesRegexMap = {};
    each(options.allowedClasses, function(classes, tag) {
      if (allowedAttributesMap) {
        if (!has(allowedAttributesMap, tag)) {
          allowedAttributesMap[tag] = [];
        }
        allowedAttributesMap[tag].push("class");
      }
      allowedClassesMap[tag] = classes;
      if (Array.isArray(classes)) {
        const globRegex = [];
        allowedClassesMap[tag] = [];
        allowedClassesRegexMap[tag] = [];
        classes.forEach(function(obj) {
          if (typeof obj === "string" && obj.indexOf("*") >= 0) {
            globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
          } else if (obj instanceof RegExp) {
            allowedClassesRegexMap[tag].push(obj);
          } else {
            allowedClassesMap[tag].push(obj);
          }
        });
        if (globRegex.length) {
          allowedClassesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
        }
      }
    });
    const transformTagsMap = {};
    let transformTagsAll;
    each(options.transformTags, function(transform, tag) {
      let transFun;
      if (typeof transform === "function") {
        transFun = transform;
      } else if (typeof transform === "string") {
        transFun = sanitizeHtml.simpleTransform(transform);
      }
      if (tag === "*") {
        transformTagsAll = transFun;
      } else {
        transformTagsMap[tag] = transFun;
      }
    });
    let depth;
    let stack;
    let skipMap;
    let transformMap;
    let skipText;
    let skipTextDepth;
    let addedText = false;
    initializeState();
    const parser = new htmlparser.Parser({
      onopentag: function(name, attribs) {
        if (options.enforceHtmlBoundary && name === "html") {
          initializeState();
        }
        if (skipText) {
          skipTextDepth++;
          return;
        }
        const frame = new Frame(name, attribs);
        stack.push(frame);
        let skip = false;
        const hasText = !!frame.text;
        let transformedTag;
        if (has(transformTagsMap, name)) {
          transformedTag = transformTagsMap[name](name, attribs);
          frame.attribs = attribs = transformedTag.attribs;
          if (transformedTag.text !== undefined) {
            frame.innerText = transformedTag.text;
          }
          if (name !== transformedTag.tagName) {
            frame.name = name = transformedTag.tagName;
            transformMap[depth] = transformedTag.tagName;
          }
        }
        if (transformTagsAll) {
          transformedTag = transformTagsAll(name, attribs);
          frame.attribs = attribs = transformedTag.attribs;
          if (name !== transformedTag.tagName) {
            frame.name = name = transformedTag.tagName;
            transformMap[depth] = transformedTag.tagName;
          }
        }
        if (!tagAllowed(name) || options.disallowedTagsMode === "recursiveEscape" && !isEmptyObject(skipMap) || options.nestingLimit != null && depth >= options.nestingLimit) {
          skip = true;
          skipMap[depth] = true;
          if (options.disallowedTagsMode === "discard") {
            if (nonTextTagsArray.indexOf(name) !== -1) {
              skipText = true;
              skipTextDepth = 1;
            }
          }
          skipMap[depth] = true;
        }
        depth++;
        if (skip) {
          if (options.disallowedTagsMode === "discard") {
            return;
          }
          tempResult = result;
          result = "";
        }
        result += "<" + name;
        if (name === "script") {
          if (options.allowedScriptHostnames || options.allowedScriptDomains) {
            frame.innerText = "";
          }
        }
        if (!allowedAttributesMap || has(allowedAttributesMap, name) || allowedAttributesMap["*"]) {
          each(attribs, function(value, a) {
            if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {
              delete frame.attribs[a];
              return;
            }
            if (value === "" && (options.nonBooleanAttributes.includes(a) || options.nonBooleanAttributes.includes("*"))) {
              delete frame.attribs[a];
              return;
            }
            let passedAllowedAttributesMapCheck = false;
            if (!allowedAttributesMap || has(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a) !== -1 || allowedAttributesMap["*"] && allowedAttributesMap["*"].indexOf(a) !== -1 || has(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a) || allowedAttributesGlobMap["*"] && allowedAttributesGlobMap["*"].test(a)) {
              passedAllowedAttributesMapCheck = true;
            } else if (allowedAttributesMap && allowedAttributesMap[name]) {
              for (const o of allowedAttributesMap[name]) {
                if (isPlainObject(o) && o.name && o.name === a) {
                  passedAllowedAttributesMapCheck = true;
                  let newValue = "";
                  if (o.multiple === true) {
                    const splitStrArray = value.split(" ");
                    for (const s of splitStrArray) {
                      if (o.values.indexOf(s) !== -1) {
                        if (newValue === "") {
                          newValue = s;
                        } else {
                          newValue += " " + s;
                        }
                      }
                    }
                  } else if (o.values.indexOf(value) >= 0) {
                    newValue = value;
                  }
                  value = newValue;
                }
              }
            }
            if (passedAllowedAttributesMapCheck) {
              if (options.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {
                if (naughtyHref(name, value)) {
                  delete frame.attribs[a];
                  return;
                }
              }
              if (name === "script" && a === "src") {
                let allowed = true;
                try {
                  const parsed = parseUrl(value);
                  if (options.allowedScriptHostnames || options.allowedScriptDomains) {
                    const allowedHostname = (options.allowedScriptHostnames || []).find(function(hostname) {
                      return hostname === parsed.url.hostname;
                    });
                    const allowedDomain = (options.allowedScriptDomains || []).find(function(domain) {
                      return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                    });
                    allowed = allowedHostname || allowedDomain;
                  }
                } catch (e) {
                  allowed = false;
                }
                if (!allowed) {
                  delete frame.attribs[a];
                  return;
                }
              }
              if (name === "iframe" && a === "src") {
                let allowed = true;
                try {
                  const parsed = parseUrl(value);
                  if (parsed.isRelativeUrl) {
                    allowed = has(options, "allowIframeRelativeUrls") ? options.allowIframeRelativeUrls : !options.allowedIframeHostnames && !options.allowedIframeDomains;
                  } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {
                    const allowedHostname = (options.allowedIframeHostnames || []).find(function(hostname) {
                      return hostname === parsed.url.hostname;
                    });
                    const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {
                      return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                    });
                    allowed = allowedHostname || allowedDomain;
                  }
                } catch (e) {
                  allowed = false;
                }
                if (!allowed) {
                  delete frame.attribs[a];
                  return;
                }
              }
              if (a === "srcset") {
                try {
                  let parsed = parseSrcset(value);
                  parsed.forEach(function(value2) {
                    if (naughtyHref("srcset", value2.url)) {
                      value2.evil = true;
                    }
                  });
                  parsed = filter(parsed, function(v) {
                    return !v.evil;
                  });
                  if (!parsed.length) {
                    delete frame.attribs[a];
                    return;
                  } else {
                    value = stringifySrcset(filter(parsed, function(v) {
                      return !v.evil;
                    }));
                    frame.attribs[a] = value;
                  }
                } catch (e) {
                  delete frame.attribs[a];
                  return;
                }
              }
              if (a === "class") {
                const allowedSpecificClasses = allowedClassesMap[name];
                const allowedWildcardClasses = allowedClassesMap["*"];
                const allowedSpecificClassesGlob = allowedClassesGlobMap[name];
                const allowedSpecificClassesRegex = allowedClassesRegexMap[name];
                const allowedWildcardClassesGlob = allowedClassesGlobMap["*"];
                const allowedClassesGlobs = [
                  allowedSpecificClassesGlob,
                  allowedWildcardClassesGlob
                ].concat(allowedSpecificClassesRegex).filter(function(t) {
                  return t;
                });
                if (allowedSpecificClasses && allowedWildcardClasses) {
                  value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);
                } else {
                  value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);
                }
                if (!value.length) {
                  delete frame.attribs[a];
                  return;
                }
              }
              if (a === "style") {
                if (options.parseStyleAttributes) {
                  try {
                    const abstractSyntaxTree = postcssParse(name + " {" + value + "}");
                    const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);
                    value = stringifyStyleAttributes(filteredAST);
                    if (value.length === 0) {
                      delete frame.attribs[a];
                      return;
                    }
                  } catch (e) {
                    if (typeof window !== "undefined") {
                      console.warn('Failed to parse "' + name + " {" + value + '}", If you\'re running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547');
                    }
                    delete frame.attribs[a];
                    return;
                  }
                } else if (options.allowedStyles) {
                  throw new Error("allowedStyles option cannot be used together with parseStyleAttributes: false.");
                }
              }
              result += " " + a;
              if (value && value.length) {
                result += '="' + escapeHtml(value, true) + '"';
              }
            } else {
              delete frame.attribs[a];
            }
          });
        }
        if (options.selfClosing.indexOf(name) !== -1) {
          result += " />";
        } else {
          result += ">";
          if (frame.innerText && !hasText && !options.textFilter) {
            result += escapeHtml(frame.innerText);
            addedText = true;
          }
        }
        if (skip) {
          result = tempResult + escapeHtml(result);
          tempResult = "";
        }
      },
      ontext: function(text) {
        if (skipText) {
          return;
        }
        const lastFrame = stack[stack.length - 1];
        let tag;
        if (lastFrame) {
          tag = lastFrame.tag;
          text = lastFrame.innerText !== undefined ? lastFrame.innerText : text;
        }
        if (options.disallowedTagsMode === "discard" && (tag === "script" || tag === "style")) {
          result += text;
        } else {
          const escaped = escapeHtml(text, false);
          if (options.textFilter && !addedText) {
            result += options.textFilter(escaped, tag);
          } else if (!addedText) {
            result += escaped;
          }
        }
        if (stack.length) {
          const frame = stack[stack.length - 1];
          frame.text += text;
        }
      },
      onclosetag: function(name, isImplied) {
        if (skipText) {
          skipTextDepth--;
          if (!skipTextDepth) {
            skipText = false;
          } else {
            return;
          }
        }
        const frame = stack.pop();
        if (!frame) {
          return;
        }
        if (frame.tag !== name) {
          stack.push(frame);
          return;
        }
        skipText = options.enforceHtmlBoundary ? name === "html" : false;
        depth--;
        const skip = skipMap[depth];
        if (skip) {
          delete skipMap[depth];
          if (options.disallowedTagsMode === "discard") {
            frame.updateParentNodeText();
            return;
          }
          tempResult = result;
          result = "";
        }
        if (transformMap[depth]) {
          name = transformMap[depth];
          delete transformMap[depth];
        }
        if (options.exclusiveFilter && options.exclusiveFilter(frame)) {
          result = result.substr(0, frame.tagPosition);
          return;
        }
        frame.updateParentNodeMediaChildren();
        frame.updateParentNodeText();
        if (options.selfClosing.indexOf(name) !== -1 || isImplied && !tagAllowed(name) && ["escape", "recursiveEscape"].indexOf(options.disallowedTagsMode) >= 0) {
          if (skip) {
            result = tempResult;
            tempResult = "";
          }
          return;
        }
        result += "</" + name + ">";
        if (skip) {
          result = tempResult + escapeHtml(result);
          tempResult = "";
        }
        addedText = false;
      }
    }, options.parser);
    parser.write(html);
    parser.end();
    return result;
    function initializeState() {
      result = "";
      depth = 0;
      stack = [];
      skipMap = {};
      transformMap = {};
      skipText = false;
      skipTextDepth = 0;
    }
    function escapeHtml(s, quote) {
      if (typeof s !== "string") {
        s = s + "";
      }
      if (options.parser.decodeEntities) {
        s = s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        if (quote) {
          s = s.replace(/"/g, "&quot;");
        }
      }
      s = s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      if (quote) {
        s = s.replace(/"/g, "&quot;");
      }
      return s;
    }
    function naughtyHref(name, href) {
      href = href.replace(/[\x00-\x20]+/g, "");
      while (true) {
        const firstIndex = href.indexOf("<!--");
        if (firstIndex === -1) {
          break;
        }
        const lastIndex = href.indexOf("-->", firstIndex + 4);
        if (lastIndex === -1) {
          break;
        }
        href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);
      }
      const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
      if (!matches) {
        if (href.match(/^[/\\]{2}/)) {
          return !options.allowProtocolRelative;
        }
        return false;
      }
      const scheme = matches[1].toLowerCase();
      if (has(options.allowedSchemesByTag, name)) {
        return options.allowedSchemesByTag[name].indexOf(scheme) === -1;
      }
      return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;
    }
    function parseUrl(value) {
      value = value.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, "$1//");
      if (value.startsWith("relative:")) {
        throw new Error("relative: exploit attempt");
      }
      let base = "relative://relative-site";
      for (let i = 0;i < 100; i++) {
        base += `/${i}`;
      }
      const parsed = new URL(value, base);
      const isRelativeUrl = parsed && parsed.hostname === "relative-site" && parsed.protocol === "relative:";
      return {
        isRelativeUrl,
        url: parsed
      };
    }
    function filterCss(abstractSyntaxTree, allowedStyles) {
      if (!allowedStyles) {
        return abstractSyntaxTree;
      }
      const astRules = abstractSyntaxTree.nodes[0];
      let selectedRule;
      if (allowedStyles[astRules.selector] && allowedStyles["*"]) {
        selectedRule = deepmerge(allowedStyles[astRules.selector], allowedStyles["*"]);
      } else {
        selectedRule = allowedStyles[astRules.selector] || allowedStyles["*"];
      }
      if (selectedRule) {
        abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);
      }
      return abstractSyntaxTree;
    }
    function stringifyStyleAttributes(filteredAST) {
      return filteredAST.nodes[0].nodes.reduce(function(extractedAttributes, attrObject) {
        extractedAttributes.push(`${attrObject.prop}:${attrObject.value}${attrObject.important ? " !important" : ""}`);
        return extractedAttributes;
      }, []).join(";");
    }
    function filterDeclarations(selectedRule) {
      return function(allowedDeclarationsList, attributeObject) {
        if (has(selectedRule, attributeObject.prop)) {
          const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {
            return regularExpression.test(attributeObject.value);
          });
          if (matchesRegex) {
            allowedDeclarationsList.push(attributeObject);
          }
        }
        return allowedDeclarationsList;
      };
    }
    function filterClasses(classes, allowed, allowedGlobs) {
      if (!allowed) {
        return classes;
      }
      classes = classes.split(/\s+/);
      return classes.filter(function(clss) {
        return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {
          return glob.test(clss);
        });
      }).join(" ");
    }
  };
  var htmlparser = require_lib6();
  var escapeStringRegexp = require_escape_string_regexp();
  var { isPlainObject } = require_is_plain_object();
  var deepmerge = require_cjs();
  var parseSrcset = require_parse_srcset();
  var { parse: postcssParse } = require_postcss();
  var mediaTags = [
    "img",
    "audio",
    "video",
    "picture",
    "svg",
    "object",
    "map",
    "iframe",
    "embed"
  ];
  var vulnerableTags = ["script", "style"];
  module.exports = sanitizeHtml;
  var VALID_HTML_ATTRIBUTE_NAME = /^[^\0\t\n\f\r /<=>]+$/;
  var htmlParserDefaults = {
    decodeEntities: true
  };
  sanitizeHtml.defaults = {
    allowedTags: [
      "address",
      "article",
      "aside",
      "footer",
      "header",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "hgroup",
      "main",
      "nav",
      "section",
      "blockquote",
      "dd",
      "div",
      "dl",
      "dt",
      "figcaption",
      "figure",
      "hr",
      "li",
      "main",
      "ol",
      "p",
      "pre",
      "ul",
      "a",
      "abbr",
      "b",
      "bdi",
      "bdo",
      "br",
      "cite",
      "code",
      "data",
      "dfn",
      "em",
      "i",
      "kbd",
      "mark",
      "q",
      "rb",
      "rp",
      "rt",
      "rtc",
      "ruby",
      "s",
      "samp",
      "small",
      "span",
      "strong",
      "sub",
      "sup",
      "time",
      "u",
      "var",
      "wbr",
      "caption",
      "col",
      "colgroup",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "tr"
    ],
    nonBooleanAttributes: [
      "abbr",
      "accept",
      "accept-charset",
      "accesskey",
      "action",
      "allow",
      "alt",
      "as",
      "autocapitalize",
      "autocomplete",
      "blocking",
      "charset",
      "cite",
      "class",
      "color",
      "cols",
      "colspan",
      "content",
      "contenteditable",
      "coords",
      "crossorigin",
      "data",
      "datetime",
      "decoding",
      "dir",
      "dirname",
      "download",
      "draggable",
      "enctype",
      "enterkeyhint",
      "fetchpriority",
      "for",
      "form",
      "formaction",
      "formenctype",
      "formmethod",
      "formtarget",
      "headers",
      "height",
      "hidden",
      "high",
      "href",
      "hreflang",
      "http-equiv",
      "id",
      "imagesizes",
      "imagesrcset",
      "inputmode",
      "integrity",
      "is",
      "itemid",
      "itemprop",
      "itemref",
      "itemtype",
      "kind",
      "label",
      "lang",
      "list",
      "loading",
      "low",
      "max",
      "maxlength",
      "media",
      "method",
      "min",
      "minlength",
      "name",
      "nonce",
      "optimum",
      "pattern",
      "ping",
      "placeholder",
      "popover",
      "popovertarget",
      "popovertargetaction",
      "poster",
      "preload",
      "referrerpolicy",
      "rel",
      "rows",
      "rowspan",
      "sandbox",
      "scope",
      "shape",
      "size",
      "sizes",
      "slot",
      "span",
      "spellcheck",
      "src",
      "srcdoc",
      "srclang",
      "srcset",
      "start",
      "step",
      "style",
      "tabindex",
      "target",
      "title",
      "translate",
      "type",
      "usemap",
      "value",
      "width",
      "wrap",
      "onauxclick",
      "onafterprint",
      "onbeforematch",
      "onbeforeprint",
      "onbeforeunload",
      "onbeforetoggle",
      "onblur",
      "oncancel",
      "oncanplay",
      "oncanplaythrough",
      "onchange",
      "onclick",
      "onclose",
      "oncontextlost",
      "oncontextmenu",
      "oncontextrestored",
      "oncopy",
      "oncuechange",
      "oncut",
      "ondblclick",
      "ondrag",
      "ondragend",
      "ondragenter",
      "ondragleave",
      "ondragover",
      "ondragstart",
      "ondrop",
      "ondurationchange",
      "onemptied",
      "onended",
      "onerror",
      "onfocus",
      "onformdata",
      "onhashchange",
      "oninput",
      "oninvalid",
      "onkeydown",
      "onkeypress",
      "onkeyup",
      "onlanguagechange",
      "onload",
      "onloadeddata",
      "onloadedmetadata",
      "onloadstart",
      "onmessage",
      "onmessageerror",
      "onmousedown",
      "onmouseenter",
      "onmouseleave",
      "onmousemove",
      "onmouseout",
      "onmouseover",
      "onmouseup",
      "onoffline",
      "ononline",
      "onpagehide",
      "onpageshow",
      "onpaste",
      "onpause",
      "onplay",
      "onplaying",
      "onpopstate",
      "onprogress",
      "onratechange",
      "onreset",
      "onresize",
      "onrejectionhandled",
      "onscroll",
      "onscrollend",
      "onsecuritypolicyviolation",
      "onseeked",
      "onseeking",
      "onselect",
      "onslotchange",
      "onstalled",
      "onstorage",
      "onsubmit",
      "onsuspend",
      "ontimeupdate",
      "ontoggle",
      "onunhandledrejection",
      "onunload",
      "onvolumechange",
      "onwaiting",
      "onwheel"
    ],
    disallowedTagsMode: "discard",
    allowedAttributes: {
      a: ["href", "name", "target"],
      img: ["src", "srcset", "alt", "title", "width", "height", "loading"]
    },
    selfClosing: ["img", "br", "hr", "area", "base", "basefont", "input", "link", "meta"],
    allowedSchemes: ["http", "https", "ftp", "mailto", "tel"],
    allowedSchemesByTag: {},
    allowedSchemesAppliedToAttributes: ["href", "src", "cite"],
    allowProtocolRelative: true,
    enforceHtmlBoundary: false,
    parseStyleAttributes: true
  };
  sanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge) {
    merge = merge === undefined ? true : merge;
    newAttribs = newAttribs || {};
    return function(tagName, attribs) {
      let attrib;
      if (merge) {
        for (attrib in newAttribs) {
          attribs[attrib] = newAttribs[attrib];
        }
      } else {
        attribs = newAttribs;
      }
      return {
        tagName: newTagName,
        attribs
      };
    };
  };
});

// node_modules/typed-html/dist/src/elements.js
var require_elements = __commonJS((exports) => {
  var createElement = function(name, attributes = {}, ...contents) {
    const children = attributes && attributes.children || contents;
    if (typeof name === "function") {
      return name(children ? { children, ...attributes } : attributes, contents);
    } else {
      const tagName = toKebabCase(name);
      if (isVoidElement(tagName) && !contents.length) {
        return `<${tagName}${attributesToString(attributes)}>`;
      } else {
        return `<${tagName}${attributesToString(attributes)}>${contentsToString(contents)}</${tagName}>`;
      }
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createElement = undefined;
  var capitalACharCode = "A".charCodeAt(0);
  var capitalZCharCode = "Z".charCodeAt(0);
  var isUpper = (input, index) => {
    const charCode = input.charCodeAt(index);
    return capitalACharCode <= charCode && capitalZCharCode >= charCode;
  };
  var toKebabCase = (camelCased) => {
    let kebabCased = "";
    for (let i = 0;i < camelCased.length; i++) {
      const prevUpperCased = i > 0 ? isUpper(camelCased, i - 1) : true;
      const currentUpperCased = isUpper(camelCased, i);
      const nextUpperCased = i < camelCased.length - 1 ? isUpper(camelCased, i + 1) : true;
      if (!prevUpperCased && currentUpperCased || currentUpperCased && !nextUpperCased) {
        kebabCased += "-";
        kebabCased += camelCased[i].toLowerCase();
      } else {
        kebabCased += camelCased[i];
      }
    }
    return kebabCased;
  };
  var escapeAttrNodeValue = (value) => {
    return value.replace(/(&)|(")|(\u00A0)/g, function(_, amp, quote) {
      if (amp)
        return "&amp;";
      if (quote)
        return "&quot;";
      return "&nbsp;";
    });
  };
  var attributeToString = (attributes) => (name) => {
    const value = attributes[name];
    const formattedName = toKebabCase(name);
    const makeAttribute = (value2) => `${formattedName}="${value2}"`;
    if (value instanceof Date) {
      return makeAttribute(value.toISOString());
    } else
      switch (typeof value) {
        case "boolean":
          if (value) {
            return formattedName;
          } else {
            return "";
          }
        default:
          return makeAttribute(escapeAttrNodeValue(value.toString()));
      }
  };
  var attributesToString = (attributes) => {
    if (attributes) {
      return " " + Object.keys(attributes).filter((attribute) => attribute !== "children").map(attributeToString(attributes)).filter((attribute) => attribute.length).join(" ");
    } else {
      return "";
    }
  };
  var contentsToString = (contents) => {
    if (contents) {
      return contents.map((elements) => Array.isArray(elements) ? elements.join("\n") : elements).join("\n");
    } else {
      return "";
    }
  };
  var isVoidElement = (tagName) => {
    return [
      "area",
      "base",
      "br",
      "col",
      "command",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ].indexOf(tagName) > -1;
  };
  exports.createElement = createElement;
});

// node_modules/cssfilter/lib/default.js
var require_default = __commonJS((exports) => {
  var getDefaultWhiteList = function() {
    var whiteList = {};
    whiteList["align-content"] = false;
    whiteList["align-items"] = false;
    whiteList["align-self"] = false;
    whiteList["alignment-adjust"] = false;
    whiteList["alignment-baseline"] = false;
    whiteList["all"] = false;
    whiteList["anchor-point"] = false;
    whiteList["animation"] = false;
    whiteList["animation-delay"] = false;
    whiteList["animation-direction"] = false;
    whiteList["animation-duration"] = false;
    whiteList["animation-fill-mode"] = false;
    whiteList["animation-iteration-count"] = false;
    whiteList["animation-name"] = false;
    whiteList["animation-play-state"] = false;
    whiteList["animation-timing-function"] = false;
    whiteList["azimuth"] = false;
    whiteList["backface-visibility"] = false;
    whiteList["background"] = true;
    whiteList["background-attachment"] = true;
    whiteList["background-clip"] = true;
    whiteList["background-color"] = true;
    whiteList["background-image"] = true;
    whiteList["background-origin"] = true;
    whiteList["background-position"] = true;
    whiteList["background-repeat"] = true;
    whiteList["background-size"] = true;
    whiteList["baseline-shift"] = false;
    whiteList["binding"] = false;
    whiteList["bleed"] = false;
    whiteList["bookmark-label"] = false;
    whiteList["bookmark-level"] = false;
    whiteList["bookmark-state"] = false;
    whiteList["border"] = true;
    whiteList["border-bottom"] = true;
    whiteList["border-bottom-color"] = true;
    whiteList["border-bottom-left-radius"] = true;
    whiteList["border-bottom-right-radius"] = true;
    whiteList["border-bottom-style"] = true;
    whiteList["border-bottom-width"] = true;
    whiteList["border-collapse"] = true;
    whiteList["border-color"] = true;
    whiteList["border-image"] = true;
    whiteList["border-image-outset"] = true;
    whiteList["border-image-repeat"] = true;
    whiteList["border-image-slice"] = true;
    whiteList["border-image-source"] = true;
    whiteList["border-image-width"] = true;
    whiteList["border-left"] = true;
    whiteList["border-left-color"] = true;
    whiteList["border-left-style"] = true;
    whiteList["border-left-width"] = true;
    whiteList["border-radius"] = true;
    whiteList["border-right"] = true;
    whiteList["border-right-color"] = true;
    whiteList["border-right-style"] = true;
    whiteList["border-right-width"] = true;
    whiteList["border-spacing"] = true;
    whiteList["border-style"] = true;
    whiteList["border-top"] = true;
    whiteList["border-top-color"] = true;
    whiteList["border-top-left-radius"] = true;
    whiteList["border-top-right-radius"] = true;
    whiteList["border-top-style"] = true;
    whiteList["border-top-width"] = true;
    whiteList["border-width"] = true;
    whiteList["bottom"] = false;
    whiteList["box-decoration-break"] = true;
    whiteList["box-shadow"] = true;
    whiteList["box-sizing"] = true;
    whiteList["box-snap"] = true;
    whiteList["box-suppress"] = true;
    whiteList["break-after"] = true;
    whiteList["break-before"] = true;
    whiteList["break-inside"] = true;
    whiteList["caption-side"] = false;
    whiteList["chains"] = false;
    whiteList["clear"] = true;
    whiteList["clip"] = false;
    whiteList["clip-path"] = false;
    whiteList["clip-rule"] = false;
    whiteList["color"] = true;
    whiteList["color-interpolation-filters"] = true;
    whiteList["column-count"] = false;
    whiteList["column-fill"] = false;
    whiteList["column-gap"] = false;
    whiteList["column-rule"] = false;
    whiteList["column-rule-color"] = false;
    whiteList["column-rule-style"] = false;
    whiteList["column-rule-width"] = false;
    whiteList["column-span"] = false;
    whiteList["column-width"] = false;
    whiteList["columns"] = false;
    whiteList["contain"] = false;
    whiteList["content"] = false;
    whiteList["counter-increment"] = false;
    whiteList["counter-reset"] = false;
    whiteList["counter-set"] = false;
    whiteList["crop"] = false;
    whiteList["cue"] = false;
    whiteList["cue-after"] = false;
    whiteList["cue-before"] = false;
    whiteList["cursor"] = false;
    whiteList["direction"] = false;
    whiteList["display"] = true;
    whiteList["display-inside"] = true;
    whiteList["display-list"] = true;
    whiteList["display-outside"] = true;
    whiteList["dominant-baseline"] = false;
    whiteList["elevation"] = false;
    whiteList["empty-cells"] = false;
    whiteList["filter"] = false;
    whiteList["flex"] = false;
    whiteList["flex-basis"] = false;
    whiteList["flex-direction"] = false;
    whiteList["flex-flow"] = false;
    whiteList["flex-grow"] = false;
    whiteList["flex-shrink"] = false;
    whiteList["flex-wrap"] = false;
    whiteList["float"] = false;
    whiteList["float-offset"] = false;
    whiteList["flood-color"] = false;
    whiteList["flood-opacity"] = false;
    whiteList["flow-from"] = false;
    whiteList["flow-into"] = false;
    whiteList["font"] = true;
    whiteList["font-family"] = true;
    whiteList["font-feature-settings"] = true;
    whiteList["font-kerning"] = true;
    whiteList["font-language-override"] = true;
    whiteList["font-size"] = true;
    whiteList["font-size-adjust"] = true;
    whiteList["font-stretch"] = true;
    whiteList["font-style"] = true;
    whiteList["font-synthesis"] = true;
    whiteList["font-variant"] = true;
    whiteList["font-variant-alternates"] = true;
    whiteList["font-variant-caps"] = true;
    whiteList["font-variant-east-asian"] = true;
    whiteList["font-variant-ligatures"] = true;
    whiteList["font-variant-numeric"] = true;
    whiteList["font-variant-position"] = true;
    whiteList["font-weight"] = true;
    whiteList["grid"] = false;
    whiteList["grid-area"] = false;
    whiteList["grid-auto-columns"] = false;
    whiteList["grid-auto-flow"] = false;
    whiteList["grid-auto-rows"] = false;
    whiteList["grid-column"] = false;
    whiteList["grid-column-end"] = false;
    whiteList["grid-column-start"] = false;
    whiteList["grid-row"] = false;
    whiteList["grid-row-end"] = false;
    whiteList["grid-row-start"] = false;
    whiteList["grid-template"] = false;
    whiteList["grid-template-areas"] = false;
    whiteList["grid-template-columns"] = false;
    whiteList["grid-template-rows"] = false;
    whiteList["hanging-punctuation"] = false;
    whiteList["height"] = true;
    whiteList["hyphens"] = false;
    whiteList["icon"] = false;
    whiteList["image-orientation"] = false;
    whiteList["image-resolution"] = false;
    whiteList["ime-mode"] = false;
    whiteList["initial-letters"] = false;
    whiteList["inline-box-align"] = false;
    whiteList["justify-content"] = false;
    whiteList["justify-items"] = false;
    whiteList["justify-self"] = false;
    whiteList["left"] = false;
    whiteList["letter-spacing"] = true;
    whiteList["lighting-color"] = true;
    whiteList["line-box-contain"] = false;
    whiteList["line-break"] = false;
    whiteList["line-grid"] = false;
    whiteList["line-height"] = false;
    whiteList["line-snap"] = false;
    whiteList["line-stacking"] = false;
    whiteList["line-stacking-ruby"] = false;
    whiteList["line-stacking-shift"] = false;
    whiteList["line-stacking-strategy"] = false;
    whiteList["list-style"] = true;
    whiteList["list-style-image"] = true;
    whiteList["list-style-position"] = true;
    whiteList["list-style-type"] = true;
    whiteList["margin"] = true;
    whiteList["margin-bottom"] = true;
    whiteList["margin-left"] = true;
    whiteList["margin-right"] = true;
    whiteList["margin-top"] = true;
    whiteList["marker-offset"] = false;
    whiteList["marker-side"] = false;
    whiteList["marks"] = false;
    whiteList["mask"] = false;
    whiteList["mask-box"] = false;
    whiteList["mask-box-outset"] = false;
    whiteList["mask-box-repeat"] = false;
    whiteList["mask-box-slice"] = false;
    whiteList["mask-box-source"] = false;
    whiteList["mask-box-width"] = false;
    whiteList["mask-clip"] = false;
    whiteList["mask-image"] = false;
    whiteList["mask-origin"] = false;
    whiteList["mask-position"] = false;
    whiteList["mask-repeat"] = false;
    whiteList["mask-size"] = false;
    whiteList["mask-source-type"] = false;
    whiteList["mask-type"] = false;
    whiteList["max-height"] = true;
    whiteList["max-lines"] = false;
    whiteList["max-width"] = true;
    whiteList["min-height"] = true;
    whiteList["min-width"] = true;
    whiteList["move-to"] = false;
    whiteList["nav-down"] = false;
    whiteList["nav-index"] = false;
    whiteList["nav-left"] = false;
    whiteList["nav-right"] = false;
    whiteList["nav-up"] = false;
    whiteList["object-fit"] = false;
    whiteList["object-position"] = false;
    whiteList["opacity"] = false;
    whiteList["order"] = false;
    whiteList["orphans"] = false;
    whiteList["outline"] = false;
    whiteList["outline-color"] = false;
    whiteList["outline-offset"] = false;
    whiteList["outline-style"] = false;
    whiteList["outline-width"] = false;
    whiteList["overflow"] = false;
    whiteList["overflow-wrap"] = false;
    whiteList["overflow-x"] = false;
    whiteList["overflow-y"] = false;
    whiteList["padding"] = true;
    whiteList["padding-bottom"] = true;
    whiteList["padding-left"] = true;
    whiteList["padding-right"] = true;
    whiteList["padding-top"] = true;
    whiteList["page"] = false;
    whiteList["page-break-after"] = false;
    whiteList["page-break-before"] = false;
    whiteList["page-break-inside"] = false;
    whiteList["page-policy"] = false;
    whiteList["pause"] = false;
    whiteList["pause-after"] = false;
    whiteList["pause-before"] = false;
    whiteList["perspective"] = false;
    whiteList["perspective-origin"] = false;
    whiteList["pitch"] = false;
    whiteList["pitch-range"] = false;
    whiteList["play-during"] = false;
    whiteList["position"] = false;
    whiteList["presentation-level"] = false;
    whiteList["quotes"] = false;
    whiteList["region-fragment"] = false;
    whiteList["resize"] = false;
    whiteList["rest"] = false;
    whiteList["rest-after"] = false;
    whiteList["rest-before"] = false;
    whiteList["richness"] = false;
    whiteList["right"] = false;
    whiteList["rotation"] = false;
    whiteList["rotation-point"] = false;
    whiteList["ruby-align"] = false;
    whiteList["ruby-merge"] = false;
    whiteList["ruby-position"] = false;
    whiteList["shape-image-threshold"] = false;
    whiteList["shape-outside"] = false;
    whiteList["shape-margin"] = false;
    whiteList["size"] = false;
    whiteList["speak"] = false;
    whiteList["speak-as"] = false;
    whiteList["speak-header"] = false;
    whiteList["speak-numeral"] = false;
    whiteList["speak-punctuation"] = false;
    whiteList["speech-rate"] = false;
    whiteList["stress"] = false;
    whiteList["string-set"] = false;
    whiteList["tab-size"] = false;
    whiteList["table-layout"] = false;
    whiteList["text-align"] = true;
    whiteList["text-align-last"] = true;
    whiteList["text-combine-upright"] = true;
    whiteList["text-decoration"] = true;
    whiteList["text-decoration-color"] = true;
    whiteList["text-decoration-line"] = true;
    whiteList["text-decoration-skip"] = true;
    whiteList["text-decoration-style"] = true;
    whiteList["text-emphasis"] = true;
    whiteList["text-emphasis-color"] = true;
    whiteList["text-emphasis-position"] = true;
    whiteList["text-emphasis-style"] = true;
    whiteList["text-height"] = true;
    whiteList["text-indent"] = true;
    whiteList["text-justify"] = true;
    whiteList["text-orientation"] = true;
    whiteList["text-overflow"] = true;
    whiteList["text-shadow"] = true;
    whiteList["text-space-collapse"] = true;
    whiteList["text-transform"] = true;
    whiteList["text-underline-position"] = true;
    whiteList["text-wrap"] = true;
    whiteList["top"] = false;
    whiteList["transform"] = false;
    whiteList["transform-origin"] = false;
    whiteList["transform-style"] = false;
    whiteList["transition"] = false;
    whiteList["transition-delay"] = false;
    whiteList["transition-duration"] = false;
    whiteList["transition-property"] = false;
    whiteList["transition-timing-function"] = false;
    whiteList["unicode-bidi"] = false;
    whiteList["vertical-align"] = false;
    whiteList["visibility"] = false;
    whiteList["voice-balance"] = false;
    whiteList["voice-duration"] = false;
    whiteList["voice-family"] = false;
    whiteList["voice-pitch"] = false;
    whiteList["voice-range"] = false;
    whiteList["voice-rate"] = false;
    whiteList["voice-stress"] = false;
    whiteList["voice-volume"] = false;
    whiteList["volume"] = false;
    whiteList["white-space"] = false;
    whiteList["widows"] = false;
    whiteList["width"] = true;
    whiteList["will-change"] = false;
    whiteList["word-break"] = true;
    whiteList["word-spacing"] = true;
    whiteList["word-wrap"] = true;
    whiteList["wrap-flow"] = false;
    whiteList["wrap-through"] = false;
    whiteList["writing-mode"] = false;
    whiteList["z-index"] = false;
    return whiteList;
  };
  var onAttr = function(name, value, options) {
  };
  var onIgnoreAttr = function(name, value, options) {
  };
  var safeAttrValue = function(name, value) {
    if (REGEXP_URL_JAVASCRIPT.test(value))
      return "";
    return value;
  };
  var REGEXP_URL_JAVASCRIPT = /javascript\s*\:/img;
  exports.whiteList = getDefaultWhiteList();
  exports.getDefaultWhiteList = getDefaultWhiteList;
  exports.onAttr = onAttr;
  exports.onIgnoreAttr = onIgnoreAttr;
  exports.safeAttrValue = safeAttrValue;
});

// node_modules/cssfilter/lib/util.js
var require_util2 = __commonJS((exports, module) => {
  module.exports = {
    indexOf: function(arr, item) {
      var i, j;
      if (Array.prototype.indexOf) {
        return arr.indexOf(item);
      }
      for (i = 0, j = arr.length;i < j; i++) {
        if (arr[i] === item) {
          return i;
        }
      }
      return -1;
    },
    forEach: function(arr, fn, scope) {
      var i, j;
      if (Array.prototype.forEach) {
        return arr.forEach(fn, scope);
      }
      for (i = 0, j = arr.length;i < j; i++) {
        fn.call(scope, arr[i], i, arr);
      }
    },
    trim: function(str) {
      if (String.prototype.trim) {
        return str.trim();
      }
      return str.replace(/(^\s*)|(\s*$)/g, "");
    },
    trimRight: function(str) {
      if (String.prototype.trimRight) {
        return str.trimRight();
      }
      return str.replace(/(\s*$)/g, "");
    }
  };
});

// node_modules/cssfilter/lib/parser.js
var require_parser2 = __commonJS((exports, module) => {
  var parseStyle = function(css, onAttr) {
    css = _.trimRight(css);
    if (css[css.length - 1] !== ";")
      css += ";";
    var cssLength = css.length;
    var isParenthesisOpen = false;
    var lastPos = 0;
    var i = 0;
    var retCSS = "";
    function addNewAttr() {
      if (!isParenthesisOpen) {
        var source = _.trim(css.slice(lastPos, i));
        var j2 = source.indexOf(":");
        if (j2 !== -1) {
          var name = _.trim(source.slice(0, j2));
          var value = _.trim(source.slice(j2 + 1));
          if (name) {
            var ret = onAttr(lastPos, retCSS.length, name, value, source);
            if (ret)
              retCSS += ret + "; ";
          }
        }
      }
      lastPos = i + 1;
    }
    for (;i < cssLength; i++) {
      var c = css[i];
      if (c === "/" && css[i + 1] === "*") {
        var j = css.indexOf("*/", i + 2);
        if (j === -1)
          break;
        i = j + 1;
        lastPos = i + 1;
        isParenthesisOpen = false;
      } else if (c === "(") {
        isParenthesisOpen = true;
      } else if (c === ")") {
        isParenthesisOpen = false;
      } else if (c === ";") {
        if (isParenthesisOpen) {
        } else {
          addNewAttr();
        }
      } else if (c === "\n") {
        addNewAttr();
      }
    }
    return _.trim(retCSS);
  };
  var _ = require_util2();
  module.exports = parseStyle;
});

// node_modules/cssfilter/lib/css.js
var require_css = __commonJS((exports, module) => {
  var isNull = function(obj) {
    return obj === undefined || obj === null;
  };
  var shallowCopyObject = function(obj) {
    var ret = {};
    for (var i in obj) {
      ret[i] = obj[i];
    }
    return ret;
  };
  var FilterCSS = function(options) {
    options = shallowCopyObject(options || {});
    options.whiteList = options.whiteList || DEFAULT.whiteList;
    options.onAttr = options.onAttr || DEFAULT.onAttr;
    options.onIgnoreAttr = options.onIgnoreAttr || DEFAULT.onIgnoreAttr;
    options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
    this.options = options;
  };
  var DEFAULT = require_default();
  var parseStyle = require_parser2();
  var _ = require_util2();
  FilterCSS.prototype.process = function(css) {
    css = css || "";
    css = css.toString();
    if (!css)
      return "";
    var me = this;
    var options = me.options;
    var whiteList = options.whiteList;
    var onAttr = options.onAttr;
    var onIgnoreAttr = options.onIgnoreAttr;
    var safeAttrValue = options.safeAttrValue;
    var retCSS = parseStyle(css, function(sourcePosition, position, name, value, source) {
      var check = whiteList[name];
      var isWhite = false;
      if (check === true)
        isWhite = check;
      else if (typeof check === "function")
        isWhite = check(value);
      else if (check instanceof RegExp)
        isWhite = check.test(value);
      if (isWhite !== true)
        isWhite = false;
      value = safeAttrValue(name, value);
      if (!value)
        return;
      var opts = {
        position,
        sourcePosition,
        source,
        isWhite
      };
      if (isWhite) {
        var ret = onAttr(name, value, opts);
        if (isNull(ret)) {
          return name + ":" + value;
        } else {
          return ret;
        }
      } else {
        var ret = onIgnoreAttr(name, value, opts);
        if (!isNull(ret)) {
          return ret;
        }
      }
    });
    return retCSS;
  };
  module.exports = FilterCSS;
});

// node_modules/cssfilter/lib/index.js
var require_lib7 = __commonJS((exports, module) => {
  var filterCSS = function(html2, options) {
    var xss = new FilterCSS(options);
    return xss.process(html2);
  };
  var DEFAULT = require_default();
  var FilterCSS = require_css();
  exports = module.exports = filterCSS;
  exports.FilterCSS = FilterCSS;
  for (i in DEFAULT)
    exports[i] = DEFAULT[i];
  var i;
  if (typeof window !== "undefined") {
    window.filterCSS = module.exports;
  }
});

// node_modules/xss/lib/util.js
var require_util3 = __commonJS((exports, module) => {
  module.exports = {
    indexOf: function(arr, item) {
      var i, j;
      if (Array.prototype.indexOf) {
        return arr.indexOf(item);
      }
      for (i = 0, j = arr.length;i < j; i++) {
        if (arr[i] === item) {
          return i;
        }
      }
      return -1;
    },
    forEach: function(arr, fn, scope) {
      var i, j;
      if (Array.prototype.forEach) {
        return arr.forEach(fn, scope);
      }
      for (i = 0, j = arr.length;i < j; i++) {
        fn.call(scope, arr[i], i, arr);
      }
    },
    trim: function(str) {
      if (String.prototype.trim) {
        return str.trim();
      }
      return str.replace(/(^\s*)|(\s*$)/g, "");
    },
    spaceIndex: function(str) {
      var reg = /\s|\n|\t/;
      var match = reg.exec(str);
      return match ? match.index : -1;
    }
  };
});

// node_modules/xss/lib/default.js
var require_default2 = __commonJS((exports) => {
  var getDefaultWhiteList = function() {
    return {
      a: ["target", "href", "title"],
      abbr: ["title"],
      address: [],
      area: ["shape", "coords", "href", "alt"],
      article: [],
      aside: [],
      audio: [
        "autoplay",
        "controls",
        "crossorigin",
        "loop",
        "muted",
        "preload",
        "src"
      ],
      b: [],
      bdi: ["dir"],
      bdo: ["dir"],
      big: [],
      blockquote: ["cite"],
      br: [],
      caption: [],
      center: [],
      cite: [],
      code: [],
      col: ["align", "valign", "span", "width"],
      colgroup: ["align", "valign", "span", "width"],
      dd: [],
      del: ["datetime"],
      details: ["open"],
      div: [],
      dl: [],
      dt: [],
      em: [],
      figcaption: [],
      figure: [],
      font: ["color", "size", "face"],
      footer: [],
      h1: [],
      h2: [],
      h3: [],
      h4: [],
      h5: [],
      h6: [],
      header: [],
      hr: [],
      i: [],
      img: ["src", "alt", "title", "width", "height"],
      ins: ["datetime"],
      li: [],
      mark: [],
      nav: [],
      ol: [],
      p: [],
      pre: [],
      s: [],
      section: [],
      small: [],
      span: [],
      sub: [],
      summary: [],
      sup: [],
      strong: [],
      strike: [],
      table: ["width", "border", "align", "valign"],
      tbody: ["align", "valign"],
      td: ["width", "rowspan", "colspan", "align", "valign"],
      tfoot: ["align", "valign"],
      th: ["width", "rowspan", "colspan", "align", "valign"],
      thead: ["align", "valign"],
      tr: ["rowspan", "align", "valign"],
      tt: [],
      u: [],
      ul: [],
      video: [
        "autoplay",
        "controls",
        "crossorigin",
        "loop",
        "muted",
        "playsinline",
        "poster",
        "preload",
        "src",
        "height",
        "width"
      ]
    };
  };
  var onTag = function(tag, html2, options) {
  };
  var onIgnoreTag = function(tag, html2, options) {
  };
  var onTagAttr = function(tag, name, value) {
  };
  var onIgnoreTagAttr = function(tag, name, value) {
  };
  var escapeHtml = function(html2) {
    return html2.replace(REGEXP_LT, "&lt;").replace(REGEXP_GT, "&gt;");
  };
  var safeAttrValue = function(tag, name, value, cssFilter) {
    value = friendlyAttrValue(value);
    if (name === "href" || name === "src") {
      value = _.trim(value);
      if (value === "#")
        return "#";
      if (!(value.substr(0, 7) === "http://" || value.substr(0, 8) === "https://" || value.substr(0, 7) === "mailto:" || value.substr(0, 4) === "tel:" || value.substr(0, 11) === "data:image/" || value.substr(0, 6) === "ftp://" || value.substr(0, 2) === "./" || value.substr(0, 3) === "../" || value[0] === "#" || value[0] === "/")) {
        return "";
      }
    } else if (name === "background") {
      REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
      if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
        return "";
      }
    } else if (name === "style") {
      REGEXP_DEFAULT_ON_TAG_ATTR_7.lastIndex = 0;
      if (REGEXP_DEFAULT_ON_TAG_ATTR_7.test(value)) {
        return "";
      }
      REGEXP_DEFAULT_ON_TAG_ATTR_8.lastIndex = 0;
      if (REGEXP_DEFAULT_ON_TAG_ATTR_8.test(value)) {
        REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
        if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
          return "";
        }
      }
      if (cssFilter !== false) {
        cssFilter = cssFilter || defaultCSSFilter;
        value = cssFilter.process(value);
      }
    }
    value = escapeAttrValue(value);
    return value;
  };
  var escapeQuote = function(str) {
    return str.replace(REGEXP_QUOTE, "&quot;");
  };
  var unescapeQuote = function(str) {
    return str.replace(REGEXP_QUOTE_2, '"');
  };
  var escapeHtmlEntities = function(str) {
    return str.replace(REGEXP_ATTR_VALUE_1, function replaceUnicode(str2, code) {
      return code[0] === "x" || code[0] === "X" ? String.fromCharCode(parseInt(code.substr(1), 16)) : String.fromCharCode(parseInt(code, 10));
    });
  };
  var escapeDangerHtml5Entities = function(str) {
    return str.replace(REGEXP_ATTR_VALUE_COLON, ":").replace(REGEXP_ATTR_VALUE_NEWLINE, " ");
  };
  var clearNonPrintableCharacter = function(str) {
    var str2 = "";
    for (var i = 0, len = str.length;i < len; i++) {
      str2 += str.charCodeAt(i) < 32 ? " " : str.charAt(i);
    }
    return _.trim(str2);
  };
  var friendlyAttrValue = function(str) {
    str = unescapeQuote(str);
    str = escapeHtmlEntities(str);
    str = escapeDangerHtml5Entities(str);
    str = clearNonPrintableCharacter(str);
    return str;
  };
  var escapeAttrValue = function(str) {
    str = escapeQuote(str);
    str = escapeHtml(str);
    return str;
  };
  var onIgnoreTagStripAll = function() {
    return "";
  };
  var StripTagBody = function(tags, next) {
    if (typeof next !== "function") {
      next = function() {
      };
    }
    var isRemoveAllTag = !Array.isArray(tags);
    function isRemoveTag(tag) {
      if (isRemoveAllTag)
        return true;
      return _.indexOf(tags, tag) !== -1;
    }
    var removeList = [];
    var posStart = false;
    return {
      onIgnoreTag: function(tag, html2, options) {
        if (isRemoveTag(tag)) {
          if (options.isClosing) {
            var ret = "[/removed]";
            var end = options.position + ret.length;
            removeList.push([
              posStart !== false ? posStart : options.position,
              end
            ]);
            posStart = false;
            return ret;
          } else {
            if (!posStart) {
              posStart = options.position;
            }
            return "[removed]";
          }
        } else {
          return next(tag, html2, options);
        }
      },
      remove: function(html2) {
        var rethtml = "";
        var lastPos = 0;
        _.forEach(removeList, function(pos) {
          rethtml += html2.slice(lastPos, pos[0]);
          lastPos = pos[1];
        });
        rethtml += html2.slice(lastPos);
        return rethtml;
      }
    };
  };
  var stripCommentTag = function(html2) {
    var retHtml = "";
    var lastPos = 0;
    while (lastPos < html2.length) {
      var i = html2.indexOf("<!--", lastPos);
      if (i === -1) {
        retHtml += html2.slice(lastPos);
        break;
      }
      retHtml += html2.slice(lastPos, i);
      var j = html2.indexOf("-->", i);
      if (j === -1) {
        break;
      }
      lastPos = j + 3;
    }
    return retHtml;
  };
  var stripBlankChar = function(html2) {
    var chars = html2.split("");
    chars = chars.filter(function(char) {
      var c = char.charCodeAt(0);
      if (c === 127)
        return false;
      if (c <= 31) {
        if (c === 10 || c === 13)
          return true;
        return false;
      }
      return true;
    });
    return chars.join("");
  };
  var FilterCSS = require_lib7().FilterCSS;
  var getDefaultCSSWhiteList = require_lib7().getDefaultWhiteList;
  var _ = require_util3();
  var defaultCSSFilter = new FilterCSS;
  var REGEXP_LT = /</g;
  var REGEXP_GT = />/g;
  var REGEXP_QUOTE = /"/g;
  var REGEXP_QUOTE_2 = /&quot;/g;
  var REGEXP_ATTR_VALUE_1 = /&#([a-zA-Z0-9]*);?/gim;
  var REGEXP_ATTR_VALUE_COLON = /&colon;?/gim;
  var REGEXP_ATTR_VALUE_NEWLINE = /&newline;?/gim;
  var REGEXP_DEFAULT_ON_TAG_ATTR_4 = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi;
  var REGEXP_DEFAULT_ON_TAG_ATTR_7 = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi;
  var REGEXP_DEFAULT_ON_TAG_ATTR_8 = /u\s*r\s*l\s*\(.*/gi;
  exports.whiteList = getDefaultWhiteList();
  exports.getDefaultWhiteList = getDefaultWhiteList;
  exports.onTag = onTag;
  exports.onIgnoreTag = onIgnoreTag;
  exports.onTagAttr = onTagAttr;
  exports.onIgnoreTagAttr = onIgnoreTagAttr;
  exports.safeAttrValue = safeAttrValue;
  exports.escapeHtml = escapeHtml;
  exports.escapeQuote = escapeQuote;
  exports.unescapeQuote = unescapeQuote;
  exports.escapeHtmlEntities = escapeHtmlEntities;
  exports.escapeDangerHtml5Entities = escapeDangerHtml5Entities;
  exports.clearNonPrintableCharacter = clearNonPrintableCharacter;
  exports.friendlyAttrValue = friendlyAttrValue;
  exports.escapeAttrValue = escapeAttrValue;
  exports.onIgnoreTagStripAll = onIgnoreTagStripAll;
  exports.StripTagBody = StripTagBody;
  exports.stripCommentTag = stripCommentTag;
  exports.stripBlankChar = stripBlankChar;
  exports.cssFilter = defaultCSSFilter;
  exports.getDefaultCSSWhiteList = getDefaultCSSWhiteList;
});

// node_modules/xss/lib/parser.js
var require_parser3 = __commonJS((exports) => {
  var getTagName = function(html2) {
    var i = _.spaceIndex(html2);
    var tagName;
    if (i === -1) {
      tagName = html2.slice(1, -1);
    } else {
      tagName = html2.slice(1, i + 1);
    }
    tagName = _.trim(tagName).toLowerCase();
    if (tagName.slice(0, 1) === "/")
      tagName = tagName.slice(1);
    if (tagName.slice(-1) === "/")
      tagName = tagName.slice(0, -1);
    return tagName;
  };
  var isClosing = function(html2) {
    return html2.slice(0, 2) === "</";
  };
  var parseTag = function(html2, onTag, escapeHtml) {
    var rethtml = "";
    var lastPos = 0;
    var tagStart = false;
    var quoteStart = false;
    var currentPos = 0;
    var len = html2.length;
    var currentTagName = "";
    var currentHtml = "";
    chariterator:
      for (currentPos = 0;currentPos < len; currentPos++) {
        var c = html2.charAt(currentPos);
        if (tagStart === false) {
          if (c === "<") {
            tagStart = currentPos;
            continue;
          }
        } else {
          if (quoteStart === false) {
            if (c === "<") {
              rethtml += escapeHtml(html2.slice(lastPos, currentPos));
              tagStart = currentPos;
              lastPos = currentPos;
              continue;
            }
            if (c === ">" || currentPos === len - 1) {
              rethtml += escapeHtml(html2.slice(lastPos, tagStart));
              currentHtml = html2.slice(tagStart, currentPos + 1);
              currentTagName = getTagName(currentHtml);
              rethtml += onTag(tagStart, rethtml.length, currentTagName, currentHtml, isClosing(currentHtml));
              lastPos = currentPos + 1;
              tagStart = false;
              continue;
            }
            if (c === '"' || c === "'") {
              var i = 1;
              var ic = html2.charAt(currentPos - i);
              while (ic.trim() === "" || ic === "=") {
                if (ic === "=") {
                  quoteStart = c;
                  continue chariterator;
                }
                ic = html2.charAt(currentPos - ++i);
              }
            }
          } else {
            if (c === quoteStart) {
              quoteStart = false;
              continue;
            }
          }
        }
      }
    if (lastPos < len) {
      rethtml += escapeHtml(html2.substr(lastPos));
    }
    return rethtml;
  };
  var parseAttr = function(html2, onAttr) {
    var lastPos = 0;
    var lastMarkPos = 0;
    var retAttrs = [];
    var tmpName = false;
    var len = html2.length;
    function addAttr(name, value) {
      name = _.trim(name);
      name = name.replace(REGEXP_ILLEGAL_ATTR_NAME, "").toLowerCase();
      if (name.length < 1)
        return;
      var ret = onAttr(name, value || "");
      if (ret)
        retAttrs.push(ret);
    }
    for (var i = 0;i < len; i++) {
      var c = html2.charAt(i);
      var v, j;
      if (tmpName === false && c === "=") {
        tmpName = html2.slice(lastPos, i);
        lastPos = i + 1;
        lastMarkPos = html2.charAt(lastPos) === '"' || html2.charAt(lastPos) === "'" ? lastPos : findNextQuotationMark(html2, i + 1);
        continue;
      }
      if (tmpName !== false) {
        if (i === lastMarkPos) {
          j = html2.indexOf(c, i + 1);
          if (j === -1) {
            break;
          } else {
            v = _.trim(html2.slice(lastMarkPos + 1, j));
            addAttr(tmpName, v);
            tmpName = false;
            i = j;
            lastPos = i + 1;
            continue;
          }
        }
      }
      if (/\s|\n|\t/.test(c)) {
        html2 = html2.replace(/\s|\n|\t/g, " ");
        if (tmpName === false) {
          j = findNextEqual(html2, i);
          if (j === -1) {
            v = _.trim(html2.slice(lastPos, i));
            addAttr(v);
            tmpName = false;
            lastPos = i + 1;
            continue;
          } else {
            i = j - 1;
            continue;
          }
        } else {
          j = findBeforeEqual(html2, i - 1);
          if (j === -1) {
            v = _.trim(html2.slice(lastPos, i));
            v = stripQuoteWrap(v);
            addAttr(tmpName, v);
            tmpName = false;
            lastPos = i + 1;
            continue;
          } else {
            continue;
          }
        }
      }
    }
    if (lastPos < html2.length) {
      if (tmpName === false) {
        addAttr(html2.slice(lastPos));
      } else {
        addAttr(tmpName, stripQuoteWrap(_.trim(html2.slice(lastPos))));
      }
    }
    return _.trim(retAttrs.join(" "));
  };
  var findNextEqual = function(str, i) {
    for (;i < str.length; i++) {
      var c = str[i];
      if (c === " ")
        continue;
      if (c === "=")
        return i;
      return -1;
    }
  };
  var findNextQuotationMark = function(str, i) {
    for (;i < str.length; i++) {
      var c = str[i];
      if (c === " ")
        continue;
      if (c === "'" || c === '"')
        return i;
      return -1;
    }
  };
  var findBeforeEqual = function(str, i) {
    for (;i > 0; i--) {
      var c = str[i];
      if (c === " ")
        continue;
      if (c === "=")
        return i;
      return -1;
    }
  };
  var isQuoteWrapString = function(text) {
    if (text[0] === '"' && text[text.length - 1] === '"' || text[0] === "'" && text[text.length - 1] === "'") {
      return true;
    } else {
      return false;
    }
  };
  var stripQuoteWrap = function(text) {
    if (isQuoteWrapString(text)) {
      return text.substr(1, text.length - 2);
    } else {
      return text;
    }
  };
  var _ = require_util3();
  var REGEXP_ILLEGAL_ATTR_NAME = /[^a-zA-Z0-9\\_:.-]/gim;
  exports.parseTag = parseTag;
  exports.parseAttr = parseAttr;
});

// node_modules/xss/lib/xss.js
var require_xss = __commonJS((exports, module) => {
  var isNull = function(obj) {
    return obj === undefined || obj === null;
  };
  var getAttrs = function(html2) {
    var i = _.spaceIndex(html2);
    if (i === -1) {
      return {
        html: "",
        closing: html2[html2.length - 2] === "/"
      };
    }
    html2 = _.trim(html2.slice(i + 1, -1));
    var isClosing = html2[html2.length - 1] === "/";
    if (isClosing)
      html2 = _.trim(html2.slice(0, -1));
    return {
      html: html2,
      closing: isClosing
    };
  };
  var shallowCopyObject = function(obj) {
    var ret = {};
    for (var i in obj) {
      ret[i] = obj[i];
    }
    return ret;
  };
  var keysToLowerCase = function(obj) {
    var ret = {};
    for (var i in obj) {
      if (Array.isArray(obj[i])) {
        ret[i.toLowerCase()] = obj[i].map(function(item) {
          return item.toLowerCase();
        });
      } else {
        ret[i.toLowerCase()] = obj[i];
      }
    }
    return ret;
  };
  var FilterXSS = function(options) {
    options = shallowCopyObject(options || {});
    if (options.stripIgnoreTag) {
      if (options.onIgnoreTag) {
        console.error('Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time');
      }
      options.onIgnoreTag = DEFAULT.onIgnoreTagStripAll;
    }
    if (options.whiteList || options.allowList) {
      options.whiteList = keysToLowerCase(options.whiteList || options.allowList);
    } else {
      options.whiteList = DEFAULT.whiteList;
    }
    options.onTag = options.onTag || DEFAULT.onTag;
    options.onTagAttr = options.onTagAttr || DEFAULT.onTagAttr;
    options.onIgnoreTag = options.onIgnoreTag || DEFAULT.onIgnoreTag;
    options.onIgnoreTagAttr = options.onIgnoreTagAttr || DEFAULT.onIgnoreTagAttr;
    options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
    options.escapeHtml = options.escapeHtml || DEFAULT.escapeHtml;
    this.options = options;
    if (options.css === false) {
      this.cssFilter = false;
    } else {
      options.css = options.css || {};
      this.cssFilter = new FilterCSS(options.css);
    }
  };
  var FilterCSS = require_lib7().FilterCSS;
  var DEFAULT = require_default2();
  var parser = require_parser3();
  var parseTag = parser.parseTag;
  var parseAttr = parser.parseAttr;
  var _ = require_util3();
  FilterXSS.prototype.process = function(html2) {
    html2 = html2 || "";
    html2 = html2.toString();
    if (!html2)
      return "";
    var me = this;
    var options = me.options;
    var whiteList = options.whiteList;
    var onTag = options.onTag;
    var onIgnoreTag = options.onIgnoreTag;
    var onTagAttr = options.onTagAttr;
    var onIgnoreTagAttr = options.onIgnoreTagAttr;
    var safeAttrValue = options.safeAttrValue;
    var escapeHtml = options.escapeHtml;
    var cssFilter = me.cssFilter;
    if (options.stripBlankChar) {
      html2 = DEFAULT.stripBlankChar(html2);
    }
    if (!options.allowCommentTag) {
      html2 = DEFAULT.stripCommentTag(html2);
    }
    var stripIgnoreTagBody = false;
    if (options.stripIgnoreTagBody) {
      stripIgnoreTagBody = DEFAULT.StripTagBody(options.stripIgnoreTagBody, onIgnoreTag);
      onIgnoreTag = stripIgnoreTagBody.onIgnoreTag;
    }
    var retHtml = parseTag(html2, function(sourcePosition, position, tag, html3, isClosing) {
      var info = {
        sourcePosition,
        position,
        isClosing,
        isWhite: Object.prototype.hasOwnProperty.call(whiteList, tag)
      };
      var ret = onTag(tag, html3, info);
      if (!isNull(ret))
        return ret;
      if (info.isWhite) {
        if (info.isClosing) {
          return "</" + tag + ">";
        }
        var attrs = getAttrs(html3);
        var whiteAttrList = whiteList[tag];
        var attrsHtml = parseAttr(attrs.html, function(name, value) {
          var isWhiteAttr = _.indexOf(whiteAttrList, name) !== -1;
          var ret2 = onTagAttr(tag, name, value, isWhiteAttr);
          if (!isNull(ret2))
            return ret2;
          if (isWhiteAttr) {
            value = safeAttrValue(tag, name, value, cssFilter);
            if (value) {
              return name + '="' + value + '"';
            } else {
              return name;
            }
          } else {
            ret2 = onIgnoreTagAttr(tag, name, value, isWhiteAttr);
            if (!isNull(ret2))
              return ret2;
            return;
          }
        });
        html3 = "<" + tag;
        if (attrsHtml)
          html3 += " " + attrsHtml;
        if (attrs.closing)
          html3 += " /";
        html3 += ">";
        return html3;
      } else {
        ret = onIgnoreTag(tag, html3, info);
        if (!isNull(ret))
          return ret;
        return escapeHtml(html3);
      }
    }, escapeHtml);
    if (stripIgnoreTagBody) {
      retHtml = stripIgnoreTagBody.remove(retHtml);
    }
    return retHtml;
  };
  module.exports = FilterXSS;
});

// node_modules/xss/lib/index.js
var require_lib8 = __commonJS((exports, module) => {
  var filterXSS = function(html2, options) {
    var xss = new FilterXSS(options);
    return xss.process(html2);
  };
  var isWorkerEnv = function() {
    return typeof self !== "undefined" && typeof DedicatedWorkerGlobalScope !== "undefined" && self instanceof DedicatedWorkerGlobalScope;
  };
  var DEFAULT = require_default2();
  var parser = require_parser3();
  var FilterXSS = require_xss();
  exports = module.exports = filterXSS;
  exports.filterXSS = filterXSS;
  exports.FilterXSS = FilterXSS;
  (function() {
    for (var i in DEFAULT) {
      exports[i] = DEFAULT[i];
    }
    for (var j in parser) {
      exports[j] = parser[j];
    }
  })();
  if (typeof window !== "undefined") {
    window.filterXSS = module.exports;
  }
  if (isWorkerEnv()) {
    self.filterXSS = module.exports;
  }
});

// node_modules/elysia/dist/bun/index.js
var m6 = Object.create;
var { defineProperty: y4, getPrototypeOf: o6, getOwnPropertyNames: n6 } = Object;
var u6 = Object.prototype.hasOwnProperty;
var t0 = ($, J, Y) => {
  Y = $ != null ? m6(o6($)) : {};
  const X = J || !$ || !$.__esModule ? y4(Y, "default", { value: $, enumerable: true }) : Y;
  for (let Z of n6($))
    if (!u6.call(X, Z))
      y4(X, Z, { get: () => $[Z], enumerable: true });
  return X;
};
var l = ($, J) => () => (J || $((J = { exports: {} }).exports, J), J.exports);
var G0 = l((n4) => {
  Object.defineProperty(n4, "__esModule", { value: true });
  n4.Type = n4.StandardType = n4.ExtendedTypeBuilder = n4.StandardTypeBuilder = n4.TypeBuilder = n4.TemplateLiteralDslParser = n4.TemplateLiteralGenerator = n4.TemplateLiteralFinite = n4.TemplateLiteralParser = n4.TemplateLiteralParserError = n4.TemplateLiteralResolver = n4.TemplateLiteralPattern = n4.UnionResolver = n4.KeyArrayResolver = n4.KeyResolver = n4.ObjectMap = n4.Intrinsic = n4.IndexedAccessor = n4.TypeClone = n4.TypeExtends = n4.TypeExtendsResult = n4.ExtendsUndefined = n4.TypeGuard = n4.TypeGuardUnknownTypeError = n4.ValueGuard = n4.FormatRegistry = n4.TypeRegistry = n4.PatternStringExact = n4.PatternNumberExact = n4.PatternBooleanExact = n4.PatternString = n4.PatternNumber = n4.PatternBoolean = n4.Kind = n4.Hint = n4.Optional = n4.Readonly = undefined;
  n4.Readonly = Symbol.for("TypeBox.Readonly");
  n4.Optional = Symbol.for("TypeBox.Optional");
  n4.Hint = Symbol.for("TypeBox.Hint");
  n4.Kind = Symbol.for("TypeBox.Kind");
  n4.PatternBoolean = "(true|false)";
  n4.PatternNumber = "(0|[1-9][0-9]*)";
  n4.PatternString = "(.*)";
  n4.PatternBooleanExact = `^${n4.PatternBoolean}$`;
  n4.PatternNumberExact = `^${n4.PatternNumber}$`;
  n4.PatternStringExact = `^${n4.PatternString}$`;
  var k$;
  (function($) {
    const J = new Map;
    function Y() {
      return new Map(J);
    }
    $.Entries = Y;
    function X() {
      return J.clear();
    }
    $.Clear = X;
    function Z(B) {
      return J.delete(B);
    }
    $.Delete = Z;
    function Q(B) {
      return J.has(B);
    }
    $.Has = Q;
    function q(B, w) {
      J.set(B, w);
    }
    $.Set = q;
    function F(B) {
      return J.get(B);
    }
    $.Get = F;
  })(k$ || (n4.TypeRegistry = k$ = {}));
  var p4;
  (function($) {
    const J = new Map;
    function Y() {
      return new Map(J);
    }
    $.Entries = Y;
    function X() {
      return J.clear();
    }
    $.Clear = X;
    function Z(B) {
      return J.delete(B);
    }
    $.Delete = Z;
    function Q(B) {
      return J.has(B);
    }
    $.Has = Q;
    function q(B, w) {
      J.set(B, w);
    }
    $.Set = q;
    function F(B) {
      return J.get(B);
    }
    $.Get = F;
  })(p4 || (n4.FormatRegistry = p4 = {}));
  var _;
  (function($) {
    function J(w) {
      return typeof w === "object" && w !== null;
    }
    $.IsObject = J;
    function Y(w) {
      return Array.isArray(w);
    }
    $.IsArray = Y;
    function X(w) {
      return typeof w === "boolean";
    }
    $.IsBoolean = X;
    function Z(w) {
      return w === null;
    }
    $.IsNull = Z;
    function Q(w) {
      return w === undefined;
    }
    $.IsUndefined = Q;
    function q(w) {
      return typeof w === "bigint";
    }
    $.IsBigInt = q;
    function F(w) {
      return typeof w === "number";
    }
    $.IsNumber = F;
    function B(w) {
      return typeof w === "string";
    }
    $.IsString = B;
  })(_ || (n4.ValueGuard = _ = {}));

  class o4 extends Error {
    constructor($) {
      super("TypeGuard: Unknown type");
      this.schema = $;
    }
  }
  n4.TypeGuardUnknownTypeError = o4;
  var M;
  (function($) {
    function J(W) {
      try {
        return new RegExp(W), true;
      } catch {
        return false;
      }
    }
    function Y(W) {
      if (!_.IsString(W))
        return false;
      for (let b = 0;b < W.length; b++) {
        const C = W.charCodeAt(b);
        if (C >= 7 && C <= 13 || C === 27 || C === 127)
          return false;
      }
      return true;
    }
    function X(W) {
      return q(W) || j(W);
    }
    function Z(W) {
      return _.IsUndefined(W) || _.IsBigInt(W);
    }
    function Q(W) {
      return _.IsUndefined(W) || _.IsNumber(W);
    }
    function q(W) {
      return _.IsUndefined(W) || _.IsBoolean(W);
    }
    function F(W) {
      return _.IsUndefined(W) || _.IsString(W);
    }
    function B(W) {
      return _.IsUndefined(W) || _.IsString(W) && Y(W) && J(W);
    }
    function w(W) {
      return _.IsUndefined(W) || _.IsString(W) && Y(W);
    }
    function N(W) {
      return _.IsUndefined(W) || j(W);
    }
    function P(W) {
      return T(W, "Any") && F(W.$id);
    }
    $.TAny = P;
    function D(W) {
      return T(W, "Array") && W.type === "array" && F(W.$id) && j(W.items) && Q(W.minItems) && Q(W.maxItems) && q(W.uniqueItems) && N(W.contains) && Q(W.minContains) && Q(W.maxContains);
    }
    $.TArray = D;
    function A(W) {
      return T(W, "AsyncIterator") && W.type === "AsyncIterator" && F(W.$id) && j(W.items);
    }
    $.TAsyncIterator = A;
    function L(W) {
      return T(W, "BigInt") && W.type === "bigint" && F(W.$id) && Z(W.multipleOf) && Z(W.minimum) && Z(W.maximum) && Z(W.exclusiveMinimum) && Z(W.exclusiveMaximum);
    }
    $.TBigInt = L;
    function O(W) {
      return T(W, "Boolean") && W.type === "boolean" && F(W.$id);
    }
    $.TBoolean = O;
    function G(W) {
      if (!(T(W, "Constructor") && W.type === "constructor" && F(W.$id) && _.IsArray(W.parameters) && j(W.returns)))
        return false;
      for (let b of W.parameters)
        if (!j(b))
          return false;
      return true;
    }
    $.TConstructor = G;
    function R(W) {
      return T(W, "Date") && W.type === "Date" && F(W.$id) && Q(W.minimumTimestamp) && Q(W.maximumTimestamp) && Q(W.exclusiveMinimumTimestamp) && Q(W.exclusiveMaximumTimestamp);
    }
    $.TDate = R;
    function k(W) {
      if (!(T(W, "Function") && W.type === "function" && F(W.$id) && _.IsArray(W.parameters) && j(W.returns)))
        return false;
      for (let b of W.parameters)
        if (!j(b))
          return false;
      return true;
    }
    $.TFunction = k;
    function y(W) {
      return T(W, "Integer") && W.type === "integer" && F(W.$id) && Q(W.multipleOf) && Q(W.minimum) && Q(W.maximum) && Q(W.exclusiveMinimum) && Q(W.exclusiveMaximum);
    }
    $.TInteger = y;
    function S(W) {
      if (!(T(W, "Intersect") && _.IsArray(W.allOf) && F(W.type) && (q(W.unevaluatedProperties) || N(W.unevaluatedProperties)) && F(W.$id)))
        return false;
      if (("type" in W) && W.type !== "object")
        return false;
      for (let b of W.allOf)
        if (!j(b))
          return false;
      return true;
    }
    $.TIntersect = S;
    function V(W) {
      return T(W, "Iterator") && W.type === "Iterator" && F(W.$id) && j(W.items);
    }
    $.TIterator = V;
    function T(W, b) {
      return M0(W) && W[n4.Kind] === b;
    }
    $.TKindOf = T;
    function M0(W) {
      return _.IsObject(W) && (n4.Kind in W) && _.IsString(W[n4.Kind]);
    }
    $.TKind = M0;
    function J0(W) {
      return T0(W) && _.IsString(W.const);
    }
    $.TLiteralString = J0;
    function X1(W) {
      return T0(W) && _.IsNumber(W.const);
    }
    $.TLiteralNumber = X1;
    function b0(W) {
      return T0(W) && _.IsBoolean(W.const);
    }
    $.TLiteralBoolean = b0;
    function T0(W) {
      return T(W, "Literal") && F(W.$id) && (_.IsBoolean(W.const) || _.IsNumber(W.const) || _.IsString(W.const));
    }
    $.TLiteral = T0;
    function e(W) {
      return T(W, "Never") && _.IsObject(W.not) && Object.getOwnPropertyNames(W.not).length === 0;
    }
    $.TNever = e;
    function Z1(W) {
      return T(W, "Not") && j(W.not);
    }
    $.TNot = Z1;
    function Q1(W) {
      return T(W, "Null") && W.type === "null" && F(W.$id);
    }
    $.TNull = Q1;
    function c0(W) {
      return T(W, "Number") && W.type === "number" && F(W.$id) && Q(W.multipleOf) && Q(W.minimum) && Q(W.maximum) && Q(W.exclusiveMinimum) && Q(W.exclusiveMaximum);
    }
    $.TNumber = c0;
    function W1(W) {
      if (!(T(W, "Object") && W.type === "object" && F(W.$id) && _.IsObject(W.properties) && X(W.additionalProperties) && Q(W.minProperties) && Q(W.maxProperties)))
        return false;
      for (let [b, C] of Object.entries(W.properties)) {
        if (!Y(b))
          return false;
        if (!j(C))
          return false;
      }
      return true;
    }
    $.TObject = W1;
    function U1(W) {
      return T(W, "Promise") && W.type === "Promise" && F(W.$id) && j(W.item);
    }
    $.TPromise = U1;
    function B1(W) {
      if (!(T(W, "Record") && W.type === "object" && F(W.$id) && X(W.additionalProperties) && _.IsObject(W.patternProperties)))
        return false;
      const b = Object.getOwnPropertyNames(W.patternProperties);
      if (b.length !== 1)
        return false;
      if (!J(b[0]))
        return false;
      if (!j(W.patternProperties[b[0]]))
        return false;
      return true;
    }
    $.TRecord = B1;
    function A1(W) {
      return T(W, "Ref") && F(W.$id) && _.IsString(W.$ref);
    }
    $.TRef = A1;
    function N1(W) {
      return T(W, "String") && W.type === "string" && F(W.$id) && Q(W.minLength) && Q(W.maxLength) && B(W.pattern) && w(W.format);
    }
    $.TString = N1;
    function w1(W) {
      return T(W, "Symbol") && W.type === "symbol" && F(W.$id);
    }
    $.TSymbol = w1;
    function A0(W) {
      return T(W, "TemplateLiteral") && W.type === "string" && _.IsString(W.pattern) && W.pattern[0] === "^" && W.pattern[W.pattern.length - 1] === "$";
    }
    $.TTemplateLiteral = A0;
    function r(W) {
      return T(W, "This") && F(W.$id) && _.IsString(W.$ref);
    }
    $.TThis = r;
    function Y0(W) {
      if (!(T(W, "Tuple") && W.type === "array" && F(W.$id) && _.IsNumber(W.minItems) && _.IsNumber(W.maxItems) && W.minItems === W.maxItems))
        return false;
      if (_.IsUndefined(W.items) && _.IsUndefined(W.additionalItems) && W.minItems === 0)
        return true;
      if (!_.IsArray(W.items))
        return false;
      for (let b of W.items)
        if (!j(b))
          return false;
      return true;
    }
    $.TTuple = Y0;
    function t(W) {
      return T(W, "Undefined") && W.type === "undefined" && F(W.$id);
    }
    $.TUndefined = t;
    function d0(W) {
      return l0(W) && W.anyOf.every((b) => J0(b) || X1(b));
    }
    $.TUnionLiteral = d0;
    function l0(W) {
      if (!(T(W, "Union") && _.IsArray(W.anyOf) && F(W.$id)))
        return false;
      for (let b of W.anyOf)
        if (!j(b))
          return false;
      return true;
    }
    $.TUnion = l0;
    function _0(W) {
      return T(W, "Uint8Array") && W.type === "Uint8Array" && F(W.$id) && Q(W.minByteLength) && Q(W.maxByteLength);
    }
    $.TUint8Array = _0;
    function y0(W) {
      return T(W, "Unknown") && F(W.$id);
    }
    $.TUnknown = y0;
    function X0(W) {
      return T(W, "Unsafe");
    }
    $.TUnsafe = X0;
    function z1(W) {
      return T(W, "Void") && W.type === "void" && F(W.$id);
    }
    $.TVoid = z1;
    function D1(W) {
      return _.IsObject(W) && W[n4.Readonly] === "Readonly";
    }
    $.TReadonly = D1;
    function U(W) {
      return _.IsObject(W) && W[n4.Optional] === "Optional";
    }
    $.TOptional = U;
    function j(W) {
      return _.IsObject(W) && (P(W) || D(W) || O(W) || L(W) || A(W) || G(W) || R(W) || k(W) || y(W) || S(W) || V(W) || T0(W) || e(W) || Z1(W) || Q1(W) || c0(W) || W1(W) || U1(W) || B1(W) || A1(W) || N1(W) || w1(W) || A0(W) || r(W) || Y0(W) || t(W) || l0(W) || _0(W) || y0(W) || X0(W) || z1(W) || M0(W) && k$.Has(W[n4.Kind]));
    }
    $.TSchema = j;
  })(M || (n4.TypeGuard = M = {}));
  var m4;
  (function($) {
    function J(Y) {
      if (Y[n4.Kind] === "Undefined")
        return true;
      if (Y[n4.Kind] === "Not")
        return !J(Y.not);
      if (Y[n4.Kind] === "Intersect")
        return Y.allOf.every((Z) => J(Z));
      if (Y[n4.Kind] === "Union")
        return Y.anyOf.some((Z) => J(Z));
      return false;
    }
    $.Check = J;
  })(m4 || (n4.ExtendsUndefined = m4 = {}));
  var K;
  (function($) {
    $[$.Union = 0] = "Union", $[$.True = 1] = "True", $[$.False = 2] = "False";
  })(K || (n4.TypeExtendsResult = K = {}));
  var H1;
  (function($) {
    function J(H) {
      return H === K.False ? K.False : K.True;
    }
    function Y(H) {
      return M.TNever(H) || M.TIntersect(H) || M.TUnion(H) || M.TUnknown(H) || M.TAny(H);
    }
    function X(H, z) {
      if (M.TNever(z))
        return V(H, z);
      if (M.TIntersect(z))
        return R(H, z);
      if (M.TUnion(z))
        return N0(H, z);
      if (M.TUnknown(z))
        return D0(H, z);
      if (M.TAny(z))
        return Z(H, z);
      throw Error("TypeExtends: StructuralRight");
    }
    function Z(H, z) {
      return K.True;
    }
    function Q(H, z) {
      if (M.TIntersect(z))
        return R(H, z);
      if (M.TUnion(z) && z.anyOf.some((p) => M.TAny(p) || M.TUnknown(p)))
        return K.True;
      if (M.TUnion(z))
        return K.Union;
      if (M.TUnknown(z))
        return K.True;
      if (M.TAny(z))
        return K.True;
      return K.Union;
    }
    function q(H, z) {
      if (M.TUnknown(H))
        return K.False;
      if (M.TAny(H))
        return K.Union;
      if (M.TNever(H))
        return K.True;
      return K.False;
    }
    function F(H, z) {
      if (Y(z))
        return X(H, z);
      if (M.TObject(z) && A0(z))
        return K.True;
      if (!M.TArray(z))
        return K.False;
      return J(n(H.items, z.items));
    }
    function B(H, z) {
      if (Y(z))
        return X(H, z);
      if (!M.TAsyncIterator(z))
        return K.False;
      return J(n(H.items, z.items));
    }
    function w(H, z) {
      if (Y(z))
        return X(H, z);
      if (M.TObject(z))
        return t(H, z);
      if (M.TRecord(z))
        return X0(H, z);
      return M.TBigInt(z) ? K.True : K.False;
    }
    function N(H, z) {
      if (M.TLiteral(H) && _.IsBoolean(H.const))
        return K.True;
      return M.TBoolean(H) ? K.True : K.False;
    }
    function P(H, z) {
      if (Y(z))
        return X(H, z);
      if (M.TObject(z))
        return t(H, z);
      if (M.TRecord(z))
        return X0(H, z);
      return M.TBoolean(z) ? K.True : K.False;
    }
    function D(H, z) {
      if (Y(z))
        return X(H, z);
      if (M.TObject(z))
        return t(H, z);
      if (!M.TConstructor(z))
        return K.False;
      if (H.parameters.length > z.parameters.length)
        return K.False;
      if (!H.parameters.every((p, R0) => J(n(z.parameters[R0], p)) === K.True))
        return K.False;
      return J(n(H.returns, z.returns));
    }
    function A(H, z) {
      if (Y(z))
        return X(H, z);
      if (M.TObject(z))
        return t(H, z);
      if (M.TRecord(z))
        return X0(H, z);
      return M.TDate(z) ? K.True : K.False;
    }
    function L(H, z) {
      if (Y(z))
        return X(H, z);
      if (M.TObject(z))
        return t(H, z);
      if (!M.TFunction(z))
        return K.False;
      if (H.parameters.length > z.parameters.length)
        return K.False;
      if (!H.parameters.every((p, R0) => J(n(z.parameters[R0], p)) === K.True))
        return K.False;
      return J(n(H.returns, z.returns));
    }
    function O(H, z) {
      if (M.TLiteral(H) && _.IsNumber(H.const))
        return K.True;
      return M.TNumber(H) || M.TInteger(H) ? K.True : K.False;
    }
    function G(H, z) {
      if (Y(z))
        return X(H, z);
      if (M.TObject(z))
        return t(H, z);
      if (M.TRecord(z))
        return X0(H, z);
      return M.TInteger(z) || M.TNumber(z) ? K.True : K.False;
    }
    function R(H, z) {
      return z.allOf.every((p) => n(H, p) === K.True) ? K.True : K.False;
    }
    function k(H, z) {
      return H.allOf.some((p) => n(p, z) === K.True) ? K.True : K.False;
    }
    function y(H, z) {
      if (Y(z))
        return X(H, z);
      if (!M.TIterator(z))
        return K.False;
      return J(n(H.items, z.items));
    }
    function S(H, z) {
      if (Y(z))
        return X(H, z);
      if (M.TObject(z))
        return t(H, z);
      if (M.TRecord(z))
        return X0(H, z);
      if (M.TString(z))
        return D1(H, z);
      if (M.TNumber(z))
        return b0(H, z);
      if (M.TInteger(z))
        return O(H, z);
      if (M.TBoolean(z))
        return N(H, z);
      return M.TLiteral(z) && z.const === H.const ? K.True : K.False;
    }
    function V(H, z) {
      return K.False;
    }
    function T(H, z) {
      return K.True;
    }
    function M0(H) {
      let [z, p] = [H, 0];
      while (true) {
        if (!M.TNot(z))
          break;
        z = z.not, p += 1;
      }
      return p % 2 === 0 ? z : n4.Type.Unknown();
    }
    function J0(H, z) {
      if (M.TNot(H))
        return n(M0(H), z);
      if (M.TNot(z))
        return n(H, M0(z));
      throw new Error("TypeExtends: Invalid fallthrough for Not");
    }
    function X1(H, z) {
      if (Y(z))
        return X(H, z);
      if (M.TObject(z))
        return t(H, z);
      if (M.TRecord(z))
        return X0(H, z);
      return M.TNull(z) ? K.True : K.False;
    }
    function b0(H, z) {
      if (M.TLiteralNumber(H))
        return K.True;
      return M.TNumber(H) || M.TInteger(H) ? K.True : K.False;
    }
    function T0(H, z) {
      if (Y(z))
        return X(H, z);
      if (M.TObject(z))
        return t(H, z);
      if (M.TRecord(z))
        return X0(H, z);
      return M.TInteger(z) || M.TNumber(z) ? K.True : K.False;
    }
    function e(H, z) {
      return Object.getOwnPropertyNames(H.properties).length === z;
    }
    function Z1(H) {
      return A0(H);
    }
    function Q1(H) {
      return e(H, 0) || e(H, 1) && ("description" in H.properties) && M.TUnion(H.properties.description) && H.properties.description.anyOf.length === 2 && (M.TString(H.properties.description.anyOf[0]) && M.TUndefined(H.properties.description.anyOf[1]) || M.TString(H.properties.description.anyOf[1]) && M.TUndefined(H.properties.description.anyOf[0]));
    }
    function c0(H) {
      return e(H, 0);
    }
    function W1(H) {
      return e(H, 0);
    }
    function U1(H) {
      return e(H, 0);
    }
    function B1(H) {
      return e(H, 0);
    }
    function A1(H) {
      return A0(H);
    }
    function N1(H) {
      const z = n4.Type.Number();
      return e(H, 0) || e(H, 1) && ("length" in H.properties) && J(n(H.properties.length, z)) === K.True;
    }
    function w1(H) {
      return e(H, 0);
    }
    function A0(H) {
      const z = n4.Type.Number();
      return e(H, 0) || e(H, 1) && ("length" in H.properties) && J(n(H.properties.length, z)) === K.True;
    }
    function r(H) {
      const z = n4.Type.Function([n4.Type.Any()], n4.Type.Any());
      return e(H, 0) || e(H, 1) && ("then" in H.properties) && J(n(H.properties.then, z)) === K.True;
    }
    function Y0(H, z) {
      if (n(H, z) === K.False)
        return K.False;
      if (M.TOptional(H) && !M.TOptional(z))
        return K.False;
      return K.True;
    }
    function t(H, z) {
      if (M.TUnknown(H))
        return K.False;
      if (M.TAny(H))
        return K.Union;
      if (M.TNever(H))
        return K.True;
      if (M.TLiteralString(H) && Z1(z))
        return K.True;
      if (M.TLiteralNumber(H) && c0(z))
        return K.True;
      if (M.TLiteralBoolean(H) && W1(z))
        return K.True;
      if (M.TSymbol(H) && Q1(z))
        return K.True;
      if (M.TBigInt(H) && U1(z))
        return K.True;
      if (M.TString(H) && Z1(z))
        return K.True;
      if (M.TSymbol(H) && Q1(z))
        return K.True;
      if (M.TNumber(H) && c0(z))
        return K.True;
      if (M.TInteger(H) && c0(z))
        return K.True;
      if (M.TBoolean(H) && W1(z))
        return K.True;
      if (M.TUint8Array(H) && A1(z))
        return K.True;
      if (M.TDate(H) && B1(z))
        return K.True;
      if (M.TConstructor(H) && w1(z))
        return K.True;
      if (M.TFunction(H) && N1(z))
        return K.True;
      if (M.TRecord(H) && M.TString(_0(H)))
        return z[n4.Hint] === "Record" ? K.True : K.False;
      if (M.TRecord(H) && M.TNumber(_0(H)))
        return e(z, 0) ? K.True : K.False;
      return K.False;
    }
    function d0(H, z) {
      if (Y(z))
        return X(H, z);
      if (M.TRecord(z))
        return X0(H, z);
      if (!M.TObject(z))
        return K.False;
      for (let p of Object.getOwnPropertyNames(z.properties)) {
        if (!(p in H.properties))
          return K.False;
        if (Y0(H.properties[p], z.properties[p]) === K.False)
          return K.False;
      }
      return K.True;
    }
    function l0(H, z) {
      if (Y(z))
        return X(H, z);
      if (M.TObject(z) && r(z))
        return K.True;
      if (!M.TPromise(z))
        return K.False;
      return J(n(H.item, z.item));
    }
    function _0(H) {
      if (n4.PatternNumberExact in H.patternProperties)
        return n4.Type.Number();
      if (n4.PatternStringExact in H.patternProperties)
        return n4.Type.String();
      throw Error("TypeExtends: Cannot get record key");
    }
    function y0(H) {
      if (n4.PatternNumberExact in H.patternProperties)
        return H.patternProperties[n4.PatternNumberExact];
      if (n4.PatternStringExact in H.patternProperties)
        return H.patternProperties[n4.PatternStringExact];
      throw Error("TypeExtends: Cannot get record value");
    }
    function X0(H, z) {
      const p = _0(z), R0 = y0(z);
      if (M.TLiteralString(H) && M.TNumber(p) && J(n(H, R0)) === K.True)
        return K.True;
      if (M.TUint8Array(H) && M.TNumber(p))
        return n(H, R0);
      if (M.TString(H) && M.TNumber(p))
        return n(H, R0);
      if (M.TArray(H) && M.TNumber(p))
        return n(H, R0);
      if (M.TObject(H)) {
        for (let p6 of Object.getOwnPropertyNames(H.properties))
          if (Y0(R0, H.properties[p6]) === K.False)
            return K.False;
        return K.True;
      }
      return K.False;
    }
    function z1(H, z) {
      const p = y0(H);
      if (Y(z))
        return X(H, z);
      if (M.TObject(z))
        return t(H, z);
      if (!M.TRecord(z))
        return K.False;
      return n(p, y0(z));
    }
    function D1(H, z) {
      if (M.TLiteral(H) && _.IsString(H.const))
        return K.True;
      return M.TString(H) ? K.True : K.False;
    }
    function U(H, z) {
      if (Y(z))
        return X(H, z);
      if (M.TObject(z))
        return t(H, z);
      if (M.TRecord(z))
        return X0(H, z);
      return M.TString(z) ? K.True : K.False;
    }
    function j(H, z) {
      if (Y(z))
        return X(H, z);
      if (M.TObject(z))
        return t(H, z);
      if (M.TRecord(z))
        return X0(H, z);
      return M.TSymbol(z) ? K.True : K.False;
    }
    function W(H, z) {
      if (M.TTemplateLiteral(H))
        return n(v0.Resolve(H), z);
      if (M.TTemplateLiteral(z))
        return n(H, v0.Resolve(z));
      throw new Error("TypeExtends: Invalid fallthrough for TemplateLiteral");
    }
    function b(H, z) {
      return M.TArray(z) && H.items !== undefined && H.items.every((p) => n(p, z.items) === K.True);
    }
    function C(H, z) {
      if (M.TNever(H))
        return K.True;
      if (M.TUnknown(H))
        return K.False;
      if (M.TAny(H))
        return K.Union;
      return K.False;
    }
    function E(H, z) {
      if (Y(z))
        return X(H, z);
      if (M.TObject(z) && A0(z))
        return K.True;
      if (M.TArray(z) && b(H, z))
        return K.True;
      if (!M.TTuple(z))
        return K.False;
      if (_.IsUndefined(H.items) && !_.IsUndefined(z.items) || !_.IsUndefined(H.items) && _.IsUndefined(z.items))
        return K.False;
      if (_.IsUndefined(H.items) && !_.IsUndefined(z.items))
        return K.True;
      return H.items.every((p, R0) => n(p, z.items[R0]) === K.True) ? K.True : K.False;
    }
    function h(H, z) {
      if (Y(z))
        return X(H, z);
      if (M.TObject(z))
        return t(H, z);
      if (M.TRecord(z))
        return X0(H, z);
      return M.TUint8Array(z) ? K.True : K.False;
    }
    function z0(H, z) {
      if (Y(z))
        return X(H, z);
      if (M.TObject(z))
        return t(H, z);
      if (M.TRecord(z))
        return X0(H, z);
      if (M.TVoid(z))
        return x$(H, z);
      return M.TUndefined(z) ? K.True : K.False;
    }
    function N0(H, z) {
      return z.anyOf.some((p) => n(H, p) === K.True) ? K.True : K.False;
    }
    function w0(H, z) {
      return H.anyOf.every((p) => n(p, z) === K.True) ? K.True : K.False;
    }
    function D0(H, z) {
      return K.True;
    }
    function K1(H, z) {
      if (M.TNever(z))
        return V(H, z);
      if (M.TIntersect(z))
        return R(H, z);
      if (M.TUnion(z))
        return N0(H, z);
      if (M.TAny(z))
        return Z(H, z);
      if (M.TString(z))
        return D1(H, z);
      if (M.TNumber(z))
        return b0(H, z);
      if (M.TInteger(z))
        return O(H, z);
      if (M.TBoolean(z))
        return N(H, z);
      if (M.TArray(z))
        return q(H, z);
      if (M.TTuple(z))
        return C(H, z);
      if (M.TObject(z))
        return t(H, z);
      return M.TUnknown(z) ? K.True : K.False;
    }
    function x$(H, z) {
      if (M.TUndefined(H))
        return K.True;
      return M.TUndefined(H) ? K.True : K.False;
    }
    function d4(H, z) {
      if (M.TIntersect(z))
        return R(H, z);
      if (M.TUnion(z))
        return N0(H, z);
      if (M.TUnknown(z))
        return D0(H, z);
      if (M.TAny(z))
        return Z(H, z);
      if (M.TObject(z))
        return t(H, z);
      return M.TVoid(z) ? K.True : K.False;
    }
    function n(H, z) {
      if (M.TTemplateLiteral(H) || M.TTemplateLiteral(z))
        return W(H, z);
      if (M.TNot(H) || M.TNot(z))
        return J0(H, z);
      if (M.TAny(H))
        return Q(H, z);
      if (M.TArray(H))
        return F(H, z);
      if (M.TBigInt(H))
        return w(H, z);
      if (M.TBoolean(H))
        return P(H, z);
      if (M.TAsyncIterator(H))
        return B(H, z);
      if (M.TConstructor(H))
        return D(H, z);
      if (M.TDate(H))
        return A(H, z);
      if (M.TFunction(H))
        return L(H, z);
      if (M.TInteger(H))
        return G(H, z);
      if (M.TIntersect(H))
        return k(H, z);
      if (M.TIterator(H))
        return y(H, z);
      if (M.TLiteral(H))
        return S(H, z);
      if (M.TNever(H))
        return T(H, z);
      if (M.TNull(H))
        return X1(H, z);
      if (M.TNumber(H))
        return T0(H, z);
      if (M.TObject(H))
        return d0(H, z);
      if (M.TRecord(H))
        return z1(H, z);
      if (M.TString(H))
        return U(H, z);
      if (M.TSymbol(H))
        return j(H, z);
      if (M.TTuple(H))
        return E(H, z);
      if (M.TPromise(H))
        return l0(H, z);
      if (M.TUint8Array(H))
        return h(H, z);
      if (M.TUndefined(H))
        return z0(H, z);
      if (M.TUnion(H))
        return w0(H, z);
      if (M.TUnknown(H))
        return K1(H, z);
      if (M.TVoid(H))
        return d4(H, z);
      throw Error(`TypeExtends: Unknown left type operand '${H[n4.Kind]}'`);
    }
    function i6(H, z) {
      return n(H, z);
    }
    $.Extends = i6;
  })(H1 || (n4.TypeExtends = H1 = {}));
  var g;
  (function($) {
    function J(Q) {
      const q = Object.getOwnPropertyNames(Q).reduce((B, w) => ({ ...B, [w]: X(Q[w]) }), {}), F = Object.getOwnPropertySymbols(Q).reduce((B, w) => ({ ...B, [w]: X(Q[w]) }), {});
      return { ...q, ...F };
    }
    function Y(Q) {
      return Q.map((q) => X(q));
    }
    function X(Q) {
      if (_.IsArray(Q))
        return Y(Q);
      if (_.IsObject(Q))
        return J(Q);
      return Q;
    }
    function Z(Q, q = {}) {
      return { ...X(Q), ...q };
    }
    $.Clone = Z;
  })(g || (n4.TypeClone = g = {}));
  var g$;
  (function($) {
    function J(A) {
      return A.map((L) => {
        const { [n4.Optional]: O, ...G } = g.Clone(L);
        return G;
      });
    }
    function Y(A) {
      return A.every((L) => M.TOptional(L));
    }
    function X(A) {
      return A.some((L) => M.TOptional(L));
    }
    function Z(A) {
      return Y(A.allOf) ? n4.Type.Optional(n4.Type.Intersect(J(A.allOf))) : A;
    }
    function Q(A) {
      return X(A.anyOf) ? n4.Type.Optional(n4.Type.Union(J(A.anyOf))) : A;
    }
    function q(A) {
      if (A[n4.Kind] === "Intersect")
        return Z(A);
      if (A[n4.Kind] === "Union")
        return Q(A);
      return A;
    }
    function F(A, L) {
      const O = A.allOf.reduce((G, R) => {
        const k = P(R, L);
        return k[n4.Kind] === "Never" ? G : [...G, k];
      }, []);
      return q(n4.Type.Intersect(O));
    }
    function B(A, L) {
      const O = A.anyOf.map((G) => P(G, L));
      return q(n4.Type.Union(O));
    }
    function w(A, L) {
      const O = A.properties[L];
      return _.IsUndefined(O) ? n4.Type.Never() : n4.Type.Union([O]);
    }
    function N(A, L) {
      const O = A.items;
      if (_.IsUndefined(O))
        return n4.Type.Never();
      const G = O[L];
      if (_.IsUndefined(G))
        return n4.Type.Never();
      return G;
    }
    function P(A, L) {
      if (A[n4.Kind] === "Intersect")
        return F(A, L);
      if (A[n4.Kind] === "Union")
        return B(A, L);
      if (A[n4.Kind] === "Object")
        return w(A, L);
      if (A[n4.Kind] === "Tuple")
        return N(A, L);
      return n4.Type.Never();
    }
    function D(A, L, O = {}) {
      const G = L.map((R) => P(A, R.toString()));
      return q(n4.Type.Union(G, O));
    }
    $.Resolve = D;
  })(g$ || (n4.IndexedAccessor = g$ = {}));
  var j1;
  (function($) {
    function J(N) {
      const [P, D] = [N.slice(0, 1), N.slice(1)];
      return `${P.toLowerCase()}${D}`;
    }
    function Y(N) {
      const [P, D] = [N.slice(0, 1), N.slice(1)];
      return `${P.toUpperCase()}${D}`;
    }
    function X(N) {
      return N.toUpperCase();
    }
    function Z(N) {
      return N.toLowerCase();
    }
    function Q(N, P) {
      const D = C1.ParseExact(N.pattern);
      if (!I1.Check(D))
        return { ...N, pattern: q(N.pattern, P) };
      const O = [...b1.Generate(D)].map((k) => n4.Type.Literal(k)), G = F(O, P), R = n4.Type.Union(G);
      return n4.Type.TemplateLiteral([R]);
    }
    function q(N, P) {
      return typeof N === "string" ? P === "Uncapitalize" ? J(N) : P === "Capitalize" ? Y(N) : P === "Uppercase" ? X(N) : P === "Lowercase" ? Z(N) : N : N.toString();
    }
    function F(N, P) {
      if (N.length === 0)
        return [];
      const [D, ...A] = N;
      return [w(D, P), ...F(A, P)];
    }
    function B(N, P) {
      if (M.TTemplateLiteral(N))
        return Q(N, P);
      if (M.TUnion(N))
        return n4.Type.Union(F(N.anyOf, P));
      if (M.TLiteral(N))
        return n4.Type.Literal(q(N.const, P));
      return N;
    }
    function w(N, P) {
      return B(N, P);
    }
    $.Map = w;
  })(j1 || (n4.Intrinsic = j1 = {}));
  var S1;
  (function($) {
    function J(q, F) {
      return n4.Type.Intersect(q.allOf.map((B) => Z(B, F)), { ...q });
    }
    function Y(q, F) {
      return n4.Type.Union(q.anyOf.map((B) => Z(B, F)), { ...q });
    }
    function X(q, F) {
      return F(q);
    }
    function Z(q, F) {
      if (q[n4.Kind] === "Intersect")
        return J(q, F);
      if (q[n4.Kind] === "Union")
        return Y(q, F);
      if (q[n4.Kind] === "Object")
        return X(q, F);
      return q;
    }
    function Q(q, F, B) {
      return { ...Z(g.Clone(q), F), ...B };
    }
    $.Map = Q;
  })(S1 || (n4.ObjectMap = S1 = {}));
  var Y$;
  (function($) {
    function J(w) {
      return w[0] === "^" && w[w.length - 1] === "$" ? w.slice(1, w.length - 1) : w;
    }
    function Y(w, N) {
      return w.allOf.reduce((P, D) => [...P, ...q(D, N)], []);
    }
    function X(w, N) {
      const P = w.anyOf.map((D) => q(D, N));
      return [...P.reduce((D, A) => A.map((L) => P.every((O) => O.includes(L)) ? D.add(L) : D)[0], new Set)];
    }
    function Z(w, N) {
      return Object.getOwnPropertyNames(w.properties);
    }
    function Q(w, N) {
      return N.includePatterns ? Object.getOwnPropertyNames(w.patternProperties) : [];
    }
    function q(w, N) {
      if (M.TIntersect(w))
        return Y(w, N);
      if (M.TUnion(w))
        return X(w, N);
      if (M.TObject(w))
        return Z(w, N);
      if (M.TRecord(w))
        return Q(w, N);
      return [];
    }
    function F(w, N) {
      return [...new Set(q(w, N))];
    }
    $.ResolveKeys = F;
    function B(w) {
      return `^(${F(w, { includePatterns: true }).map((D) => `(${J(D)})`).join("|")})$`;
    }
    $.ResolvePattern = B;
  })(Y$ || (n4.KeyResolver = Y$ = {}));
  var d1;
  (function($) {
    function J(Y) {
      if (Array.isArray(Y))
        return Y;
      if (M.TUnionLiteral(Y))
        return Y.anyOf.map((X) => X.const.toString());
      if (M.TLiteral(Y))
        return [Y.const];
      if (M.TTemplateLiteral(Y)) {
        const X = C1.ParseExact(Y.pattern);
        if (!I1.Check(X))
          throw Error("KeyArrayResolver: Cannot resolve keys from infinite template expression");
        return [...b1.Generate(X)];
      }
      return [];
    }
    $.Resolve = J;
  })(d1 || (n4.KeyArrayResolver = d1 = {}));
  var f$;
  (function($) {
    function* J(X) {
      for (let Z of X.anyOf)
        if (Z[n4.Kind] === "Union")
          yield* J(Z);
        else
          yield Z;
    }
    function Y(X) {
      return n4.Type.Union([...J(X)], { ...X });
    }
    $.Resolve = Y;
  })(f$ || (n4.UnionResolver = f$ = {}));
  var X$;
  (function($) {
    function J(Z) {
      return Z.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function Y(Z, Q) {
      if (M.TTemplateLiteral(Z))
        return Z.pattern.slice(1, Z.pattern.length - 1);
      else if (M.TUnion(Z))
        return `(${Z.anyOf.map((q) => Y(q, Q)).join("|")})`;
      else if (M.TNumber(Z))
        return `${Q}${n4.PatternNumber}`;
      else if (M.TInteger(Z))
        return `${Q}${n4.PatternNumber}`;
      else if (M.TBigInt(Z))
        return `${Q}${n4.PatternNumber}`;
      else if (M.TString(Z))
        return `${Q}${n4.PatternString}`;
      else if (M.TLiteral(Z))
        return `${Q}${J(Z.const.toString())}`;
      else if (M.TBoolean(Z))
        return `${Q}${n4.PatternBoolean}`;
      else if (M.TNever(Z))
        throw Error("TemplateLiteralPattern: TemplateLiteral cannot operate on types of TNever");
      else
        throw Error(`TemplateLiteralPattern: Unexpected Kind '${Z[n4.Kind]}'`);
    }
    function X(Z) {
      return `^${Z.map((Q) => Y(Q, "")).join("")}\$`;
    }
    $.Create = X;
  })(X$ || (n4.TemplateLiteralPattern = X$ = {}));
  var v0;
  (function($) {
    function J(Y) {
      const X = C1.ParseExact(Y.pattern);
      if (!I1.Check(X))
        return n4.Type.String();
      const Z = [...b1.Generate(X)].map((Q) => n4.Type.Literal(Q));
      return n4.Type.Union(Z);
    }
    $.Resolve = J;
  })(v0 || (n4.TemplateLiteralResolver = v0 = {}));

  class Z$ extends Error {
    constructor($) {
      super($);
    }
  }
  n4.TemplateLiteralParserError = Z$;
  var C1;
  (function($) {
    function J(A, L, O) {
      return A[L] === O && A.charCodeAt(L - 1) !== 92;
    }
    function Y(A, L) {
      return J(A, L, "(");
    }
    function X(A, L) {
      return J(A, L, ")");
    }
    function Z(A, L) {
      return J(A, L, "|");
    }
    function Q(A) {
      if (!(Y(A, 0) && X(A, A.length - 1)))
        return false;
      let L = 0;
      for (let O = 0;O < A.length; O++) {
        if (Y(A, O))
          L += 1;
        if (X(A, O))
          L -= 1;
        if (L === 0 && O !== A.length - 1)
          return false;
      }
      return true;
    }
    function q(A) {
      return A.slice(1, A.length - 1);
    }
    function F(A) {
      let L = 0;
      for (let O = 0;O < A.length; O++) {
        if (Y(A, O))
          L += 1;
        if (X(A, O))
          L -= 1;
        if (Z(A, O) && L === 0)
          return true;
      }
      return false;
    }
    function B(A) {
      for (let L = 0;L < A.length; L++)
        if (Y(A, L))
          return true;
      return false;
    }
    function w(A) {
      let [L, O] = [0, 0];
      const G = [];
      for (let k = 0;k < A.length; k++) {
        if (Y(A, k))
          L += 1;
        if (X(A, k))
          L -= 1;
        if (Z(A, k) && L === 0) {
          const y = A.slice(O, k);
          if (y.length > 0)
            G.push(P(y));
          O = k + 1;
        }
      }
      const R = A.slice(O);
      if (R.length > 0)
        G.push(P(R));
      if (G.length === 0)
        return { type: "const", const: "" };
      if (G.length === 1)
        return G[0];
      return { type: "or", expr: G };
    }
    function N(A) {
      function L(R, k) {
        if (!Y(R, k))
          throw new Z$("TemplateLiteralParser: Index must point to open parens");
        let y = 0;
        for (let S = k;S < R.length; S++) {
          if (Y(R, S))
            y += 1;
          if (X(R, S))
            y -= 1;
          if (y === 0)
            return [k, S];
        }
        throw new Z$("TemplateLiteralParser: Unclosed group parens in expression");
      }
      function O(R, k) {
        for (let y = k;y < R.length; y++)
          if (Y(R, y))
            return [k, y];
        return [k, R.length];
      }
      const G = [];
      for (let R = 0;R < A.length; R++)
        if (Y(A, R)) {
          const [k, y] = L(A, R), S = A.slice(k, y + 1);
          G.push(P(S)), R = y;
        } else {
          const [k, y] = O(A, R), S = A.slice(k, y);
          if (S.length > 0)
            G.push(P(S));
          R = y - 1;
        }
      if (G.length === 0)
        return { type: "const", const: "" };
      if (G.length === 1)
        return G[0];
      return { type: "and", expr: G };
    }
    function P(A) {
      if (Q(A))
        return P(q(A));
      if (F(A))
        return w(A);
      if (B(A))
        return N(A);
      return { type: "const", const: A };
    }
    $.Parse = P;
    function D(A) {
      return P(A.slice(1, A.length - 1));
    }
    $.ParseExact = D;
  })(C1 || (n4.TemplateLiteralParser = C1 = {}));
  var I1;
  (function($) {
    function J(Q) {
      return Q.type === "or" && Q.expr.length === 2 && Q.expr[0].type === "const" && Q.expr[0].const === "0" && Q.expr[1].type === "const" && Q.expr[1].const === "[1-9][0-9]*";
    }
    function Y(Q) {
      return Q.type === "or" && Q.expr.length === 2 && Q.expr[0].type === "const" && Q.expr[0].const === "true" && Q.expr[1].type === "const" && Q.expr[1].const === "false";
    }
    function X(Q) {
      return Q.type === "const" && Q.const === ".*";
    }
    function Z(Q) {
      if (Y(Q))
        return true;
      if (J(Q) || X(Q))
        return false;
      if (Q.type === "and")
        return Q.expr.every((q) => Z(q));
      if (Q.type === "or")
        return Q.expr.every((q) => Z(q));
      if (Q.type === "const")
        return true;
      throw Error("TemplateLiteralFinite: Unknown expression type");
    }
    $.Check = Z;
  })(I1 || (n4.TemplateLiteralFinite = I1 = {}));
  var b1;
  (function($) {
    function* J(q) {
      if (q.length === 1)
        return yield* q[0];
      for (let F of q[0])
        for (let B of J(q.slice(1)))
          yield `${F}${B}`;
    }
    function* Y(q) {
      return yield* J(q.expr.map((F) => [...Q(F)]));
    }
    function* X(q) {
      for (let F of q.expr)
        yield* Q(F);
    }
    function* Z(q) {
      return yield q.const;
    }
    function* Q(q) {
      if (q.type === "and")
        return yield* Y(q);
      if (q.type === "or")
        return yield* X(q);
      if (q.type === "const")
        return yield* Z(q);
      throw Error("TemplateLiteralGenerator: Unknown expression");
    }
    $.Generate = Q;
  })(b1 || (n4.TemplateLiteralGenerator = b1 = {}));
  var T$;
  (function($) {
    function* J(Q) {
      const q = Q.trim().replace(/"|'/g, "");
      if (q === "boolean")
        return yield n4.Type.Boolean();
      if (q === "number")
        return yield n4.Type.Number();
      if (q === "bigint")
        return yield n4.Type.BigInt();
      if (q === "string")
        return yield n4.Type.String();
      const F = q.split("|").map((B) => n4.Type.Literal(B.trim()));
      return yield F.length === 0 ? n4.Type.Never() : F.length === 1 ? F[0] : n4.Type.Union(F);
    }
    function* Y(Q) {
      if (Q[1] !== "{") {
        const q = n4.Type.Literal("$"), F = X(Q.slice(1));
        return yield* [q, ...F];
      }
      for (let q = 2;q < Q.length; q++)
        if (Q[q] === "}") {
          const F = J(Q.slice(2, q)), B = X(Q.slice(q + 1));
          return yield* [...F, ...B];
        }
      yield n4.Type.Literal(Q);
    }
    function* X(Q) {
      for (let q = 0;q < Q.length; q++)
        if (Q[q] === "$") {
          const F = n4.Type.Literal(Q.slice(0, q)), B = Y(Q.slice(q));
          return yield* [F, ...B];
        }
      yield n4.Type.Literal(Q);
    }
    function Z(Q) {
      return [...X(Q)];
    }
    $.Parse = Z;
  })(T$ || (n4.TemplateLiteralDslParser = T$ = {}));
  var h6 = 0;

  class d$ {
    Create($) {
      return $;
    }
    Discard($, J) {
      const { [J]: Y, ...X } = $;
      return X;
    }
    Strict($) {
      return JSON.parse(JSON.stringify($));
    }
  }
  n4.TypeBuilder = d$;

  class W$ extends d$ {
    ReadonlyOptional($) {
      return this.Readonly(this.Optional($));
    }
    Readonly($) {
      return { ...g.Clone($), [n4.Readonly]: "Readonly" };
    }
    Optional($) {
      return { ...g.Clone($), [n4.Optional]: "Optional" };
    }
    Any($ = {}) {
      return this.Create({ ...$, [n4.Kind]: "Any" });
    }
    Array($, J = {}) {
      return this.Create({ ...J, [n4.Kind]: "Array", type: "array", items: g.Clone($) });
    }
    Boolean($ = {}) {
      return this.Create({ ...$, [n4.Kind]: "Boolean", type: "boolean" });
    }
    Capitalize($, J = {}) {
      return { ...j1.Map(g.Clone($), "Capitalize"), ...J };
    }
    Composite($, J) {
      const Y = n4.Type.Intersect($, {}), Z = Y$.ResolveKeys(Y, { includePatterns: false }).reduce((Q, q) => ({ ...Q, [q]: n4.Type.Index(Y, [q]) }), {});
      return n4.Type.Object(Z, J);
    }
    Enum($, J = {}) {
      const X = Object.getOwnPropertyNames($).filter((Z) => isNaN(Z)).map((Z) => $[Z]).map((Z) => _.IsString(Z) ? { [n4.Kind]: "Literal", type: "string", const: Z } : { [n4.Kind]: "Literal", type: "number", const: Z });
      return this.Create({ ...J, [n4.Kind]: "Union", anyOf: X });
    }
    Extends($, J, Y, X, Z = {}) {
      switch (H1.Extends($, J)) {
        case K.Union:
          return this.Union([g.Clone(Y, Z), g.Clone(X, Z)]);
        case K.True:
          return g.Clone(Y, Z);
        case K.False:
          return g.Clone(X, Z);
      }
    }
    Exclude($, J, Y = {}) {
      if (M.TTemplateLiteral($))
        return this.Exclude(v0.Resolve($), J, Y);
      if (M.TTemplateLiteral(J))
        return this.Exclude($, v0.Resolve(J), Y);
      if (M.TUnion($)) {
        const X = $.anyOf.filter((Z) => H1.Extends(Z, J) === K.False);
        return X.length === 1 ? g.Clone(X[0], Y) : this.Union(X, Y);
      } else
        return H1.Extends($, J) !== K.False ? this.Never(Y) : g.Clone($, Y);
    }
    Extract($, J, Y = {}) {
      if (M.TTemplateLiteral($))
        return this.Extract(v0.Resolve($), J, Y);
      if (M.TTemplateLiteral(J))
        return this.Extract($, v0.Resolve(J), Y);
      if (M.TUnion($)) {
        const X = $.anyOf.filter((Z) => H1.Extends(Z, J) !== K.False);
        return X.length === 1 ? g.Clone(X[0], Y) : this.Union(X, Y);
      } else
        return H1.Extends($, J) !== K.False ? g.Clone($, Y) : this.Never(Y);
    }
    Index($, J, Y = {}) {
      if (M.TArray($) && M.TNumber(J))
        return g.Clone($.items, Y);
      else if (M.TTuple($) && M.TNumber(J)) {
        const Z = (_.IsUndefined($.items) ? [] : $.items).map((Q) => g.Clone(Q));
        return this.Union(Z, Y);
      } else {
        const X = d1.Resolve(J), Z = g.Clone($);
        return g$.Resolve(Z, X, Y);
      }
    }
    Integer($ = {}) {
      return this.Create({ ...$, [n4.Kind]: "Integer", type: "integer" });
    }
    Intersect($, J = {}) {
      if ($.length === 0)
        return n4.Type.Never();
      if ($.length === 1)
        return g.Clone($[0], J);
      const Y = $.every((Q) => M.TObject(Q)), X = $.map((Q) => g.Clone(Q)), Z = M.TSchema(J.unevaluatedProperties) ? { unevaluatedProperties: g.Clone(J.unevaluatedProperties) } : {};
      if (J.unevaluatedProperties === false || M.TSchema(J.unevaluatedProperties) || Y)
        return this.Create({ ...J, ...Z, [n4.Kind]: "Intersect", type: "object", allOf: X });
      else
        return this.Create({ ...J, ...Z, [n4.Kind]: "Intersect", allOf: X });
    }
    KeyOf($, J = {}) {
      if (M.TRecord($)) {
        const Y = Object.getOwnPropertyNames($.patternProperties)[0];
        if (Y === n4.PatternNumberExact)
          return this.Number(J);
        if (Y === n4.PatternStringExact)
          return this.String(J);
        throw Error("StandardTypeBuilder: Unable to resolve key type from Record key pattern");
      } else if (M.TTuple($)) {
        const X = (_.IsUndefined($.items) ? [] : $.items).map((Z, Q) => n4.Type.Literal(Q));
        return this.Union(X, J);
      } else if (M.TArray($))
        return this.Number(J);
      else {
        const Y = Y$.ResolveKeys($, { includePatterns: false });
        if (Y.length === 0)
          return this.Never(J);
        const X = Y.map((Z) => this.Literal(Z));
        return this.Union(X, J);
      }
    }
    Literal($, J = {}) {
      return this.Create({ ...J, [n4.Kind]: "Literal", const: $, type: typeof $ });
    }
    Lowercase($, J = {}) {
      return { ...j1.Map(g.Clone($), "Lowercase"), ...J };
    }
    Never($ = {}) {
      return this.Create({ ...$, [n4.Kind]: "Never", not: {} });
    }
    Not($, J) {
      return this.Create({ ...J, [n4.Kind]: "Not", not: g.Clone($) });
    }
    Null($ = {}) {
      return this.Create({ ...$, [n4.Kind]: "Null", type: "null" });
    }
    Number($ = {}) {
      return this.Create({ ...$, [n4.Kind]: "Number", type: "number" });
    }
    Object($, J = {}) {
      const Y = Object.getOwnPropertyNames($), X = Y.filter((F) => M.TOptional($[F])), Z = Y.filter((F) => !X.includes(F)), Q = M.TSchema(J.additionalProperties) ? { additionalProperties: g.Clone(J.additionalProperties) } : {}, q = Y.reduce((F, B) => ({ ...F, [B]: g.Clone($[B]) }), {});
      if (Z.length > 0)
        return this.Create({ ...J, ...Q, [n4.Kind]: "Object", type: "object", properties: q, required: Z });
      else
        return this.Create({ ...J, ...Q, [n4.Kind]: "Object", type: "object", properties: q });
    }
    Omit($, J, Y = {}) {
      const X = d1.Resolve(J);
      return S1.Map(g.Clone($), (Z) => {
        if (_.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((Q) => !X.includes(Q)), Z.required.length === 0)
            delete Z.required;
        }
        for (let Q of Object.getOwnPropertyNames(Z.properties))
          if (X.includes(Q))
            delete Z.properties[Q];
        return this.Create(Z);
      }, Y);
    }
    Partial($, J = {}) {
      return S1.Map($, (Y) => {
        const X = Object.getOwnPropertyNames(Y.properties).reduce((Z, Q) => {
          return { ...Z, [Q]: this.Optional(Y.properties[Q]) };
        }, {});
        return this.Object(X, this.Discard(Y, "required"));
      }, J);
    }
    Pick($, J, Y = {}) {
      const X = d1.Resolve(J);
      return S1.Map(g.Clone($), (Z) => {
        if (_.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((Q) => X.includes(Q)), Z.required.length === 0)
            delete Z.required;
        }
        for (let Q of Object.getOwnPropertyNames(Z.properties))
          if (!X.includes(Q))
            delete Z.properties[Q];
        return this.Create(Z);
      }, Y);
    }
    Record($, J, Y = {}) {
      if (M.TTemplateLiteral($)) {
        const X = C1.ParseExact($.pattern);
        return I1.Check(X) ? this.Object([...b1.Generate(X)].reduce((Z, Q) => ({ ...Z, [Q]: g.Clone(J) }), {}), Y) : this.Create({ ...Y, [n4.Kind]: "Record", type: "object", patternProperties: { [$.pattern]: g.Clone(J) } });
      } else if (M.TUnion($)) {
        const X = f$.Resolve($);
        if (M.TUnionLiteral(X)) {
          const Z = X.anyOf.reduce((Q, q) => ({ ...Q, [q.const]: g.Clone(J) }), {});
          return this.Object(Z, { ...Y, [n4.Hint]: "Record" });
        } else
          throw Error("StandardTypeBuilder: Record key of type union contains non-literal types");
      } else if (M.TLiteral($))
        if (_.IsString($.const) || _.IsNumber($.const))
          return this.Object({ [$.const]: g.Clone(J) }, Y);
        else
          throw Error("StandardTypeBuilder: Record key of type literal is not of type string or number");
      else if (M.TInteger($) || M.TNumber($))
        return this.Create({ ...Y, [n4.Kind]: "Record", type: "object", patternProperties: { [n4.PatternNumberExact]: g.Clone(J) } });
      else if (M.TString($)) {
        const X = _.IsUndefined($.pattern) ? n4.PatternStringExact : $.pattern;
        return this.Create({ ...Y, [n4.Kind]: "Record", type: "object", patternProperties: { [X]: g.Clone(J) } });
      } else
        throw Error("StandardTypeBuilder: Record key is an invalid type");
    }
    Recursive($, J = {}) {
      if (_.IsUndefined(J.$id))
        J.$id = `T${h6++}`;
      const Y = $({ [n4.Kind]: "This", $ref: `${J.$id}` });
      return Y.$id = J.$id, this.Create({ ...J, [n4.Hint]: "Recursive", ...Y });
    }
    Ref($, J = {}) {
      if (_.IsString($))
        return this.Create({ ...J, [n4.Kind]: "Ref", $ref: $ });
      if (_.IsUndefined($.$id))
        throw Error("StandardTypeBuilder.Ref: Target type must specify an $id");
      return this.Create({ ...J, [n4.Kind]: "Ref", $ref: $.$id });
    }
    Required($, J = {}) {
      return S1.Map($, (Y) => {
        const X = Object.getOwnPropertyNames(Y.properties).reduce((Z, Q) => {
          return { ...Z, [Q]: this.Discard(Y.properties[Q], n4.Optional) };
        }, {});
        return this.Object(X, Y);
      }, J);
    }
    Rest($) {
      if (M.TTuple($)) {
        if (_.IsUndefined($.items))
          return [];
        return $.items.map((J) => g.Clone(J));
      } else
        return [g.Clone($)];
    }
    String($ = {}) {
      return this.Create({ ...$, [n4.Kind]: "String", type: "string" });
    }
    TemplateLiteral($, J = {}) {
      const Y = _.IsString($) ? X$.Create(T$.Parse($)) : X$.Create($);
      return this.Create({ ...J, [n4.Kind]: "TemplateLiteral", type: "string", pattern: Y });
    }
    Tuple($, J = {}) {
      const [Y, X, Z] = [false, $.length, $.length], Q = $.map((F) => g.Clone(F)), q = $.length > 0 ? { ...J, [n4.Kind]: "Tuple", type: "array", items: Q, additionalItems: Y, minItems: X, maxItems: Z } : { ...J, [n4.Kind]: "Tuple", type: "array", minItems: X, maxItems: Z };
      return this.Create(q);
    }
    Uncapitalize($, J = {}) {
      return { ...j1.Map(g.Clone($), "Uncapitalize"), ...J };
    }
    Union($, J = {}) {
      if (M.TTemplateLiteral($))
        return v0.Resolve($);
      else {
        const Y = $;
        if (Y.length === 0)
          return this.Never(J);
        if (Y.length === 1)
          return this.Create(g.Clone(Y[0], J));
        const X = Y.map((Z) => g.Clone(Z));
        return this.Create({ ...J, [n4.Kind]: "Union", anyOf: X });
      }
    }
    Unknown($ = {}) {
      return this.Create({ ...$, [n4.Kind]: "Unknown" });
    }
    Unsafe($ = {}) {
      return this.Create({ ...$, [n4.Kind]: $[n4.Kind] || "Unsafe" });
    }
    Uppercase($, J = {}) {
      return { ...j1.Map(g.Clone($), "Uppercase"), ...J };
    }
  }
  n4.StandardTypeBuilder = W$;

  class y$ extends W$ {
    AsyncIterator($, J = {}) {
      return this.Create({ ...J, [n4.Kind]: "AsyncIterator", type: "AsyncIterator", items: g.Clone($) });
    }
    Awaited($, J = {}) {
      const Y = (X) => {
        if (X.length === 0)
          return X;
        const [Z, ...Q] = X;
        return [this.Awaited(Z), ...Y(Q)];
      };
      return M.TIntersect($) ? n4.Type.Intersect(Y($.allOf)) : M.TUnion($) ? n4.Type.Union(Y($.anyOf)) : M.TPromise($) ? this.Awaited($.item) : g.Clone($, J);
    }
    BigInt($ = {}) {
      return this.Create({ ...$, [n4.Kind]: "BigInt", type: "bigint" });
    }
    ConstructorParameters($, J = {}) {
      return this.Tuple([...$.parameters], { ...J });
    }
    Constructor($, J, Y) {
      const X = g.Clone(J), Z = $.map((Q) => g.Clone(Q));
      return this.Create({ ...Y, [n4.Kind]: "Constructor", type: "constructor", parameters: Z, returns: X });
    }
    Date($ = {}) {
      return this.Create({ ...$, [n4.Kind]: "Date", type: "Date" });
    }
    Function($, J, Y) {
      const X = g.Clone(J, {}), Z = $.map((Q) => g.Clone(Q));
      return this.Create({ ...Y, [n4.Kind]: "Function", type: "function", parameters: Z, returns: X });
    }
    InstanceType($, J = {}) {
      return g.Clone($.returns, J);
    }
    Iterator($, J = {}) {
      return this.Create({ ...J, [n4.Kind]: "Iterator", type: "Iterator", items: g.Clone($) });
    }
    Parameters($, J = {}) {
      return this.Tuple($.parameters, { ...J });
    }
    Promise($, J = {}) {
      return this.Create({ ...J, [n4.Kind]: "Promise", type: "Promise", item: g.Clone($) });
    }
    RegExp($, J = {}) {
      const Y = _.IsString($) ? $ : $.source;
      return this.Create({ ...J, [n4.Kind]: "String", type: "string", pattern: Y });
    }
    RegEx($, J = {}) {
      return this.RegExp($, J);
    }
    ReturnType($, J = {}) {
      return g.Clone($.returns, J);
    }
    Symbol($) {
      return this.Create({ ...$, [n4.Kind]: "Symbol", type: "symbol" });
    }
    Undefined($ = {}) {
      return this.Create({ ...$, [n4.Kind]: "Undefined", type: "undefined" });
    }
    Uint8Array($ = {}) {
      return this.Create({ ...$, [n4.Kind]: "Uint8Array", type: "Uint8Array" });
    }
    Void($ = {}) {
      return this.Create({ ...$, [n4.Kind]: "Void", type: "void" });
    }
  }
  n4.ExtendedTypeBuilder = y$;
  n4.StandardType = new W$;
  n4.Type = new y$;
});
var l4 = l((h4) => {
  Object.defineProperty(h4, "__esModule", { value: true });
  h4.TypeSystem = h4.TypeSystemDuplicateFormat = h4.TypeSystemDuplicateTypeKind = undefined;
  var _1 = G0();

  class m$ extends Error {
    constructor($) {
      super(`Duplicate type kind '${$}' detected`);
    }
  }
  h4.TypeSystemDuplicateTypeKind = m$;

  class o$ extends Error {
    constructor($) {
      super(`Duplicate string format '${$}' detected`);
    }
  }
  h4.TypeSystemDuplicateFormat = o$;
  var u4;
  (function($) {
    $.ExactOptionalPropertyTypes = false, $.AllowArrayObjects = false, $.AllowNaN = false, $.AllowVoidNull = false;
    function J(X, Z) {
      if (_1.TypeRegistry.Has(X))
        throw new m$(X);
      return _1.TypeRegistry.Set(X, Z), (Q = {}) => _1.Type.Unsafe({ ...Q, [_1.Kind]: X });
    }
    $.Type = J;
    function Y(X, Z) {
      if (_1.FormatRegistry.Has(X))
        throw new o$(X);
      return _1.FormatRegistry.Set(X, Z), X;
    }
    $.Format = Y;
  })(u4 || (h4.TypeSystem = u4 = {}));
});
var i1 = l((q1) => {
  var LJ = q1 && q1.__createBinding || (Object.create ? function($, J, Y, X) {
    if (X === undefined)
      X = Y;
    var Z = Object.getOwnPropertyDescriptor(J, Y);
    if (!Z || ("get" in Z ? !J.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return J[Y];
      } };
    Object.defineProperty($, X, Z);
  } : function($, J, Y, X) {
    if (X === undefined)
      X = Y;
    $[X] = J[Y];
  }), OJ = q1 && q1.__exportStar || function($, J) {
    for (var Y in $)
      if (Y !== "default" && !Object.prototype.hasOwnProperty.call(J, Y))
        LJ(J, $, Y);
  };
  Object.defineProperty(q1, "__esModule", { value: true });
  OJ(l4(), q1);
});
var L0 = l((Y8) => {
  var CJ = function($) {
    return z$($) && (Symbol.asyncIterator in $);
  }, IJ = function($) {
    return z$($) && (Symbol.iterator in $);
  }, bJ = function($) {
    return ArrayBuffer.isView($);
  }, _J = function($) {
    return $ instanceof Promise;
  }, RJ = function($) {
    return $ instanceof Uint8Array;
  }, GJ = function($) {
    return $ instanceof Date;
  }, EJ = function($, J) {
    return J in $;
  }, xJ = function($) {
    return z$($) && $8($.constructor) && $.constructor.name === "Object";
  }, z$ = function($) {
    return $ !== null && typeof $ === "object";
  }, VJ = function($) {
    return Array.isArray($) && !ArrayBuffer.isView($);
  }, t4 = function($) {
    return $ === undefined;
  }, s4 = function($) {
    return $ === null;
  }, r4 = function($) {
    return typeof $ === "boolean";
  }, n$ = function($) {
    return typeof $ === "number";
  }, kJ = function($) {
    return n$($) && Number.isInteger($);
  }, a4 = function($) {
    return typeof $ === "bigint";
  }, e4 = function($) {
    return typeof $ === "string";
  }, $8 = function($) {
    return typeof $ === "function";
  }, J8 = function($) {
    return typeof $ === "symbol";
  }, gJ = function($) {
    return a4($) || r4($) || s4($) || n$($) || e4($) || J8($) || t4($);
  };
  Object.defineProperty(Y8, "__esModule", { value: true });
  Y8.IsValueType = Y8.IsSymbol = Y8.IsFunction = Y8.IsString = Y8.IsBigInt = Y8.IsInteger = Y8.IsNumber = Y8.IsBoolean = Y8.IsNull = Y8.IsUndefined = Y8.IsArray = Y8.IsObject = Y8.IsPlainObject = Y8.HasPropertyKey = Y8.IsDate = Y8.IsUint8Array = Y8.IsPromise = Y8.IsTypedArray = Y8.IsIterator = Y8.IsAsyncIterator = undefined;
  Y8.IsAsyncIterator = CJ;
  Y8.IsIterator = IJ;
  Y8.IsTypedArray = bJ;
  Y8.IsPromise = _J;
  Y8.IsUint8Array = RJ;
  Y8.IsDate = GJ;
  Y8.HasPropertyKey = EJ;
  Y8.IsPlainObject = xJ;
  Y8.IsObject = z$;
  Y8.IsArray = VJ;
  Y8.IsUndefined = t4;
  Y8.IsNull = s4;
  Y8.IsBoolean = r4;
  Y8.IsNumber = n$;
  Y8.IsInteger = kJ;
  Y8.IsBigInt = a4;
  Y8.IsString = e4;
  Y8.IsFunction = $8;
  Y8.IsSymbol = J8;
  Y8.IsValueType = gJ;
});
var p1 = l((z8) => {
  var XY = function($) {
    H0(K0.Array);
    for (let J of $)
      G1(J);
  }, ZY = function($) {
    H0(K0.Boolean), H0($ ? 1 : 0);
  }, QY = function($) {
    H0(K0.BigInt), Q8.setBigInt64(0, $);
    for (let J of W8)
      H0(J);
  }, WY = function($) {
    H0(K0.Date), G1($.getTime());
  }, zY = function($) {
    H0(K0.Null);
  }, HY = function($) {
    H0(K0.Number), Q8.setFloat64(0, $);
    for (let J of W8)
      H0(J);
  }, qY = function($) {
    H0(K0.Object);
    for (let J of globalThis.Object.keys($).sort())
      G1(J), G1($[J]);
  }, FY = function($) {
    H0(K0.String);
    for (let J = 0;J < $.length; J++)
      H0($.charCodeAt(J));
  }, MY = function($) {
    H0(K0.Symbol), G1($.description);
  }, UY = function($) {
    H0(K0.Uint8Array);
    for (let J = 0;J < $.length; J++)
      H0($[J]);
  }, BY = function($) {
    return H0(K0.Undefined);
  }, G1 = function($) {
    if (E0.IsArray($))
      return XY($);
    if (E0.IsBoolean($))
      return ZY($);
    if (E0.IsBigInt($))
      return QY($);
    if (E0.IsDate($))
      return WY($);
    if (E0.IsNull($))
      return zY($);
    if (E0.IsNumber($))
      return HY($);
    if (E0.IsPlainObject($))
      return qY($);
    if (E0.IsString($))
      return FY($);
    if (E0.IsSymbol($))
      return MY($);
    if (E0.IsUint8Array($))
      return UY($);
    if (E0.IsUndefined($))
      return BY($);
    throw new u$($);
  }, H0 = function($) {
    R1 = R1 ^ YY[$], R1 = R1 * $Y % JY;
  }, AY = function($) {
    return R1 = BigInt("14695981039346656037"), G1($), R1;
  };
  Object.defineProperty(z8, "__esModule", { value: true });
  z8.Hash = z8.ByteMarker = z8.ValueHashError = undefined;
  var E0 = L0();

  class u$ extends Error {
    constructor($) {
      super("Hash: Unable to hash value");
      this.value = $;
    }
  }
  z8.ValueHashError = u$;
  var K0;
  (function($) {
    $[$.Undefined = 0] = "Undefined", $[$.Null = 1] = "Null", $[$.Boolean = 2] = "Boolean", $[$.Number = 3] = "Number", $[$.String = 4] = "String", $[$.Object = 5] = "Object", $[$.Array = 6] = "Array", $[$.Date = 7] = "Date", $[$.Uint8Array = 8] = "Uint8Array", $[$.Symbol = 9] = "Symbol", $[$.BigInt = 10] = "BigInt";
  })(K0 || (z8.ByteMarker = K0 = {}));
  var R1 = BigInt("14695981039346656037"), [$Y, JY] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")], YY = Array.from({ length: 256 }).map(($, J) => BigInt(J)), Z8 = new Float64Array(1), Q8 = new DataView(Z8.buffer), W8 = new Uint8Array(Z8.buffer);
  z8.Hash = AY;
});
var M8 = l((q8) => {
  var m = function($) {
    return $ !== undefined;
  }, KY = function($, J) {
    return H$.TypeSystem.ExactOptionalPropertyTypes ? J in $ : $[J] !== undefined;
  }, t$ = function($) {
    const J = s.IsObject($);
    return H$.TypeSystem.AllowArrayObjects ? J : J && !s.IsArray($);
  }, PY = function($) {
    return t$($) && !($ instanceof Date) && !($ instanceof Uint8Array);
  }, h$ = function($) {
    const J = s.IsNumber($);
    return H$.TypeSystem.AllowNaN ? J : J && Number.isFinite($);
  }, jY = function($) {
    const J = s.IsUndefined($);
    return H$.TypeSystem.AllowVoidNull ? J || $ === null : J;
  };
  function* SY($, J, Y, X) {
  }
  function* LY($, J, Y, X) {
    if (!s.IsArray(X))
      return yield { type: I.Array, schema: $, path: Y, value: X, message: "Expected array" };
    if (m($.minItems) && !(X.length >= $.minItems))
      yield { type: I.ArrayMinItems, schema: $, path: Y, value: X, message: `Expected array length to be greater or equal to ${$.minItems}` };
    if (m($.maxItems) && !(X.length <= $.maxItems))
      yield { type: I.ArrayMinItems, schema: $, path: Y, value: X, message: `Expected array length to be less or equal to ${$.maxItems}` };
    for (let q = 0;q < X.length; q++)
      yield* Z0($.items, J, `${Y}/${q}`, X[q]);
    if ($.uniqueItems === true && !function() {
      const q = new Set;
      for (let F of X) {
        const B = DY.Hash(F);
        if (q.has(B))
          return false;
        else
          q.add(B);
      }
      return true;
    }())
      yield { type: I.ArrayUniqueItems, schema: $, path: Y, value: X, message: "Expected array elements to be unique" };
    if (!(m($.contains) || h$($.minContains) || h$($.maxContains)))
      return;
    const Z = m($.contains) ? $.contains : O0.Type.Never(), Q = X.reduce((q, F, B) => Z0(Z, J, `${Y}${B}`, F).next().done === true ? q + 1 : q, 0);
    if (Q === 0)
      yield { type: I.ArrayContains, schema: $, path: Y, value: X, message: "Expected array to contain at least one matching type" };
    if (s.IsNumber($.minContains) && Q < $.minContains)
      yield { type: I.ArrayMinContains, schema: $, path: Y, value: X, message: `Expected array to contain at least ${$.minContains} matching types` };
    if (s.IsNumber($.maxContains) && Q > $.maxContains)
      yield { type: I.ArrayMaxContains, schema: $, path: Y, value: X, message: `Expected array to contain no more than ${$.maxContains} matching types` };
  }
  function* OY($, J, Y, X) {
    if (!s.IsAsyncIterator(X))
      yield { type: I.AsyncIterator, schema: $, path: Y, value: X, message: "Expected value to be an async iterator" };
  }
  function* CY($, J, Y, X) {
    if (!s.IsBigInt(X))
      return yield { type: I.BigInt, schema: $, path: Y, value: X, message: "Expected bigint" };
    if (m($.multipleOf) && X % $.multipleOf !== BigInt(0))
      yield { type: I.BigIntMultipleOf, schema: $, path: Y, value: X, message: `Expected bigint to be a multiple of ${$.multipleOf}` };
    if (m($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield { type: I.BigIntExclusiveMinimum, schema: $, path: Y, value: X, message: `Expected bigint to be greater than ${$.exclusiveMinimum}` };
    if (m($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield { type: I.BigIntExclusiveMaximum, schema: $, path: Y, value: X, message: `Expected bigint to be less than ${$.exclusiveMaximum}` };
    if (m($.minimum) && !(X >= $.minimum))
      yield { type: I.BigIntMinimum, schema: $, path: Y, value: X, message: `Expected bigint to be greater or equal to ${$.minimum}` };
    if (m($.maximum) && !(X <= $.maximum))
      yield { type: I.BigIntMaximum, schema: $, path: Y, value: X, message: `Expected bigint to be less or equal to ${$.maximum}` };
  }
  function* IY($, J, Y, X) {
    if (!s.IsBoolean(X))
      return yield { type: I.Boolean, schema: $, path: Y, value: X, message: "Expected boolean" };
  }
  function* bY($, J, Y, X) {
    yield* Z0($.returns, J, Y, X.prototype);
  }
  function* _Y($, J, Y, X) {
    if (!s.IsDate(X))
      return yield { type: I.Date, schema: $, path: Y, value: X, message: "Expected Date object" };
    if (!isFinite(X.getTime()))
      return yield { type: I.Date, schema: $, path: Y, value: X, message: "Invalid Date" };
    if (m($.exclusiveMinimumTimestamp) && !(X.getTime() > $.exclusiveMinimumTimestamp))
      yield { type: I.DateExclusiveMinimumTimestamp, schema: $, path: Y, value: X, message: `Expected Date timestamp to be greater than ${$.exclusiveMinimum}` };
    if (m($.exclusiveMaximumTimestamp) && !(X.getTime() < $.exclusiveMaximumTimestamp))
      yield { type: I.DateExclusiveMaximumTimestamp, schema: $, path: Y, value: X, message: `Expected Date timestamp to be less than ${$.exclusiveMaximum}` };
    if (m($.minimumTimestamp) && !(X.getTime() >= $.minimumTimestamp))
      yield { type: I.DateMinimumTimestamp, schema: $, path: Y, value: X, message: `Expected Date timestamp to be greater or equal to ${$.minimum}` };
    if (m($.maximumTimestamp) && !(X.getTime() <= $.maximumTimestamp))
      yield { type: I.DateMaximumTimestamp, schema: $, path: Y, value: X, message: `Expected Date timestamp to be less or equal to ${$.maximum}` };
  }
  function* RY($, J, Y, X) {
    if (!s.IsFunction(X))
      return yield { type: I.Function, schema: $, path: Y, value: X, message: "Expected function" };
  }
  function* GY($, J, Y, X) {
    if (!s.IsInteger(X))
      return yield { type: I.Integer, schema: $, path: Y, value: X, message: "Expected integer" };
    if (m($.multipleOf) && X % $.multipleOf !== 0)
      yield { type: I.IntegerMultipleOf, schema: $, path: Y, value: X, message: `Expected integer to be a multiple of ${$.multipleOf}` };
    if (m($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield { type: I.IntegerExclusiveMinimum, schema: $, path: Y, value: X, message: `Expected integer to be greater than ${$.exclusiveMinimum}` };
    if (m($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield { type: I.IntegerExclusiveMaximum, schema: $, path: Y, value: X, message: `Expected integer to be less than ${$.exclusiveMaximum}` };
    if (m($.minimum) && !(X >= $.minimum))
      yield { type: I.IntegerMinimum, schema: $, path: Y, value: X, message: `Expected integer to be greater or equal to ${$.minimum}` };
    if (m($.maximum) && !(X <= $.maximum))
      yield { type: I.IntegerMaximum, schema: $, path: Y, value: X, message: `Expected integer to be less or equal to ${$.maximum}` };
  }
  function* EY($, J, Y, X) {
    for (let Z of $.allOf) {
      const Q = Z0(Z, J, Y, X).next();
      if (!Q.done) {
        yield Q.value, yield { type: I.Intersect, schema: $, path: Y, value: X, message: "Expected all sub schemas to be valid" };
        return;
      }
    }
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp(O0.KeyResolver.ResolvePattern($));
      for (let Q of Object.getOwnPropertyNames(X))
        if (!Z.test(Q))
          yield { type: I.IntersectUnevaluatedProperties, schema: $, path: `${Y}/${Q}`, value: X, message: "Unexpected property" };
    }
    if (typeof $.unevaluatedProperties === "object") {
      const Z = new RegExp(O0.KeyResolver.ResolvePattern($));
      for (let Q of Object.getOwnPropertyNames(X))
        if (!Z.test(Q)) {
          const q = Z0($.unevaluatedProperties, J, `${Y}/${Q}`, X[Q]).next();
          if (!q.done) {
            yield q.value, yield { type: I.IntersectUnevaluatedProperties, schema: $, path: `${Y}/${Q}`, value: X, message: "Invalid additional property" };
            return;
          }
        }
    }
  }
  function* xY($, J, Y, X) {
    if (!(t$(X) && (Symbol.iterator in X)))
      yield { type: I.Iterator, schema: $, path: Y, value: X, message: "Expected value to be an iterator" };
  }
  function* VY($, J, Y, X) {
    if (X !== $.const) {
      const Z = typeof $.const === "string" ? `'${$.const}'` : $.const;
      return yield { type: I.Literal, schema: $, path: Y, value: X, message: `Expected ${Z}` };
    }
  }
  function* kY($, J, Y, X) {
    yield { type: I.Never, schema: $, path: Y, value: X, message: "Value cannot be validated" };
  }
  function* gY($, J, Y, X) {
    if (Z0($.not, J, Y, X).next().done === true)
      yield { type: I.Not, schema: $, path: Y, value: X, message: "Value should not validate" };
  }
  function* fY($, J, Y, X) {
    if (!s.IsNull(X))
      return yield { type: I.Null, schema: $, path: Y, value: X, message: "Expected null" };
  }
  function* TY($, J, Y, X) {
    if (!h$(X))
      return yield { type: I.Number, schema: $, path: Y, value: X, message: "Expected number" };
    if (m($.multipleOf) && X % $.multipleOf !== 0)
      yield { type: I.NumberMultipleOf, schema: $, path: Y, value: X, message: `Expected number to be a multiple of ${$.multipleOf}` };
    if (m($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield { type: I.NumberExclusiveMinimum, schema: $, path: Y, value: X, message: `Expected number to be greater than ${$.exclusiveMinimum}` };
    if (m($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield { type: I.NumberExclusiveMaximum, schema: $, path: Y, value: X, message: `Expected number to be less than ${$.exclusiveMaximum}` };
    if (m($.minimum) && !(X >= $.minimum))
      yield { type: I.NumberMinimum, schema: $, path: Y, value: X, message: `Expected number to be greater or equal to ${$.minimum}` };
    if (m($.maximum) && !(X <= $.maximum))
      yield { type: I.NumberMaximum, schema: $, path: Y, value: X, message: `Expected number to be less or equal to ${$.maximum}` };
  }
  function* dY($, J, Y, X) {
    if (!t$(X))
      return yield { type: I.Object, schema: $, path: Y, value: X, message: "Expected object" };
    if (m($.minProperties) && !(Object.getOwnPropertyNames(X).length >= $.minProperties))
      yield { type: I.ObjectMinProperties, schema: $, path: Y, value: X, message: `Expected object to have at least ${$.minProperties} properties` };
    if (m($.maxProperties) && !(Object.getOwnPropertyNames(X).length <= $.maxProperties))
      yield { type: I.ObjectMaxProperties, schema: $, path: Y, value: X, message: `Expected object to have no more than ${$.maxProperties} properties` };
    const Z = Array.isArray($.required) ? $.required : [], Q = Object.getOwnPropertyNames($.properties), q = Object.getOwnPropertyNames(X);
    for (let F of Q) {
      const B = $.properties[F];
      if ($.required && $.required.includes(F)) {
        if (yield* Z0(B, J, `${Y}/${F}`, X[F]), O0.ExtendsUndefined.Check($) && !(F in X))
          yield { type: I.ObjectRequiredProperties, schema: B, path: `${Y}/${F}`, value: undefined, message: "Expected required property" };
      } else if (KY(X, F))
        yield* Z0(B, J, `${Y}/${F}`, X[F]);
    }
    for (let F of Z) {
      if (q.includes(F))
        continue;
      yield { type: I.ObjectRequiredProperties, schema: $.properties[F], path: `${Y}/${F}`, value: undefined, message: "Expected required property" };
    }
    if ($.additionalProperties === false) {
      for (let F of q)
        if (!Q.includes(F))
          yield { type: I.ObjectAdditionalProperties, schema: $, path: `${Y}/${F}`, value: X[F], message: "Unexpected property" };
    }
    if (typeof $.additionalProperties === "object")
      for (let F of q) {
        if (Q.includes(F))
          continue;
        yield* Z0($.additionalProperties, J, `${Y}/${F}`, X[F]);
      }
  }
  function* yY($, J, Y, X) {
    if (!s.IsPromise(X))
      yield { type: I.Promise, schema: $, path: Y, value: X, message: "Expected Promise" };
  }
  function* vY($, J, Y, X) {
    if (!PY(X))
      return yield { type: I.Object, schema: $, path: Y, value: X, message: "Expected record object" };
    if (m($.minProperties) && !(Object.getOwnPropertyNames(X).length >= $.minProperties))
      yield { type: I.ObjectMinProperties, schema: $, path: Y, value: X, message: `Expected object to have at least ${$.minProperties} properties` };
    if (m($.maxProperties) && !(Object.getOwnPropertyNames(X).length <= $.maxProperties))
      yield { type: I.ObjectMaxProperties, schema: $, path: Y, value: X, message: `Expected object to have no more than ${$.maxProperties} properties` };
    const [Z, Q] = Object.entries($.patternProperties)[0], q = new RegExp(Z);
    for (let [F, B] of Object.entries(X)) {
      if (q.test(F)) {
        yield* Z0(Q, J, `${Y}/${F}`, B);
        continue;
      }
      if (typeof $.additionalProperties === "object")
        yield* Z0($.additionalProperties, J, `${Y}/${F}`, B);
      if ($.additionalProperties === false) {
        const w = `${Y}/${F}`, N = `Unexpected property '${w}'`;
        return yield { type: I.ObjectAdditionalProperties, schema: $, path: w, value: B, message: N };
      }
    }
  }
  function* iY($, J, Y, X) {
    const Z = J.findIndex((q) => q.$id === $.$ref);
    if (Z === -1)
      throw new q$($);
    const Q = J[Z];
    yield* Z0(Q, J, Y, X);
  }
  function* pY($, J, Y, X) {
    if (!s.IsString(X))
      return yield { type: I.String, schema: $, path: Y, value: X, message: "Expected string" };
    if (m($.minLength) && !(X.length >= $.minLength))
      yield { type: I.StringMinLength, schema: $, path: Y, value: X, message: `Expected string length greater or equal to ${$.minLength}` };
    if (m($.maxLength) && !(X.length <= $.maxLength))
      yield { type: I.StringMaxLength, schema: $, path: Y, value: X, message: `Expected string length less or equal to ${$.maxLength}` };
    if (s.IsString($.pattern)) {
      if (!new RegExp($.pattern).test(X))
        yield { type: I.StringPattern, schema: $, path: Y, value: X, message: `Expected string to match pattern ${$.pattern}` };
    }
    if (s.IsString($.format)) {
      if (!O0.FormatRegistry.Has($.format))
        yield { type: I.StringFormatUnknown, schema: $, path: Y, value: X, message: `Unknown string format '${$.format}'` };
      else if (!O0.FormatRegistry.Get($.format)(X))
        yield { type: I.StringFormat, schema: $, path: Y, value: X, message: `Expected string to match format '${$.format}'` };
    }
  }
  function* mY($, J, Y, X) {
    if (!s.IsSymbol(X))
      return yield { type: I.Symbol, schema: $, path: Y, value: X, message: "Expected symbol" };
  }
  function* oY($, J, Y, X) {
    if (!s.IsString(X))
      return yield { type: I.String, schema: $, path: Y, value: X, message: "Expected string" };
    if (!new RegExp($.pattern).test(X))
      yield { type: I.StringPattern, schema: $, path: Y, value: X, message: `Expected string to match pattern ${$.pattern}` };
  }
  function* nY($, J, Y, X) {
    const Z = J.findIndex((q) => q.$id === $.$ref);
    if (Z === -1)
      throw new q$($);
    const Q = J[Z];
    yield* Z0(Q, J, Y, X);
  }
  function* uY($, J, Y, X) {
    if (!s.IsArray(X))
      return yield { type: I.Array, schema: $, path: Y, value: X, message: "Expected Array" };
    if ($.items === undefined && X.length !== 0)
      return yield { type: I.TupleZeroLength, schema: $, path: Y, value: X, message: "Expected tuple to have 0 elements" };
    if (X.length !== $.maxItems)
      yield { type: I.TupleLength, schema: $, path: Y, value: X, message: `Expected tuple to have ${$.maxItems} elements` };
    if (!$.items)
      return;
    for (let Z = 0;Z < $.items.length; Z++)
      yield* Z0($.items[Z], J, `${Y}/${Z}`, X[Z]);
  }
  function* hY($, J, Y, X) {
    if (X !== undefined)
      yield { type: I.Undefined, schema: $, path: Y, value: X, message: "Expected undefined" };
  }
  function* cY($, J, Y, X) {
    const Z = [];
    for (let Q of $.anyOf) {
      const q = [...Z0(Q, J, Y, X)];
      if (q.length === 0)
        return;
      Z.push(...q);
    }
    if (Z.length > 0)
      yield { type: I.Union, schema: $, path: Y, value: X, message: "Expected value of union" };
    for (let Q of Z)
      yield Q;
  }
  function* lY($, J, Y, X) {
    if (!s.IsUint8Array(X))
      return yield { type: I.Uint8Array, schema: $, path: Y, value: X, message: "Expected Uint8Array" };
    if (m($.maxByteLength) && !(X.length <= $.maxByteLength))
      yield { type: I.Uint8ArrayMaxByteLength, schema: $, path: Y, value: X, message: `Expected Uint8Array to have a byte length less or equal to ${$.maxByteLength}` };
    if (m($.minByteLength) && !(X.length >= $.minByteLength))
      yield { type: I.Uint8ArrayMinByteLength, schema: $, path: Y, value: X, message: `Expected Uint8Array to have a byte length greater or equal to ${$.maxByteLength}` };
  }
  function* tY($, J, Y, X) {
  }
  function* sY($, J, Y, X) {
    if (!jY(X))
      return yield { type: I.Void, schema: $, path: Y, value: X, message: "Expected void" };
  }
  function* rY($, J, Y, X) {
    if (!O0.TypeRegistry.Get($[O0.Kind])($, X))
      return yield { type: I.Kind, schema: $, path: Y, value: X, message: `Expected kind ${$[O0.Kind]}` };
  }
  function* Z0($, J, Y, X) {
    const Z = m($.$id) ? [...J, $] : J, Q = $;
    switch (Q[O0.Kind]) {
      case "Any":
        return yield* SY(Q, Z, Y, X);
      case "Array":
        return yield* LY(Q, Z, Y, X);
      case "AsyncIterator":
        return yield* OY(Q, Z, Y, X);
      case "BigInt":
        return yield* CY(Q, Z, Y, X);
      case "Boolean":
        return yield* IY(Q, Z, Y, X);
      case "Constructor":
        return yield* bY(Q, Z, Y, X);
      case "Date":
        return yield* _Y(Q, Z, Y, X);
      case "Function":
        return yield* RY(Q, Z, Y, X);
      case "Integer":
        return yield* GY(Q, Z, Y, X);
      case "Intersect":
        return yield* EY(Q, Z, Y, X);
      case "Iterator":
        return yield* xY(Q, Z, Y, X);
      case "Literal":
        return yield* VY(Q, Z, Y, X);
      case "Never":
        return yield* kY(Q, Z, Y, X);
      case "Not":
        return yield* gY(Q, Z, Y, X);
      case "Null":
        return yield* fY(Q, Z, Y, X);
      case "Number":
        return yield* TY(Q, Z, Y, X);
      case "Object":
        return yield* dY(Q, Z, Y, X);
      case "Promise":
        return yield* yY(Q, Z, Y, X);
      case "Record":
        return yield* vY(Q, Z, Y, X);
      case "Ref":
        return yield* iY(Q, Z, Y, X);
      case "String":
        return yield* pY(Q, Z, Y, X);
      case "Symbol":
        return yield* mY(Q, Z, Y, X);
      case "TemplateLiteral":
        return yield* oY(Q, Z, Y, X);
      case "This":
        return yield* nY(Q, Z, Y, X);
      case "Tuple":
        return yield* uY(Q, Z, Y, X);
      case "Undefined":
        return yield* hY(Q, Z, Y, X);
      case "Union":
        return yield* cY(Q, Z, Y, X);
      case "Uint8Array":
        return yield* lY(Q, Z, Y, X);
      case "Unknown":
        return yield* tY(Q, Z, Y, X);
      case "Void":
        return yield* sY(Q, Z, Y, X);
      default:
        if (!O0.TypeRegistry.Has(Q[O0.Kind]))
          throw new l$($);
        return yield* rY(Q, Z, Y, X);
    }
  }
  var aY = function(...$) {
    const J = $.length === 3 ? Z0($[0], $[1], "", $[2]) : Z0($[0], [], "", $[1]);
    return new c$(J);
  };
  Object.defineProperty(q8, "__esModule", { value: true });
  q8.Errors = q8.ValueErrorsDereferenceError = q8.ValueErrorsUnknownTypeError = q8.ValueErrorIterator = q8.ValueErrorType = undefined;
  var H$ = i1(), O0 = G0(), DY = p1(), s = L0(), I;
  (function($) {
    $[$.Array = 0] = "Array", $[$.ArrayMinItems = 1] = "ArrayMinItems", $[$.ArrayMaxItems = 2] = "ArrayMaxItems", $[$.ArrayContains = 3] = "ArrayContains", $[$.ArrayMinContains = 4] = "ArrayMinContains", $[$.ArrayMaxContains = 5] = "ArrayMaxContains", $[$.ArrayUniqueItems = 6] = "ArrayUniqueItems", $[$.AsyncIterator = 7] = "AsyncIterator", $[$.BigInt = 8] = "BigInt", $[$.BigIntMultipleOf = 9] = "BigIntMultipleOf", $[$.BigIntExclusiveMinimum = 10] = "BigIntExclusiveMinimum", $[$.BigIntExclusiveMaximum = 11] = "BigIntExclusiveMaximum", $[$.BigIntMinimum = 12] = "BigIntMinimum", $[$.BigIntMaximum = 13] = "BigIntMaximum", $[$.Boolean = 14] = "Boolean", $[$.Date = 15] = "Date", $[$.DateExclusiveMinimumTimestamp = 16] = "DateExclusiveMinimumTimestamp", $[$.DateExclusiveMaximumTimestamp = 17] = "DateExclusiveMaximumTimestamp", $[$.DateMinimumTimestamp = 18] = "DateMinimumTimestamp", $[$.DateMaximumTimestamp = 19] = "DateMaximumTimestamp", $[$.Function = 20] = "Function", $[$.Integer = 21] = "Integer", $[$.IntegerMultipleOf = 22] = "IntegerMultipleOf", $[$.IntegerExclusiveMinimum = 23] = "IntegerExclusiveMinimum", $[$.IntegerExclusiveMaximum = 24] = "IntegerExclusiveMaximum", $[$.IntegerMinimum = 25] = "IntegerMinimum", $[$.IntegerMaximum = 26] = "IntegerMaximum", $[$.Intersect = 27] = "Intersect", $[$.IntersectUnevaluatedProperties = 28] = "IntersectUnevaluatedProperties", $[$.Iterator = 29] = "Iterator", $[$.Literal = 30] = "Literal", $[$.Never = 31] = "Never", $[$.Not = 32] = "Not", $[$.Null = 33] = "Null", $[$.Number = 34] = "Number", $[$.NumberMultipleOf = 35] = "NumberMultipleOf", $[$.NumberExclusiveMinimum = 36] = "NumberExclusiveMinimum", $[$.NumberExclusiveMaximum = 37] = "NumberExclusiveMaximum", $[$.NumberMinimum = 38] = "NumberMinimum", $[$.NumberMaximum = 39] = "NumberMaximum", $[$.Object = 40] = "Object", $[$.ObjectMinProperties = 41] = "ObjectMinProperties", $[$.ObjectMaxProperties = 42] = "ObjectMaxProperties", $[$.ObjectAdditionalProperties = 43] = "ObjectAdditionalProperties", $[$.ObjectRequiredProperties = 44] = "ObjectRequiredProperties", $[$.Promise = 45] = "Promise", $[$.RecordKeyNumeric = 46] = "RecordKeyNumeric", $[$.RecordKeyString = 47] = "RecordKeyString", $[$.String = 48] = "String", $[$.StringMinLength = 49] = "StringMinLength", $[$.StringMaxLength = 50] = "StringMaxLength", $[$.StringPattern = 51] = "StringPattern", $[$.StringFormatUnknown = 52] = "StringFormatUnknown", $[$.StringFormat = 53] = "StringFormat", $[$.Symbol = 54] = "Symbol", $[$.TupleZeroLength = 55] = "TupleZeroLength", $[$.TupleLength = 56] = "TupleLength", $[$.Undefined = 57] = "Undefined", $[$.Union = 58] = "Union", $[$.Uint8Array = 59] = "Uint8Array", $[$.Uint8ArrayMinByteLength = 60] = "Uint8ArrayMinByteLength", $[$.Uint8ArrayMaxByteLength = 61] = "Uint8ArrayMaxByteLength", $[$.Void = 62] = "Void", $[$.Kind = 63] = "Kind";
  })(I || (q8.ValueErrorType = I = {}));

  class c$ {
    constructor($) {
      this.iterator = $;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    First() {
      const $ = this.iterator.next();
      return $.done ? undefined : $.value;
    }
  }
  q8.ValueErrorIterator = c$;

  class l$ extends Error {
    constructor($) {
      super("ValueErrors: Unknown type");
      this.schema = $;
    }
  }
  q8.ValueErrorsUnknownTypeError = l$;

  class q$ extends Error {
    constructor($) {
      super(`ValueErrors: Unable to dereference type with $id '${$.$ref}'`);
      this.schema = $;
    }
  }
  q8.ValueErrorsDereferenceError = q$;
  q8.Errors = aY;
});
var m1 = l((F1) => {
  var XX = F1 && F1.__createBinding || (Object.create ? function($, J, Y, X) {
    if (X === undefined)
      X = Y;
    var Z = Object.getOwnPropertyDescriptor(J, Y);
    if (!Z || ("get" in Z ? !J.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return J[Y];
      } };
    Object.defineProperty($, X, Z);
  } : function($, J, Y, X) {
    if (X === undefined)
      X = Y;
    $[X] = J[Y];
  }), ZX = F1 && F1.__exportStar || function($, J) {
    for (var Y in $)
      if (Y !== "default" && !Object.prototype.hasOwnProperty.call(J, Y))
        XX(J, $, Y);
  };
  Object.defineProperty(F1, "__esModule", { value: true });
  ZX(M8(), F1);
});
var F$ = l((B8) => {
  Object.defineProperty(B8, "__esModule", { value: true });
  B8.ValuePointer = B8.ValuePointerRootDeleteError = B8.ValuePointerRootSetError = undefined;

  class s$ extends Error {
    constructor($, J, Y) {
      super("ValuePointer: Cannot set root value");
      this.value = $, this.path = J, this.update = Y;
    }
  }
  B8.ValuePointerRootSetError = s$;

  class r$ extends Error {
    constructor($, J) {
      super("ValuePointer: Cannot delete root value");
      this.value = $, this.path = J;
    }
  }
  B8.ValuePointerRootDeleteError = r$;
  var U8;
  (function($) {
    function J(F) {
      return F.indexOf("~") === -1 ? F : F.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    function* Y(F) {
      if (F === "")
        return;
      let [B, w] = [0, 0];
      for (let N = 0;N < F.length; N++)
        if (F.charAt(N) === "/")
          if (N === 0)
            B = N + 1;
          else
            w = N, yield J(F.slice(B, w)), B = N + 1;
        else
          w = N;
      yield J(F.slice(B));
    }
    $.Format = Y;
    function X(F, B, w) {
      if (B === "")
        throw new s$(F, B, w);
      let [N, P, D] = [null, F, ""];
      for (let A of Y(B)) {
        if (P[A] === undefined)
          P[A] = {};
        N = P, P = P[A], D = A;
      }
      N[D] = w;
    }
    $.Set = X;
    function Z(F, B) {
      if (B === "")
        throw new r$(F, B);
      let [w, N, P] = [null, F, ""];
      for (let D of Y(B)) {
        if (N[D] === undefined || N[D] === null)
          return;
        w = N, N = N[D], P = D;
      }
      if (Array.isArray(w)) {
        const D = parseInt(P);
        w.splice(D, 1);
      } else
        delete w[P];
    }
    $.Delete = Z;
    function Q(F, B) {
      if (B === "")
        return true;
      let [w, N, P] = [null, F, ""];
      for (let D of Y(B)) {
        if (N[D] === undefined)
          return false;
        w = N, N = N[D], P = D;
      }
      return Object.getOwnPropertyNames(w).includes(P);
    }
    $.Has = Q;
    function q(F, B) {
      if (B === "")
        return F;
      let w = F;
      for (let N of Y(B)) {
        if (w[N] === undefined)
          return;
        w = w[N];
      }
      return w;
    }
    $.Get = q;
  })(U8 || (B8.ValuePointer = U8 = {}));
});
var E1 = l((N8) => {
  var zX = function($) {
    return [...Object.getOwnPropertyNames($), ...Object.getOwnPropertySymbols($)].reduce((Y, X) => ({ ...Y, [X]: a$($[X]) }), {});
  }, HX = function($) {
    return $.map((J) => a$(J));
  }, qX = function($) {
    return $.slice();
  }, FX = function($) {
    return new Date($.toISOString());
  }, MX = function($) {
    return $;
  }, UX = function($) {
    return $;
  }, BX = function($) {
    return $;
  }, AX = function($) {
    return $;
  }, NX = function($) {
    return $;
  }, a$ = function($) {
    if (i0.IsArray($))
      return HX($);
    if (i0.IsAsyncIterator($))
      return UX($);
    if (i0.IsFunction($))
      return AX($);
    if (i0.IsIterator($))
      return BX($);
    if (i0.IsPromise($))
      return NX($);
    if (i0.IsDate($))
      return FX($);
    if (i0.IsPlainObject($))
      return zX($);
    if (i0.IsTypedArray($))
      return qX($);
    if (i0.IsValueType($))
      return MX($);
    throw new Error("ValueClone: Unable to clone value");
  };
  Object.defineProperty(N8, "__esModule", { value: true });
  N8.Clone = undefined;
  var i0 = L0();
  N8.Clone = a$;
});
var Y4 = l((P8) => {
  var o1 = function($, J) {
    return { type: "update", path: $, value: J };
  }, D8 = function($, J) {
    return { type: "insert", path: $, value: J };
  }, K8 = function($) {
    return { type: "delete", path: $ };
  };
  function* wX($, J, Y) {
    if (!q0.IsPlainObject(Y))
      return yield o1($, Y);
    const X = [...Object.keys(J), ...Object.getOwnPropertySymbols(J)], Z = [...Object.keys(Y), ...Object.getOwnPropertySymbols(Y)];
    for (let Q of X) {
      if (q0.IsSymbol(Q))
        throw new x1(Q);
      if (q0.IsUndefined(Y[Q]) && Z.includes(Q))
        yield o1(`${$}/${String(Q)}`, undefined);
    }
    for (let Q of Z) {
      if (q0.IsUndefined(J[Q]) || q0.IsUndefined(Y[Q]))
        continue;
      if (q0.IsSymbol(Q))
        throw new x1(Q);
      yield* M$(`${$}/${String(Q)}`, J[Q], Y[Q]);
    }
    for (let Q of Z) {
      if (q0.IsSymbol(Q))
        throw new x1(Q);
      if (q0.IsUndefined(J[Q]))
        yield D8(`${$}/${String(Q)}`, Y[Q]);
    }
    for (let Q of X.reverse()) {
      if (q0.IsSymbol(Q))
        throw new x1(Q);
      if (q0.IsUndefined(Y[Q]) && !Z.includes(Q))
        yield K8(`${$}/${String(Q)}`);
    }
  }
  function* DX($, J, Y) {
    if (!q0.IsArray(Y))
      return yield o1($, Y);
    for (let X = 0;X < Math.min(J.length, Y.length); X++)
      yield* M$(`${$}/${X}`, J[X], Y[X]);
    for (let X = 0;X < Y.length; X++) {
      if (X < J.length)
        continue;
      yield D8(`${$}/${X}`, Y[X]);
    }
    for (let X = J.length - 1;X >= 0; X--) {
      if (X < Y.length)
        continue;
      yield K8(`${$}/${X}`);
    }
  }
  function* KX($, J, Y) {
    if (!q0.IsTypedArray(Y) || J.length !== Y.length || Object.getPrototypeOf(J).constructor.name !== Object.getPrototypeOf(Y).constructor.name)
      return yield o1($, Y);
    for (let X = 0;X < Math.min(J.length, Y.length); X++)
      yield* M$(`${$}/${X}`, J[X], Y[X]);
  }
  function* PX($, J, Y) {
    if (J === Y)
      return;
    yield o1($, Y);
  }
  function* M$($, J, Y) {
    if (q0.IsPlainObject(J))
      return yield* wX($, J, Y);
    if (q0.IsArray(J))
      return yield* DX($, J, Y);
    if (q0.IsTypedArray(J))
      return yield* KX($, J, Y);
    if (q0.IsValueType(J))
      return yield* PX($, J, Y);
    throw new J4(J);
  }
  var jX = function($, J) {
    return [...M$("", $, J)];
  }, SX = function($) {
    return $.length > 0 && $[0].path === "" && $[0].type === "update";
  }, LX = function($) {
    return $.length === 0;
  }, OX = function($, J) {
    if (SX(J))
      return $4.Clone(J[0].value);
    if (LX(J))
      return $4.Clone($);
    const Y = $4.Clone($);
    for (let X of J)
      switch (X.type) {
        case "insert": {
          e$.ValuePointer.Set(Y, X.path, X.value);
          break;
        }
        case "update": {
          e$.ValuePointer.Set(Y, X.path, X.value);
          break;
        }
        case "delete": {
          e$.ValuePointer.Delete(Y, X.path);
          break;
        }
      }
    return Y;
  };
  Object.defineProperty(P8, "__esModule", { value: true });
  P8.Patch = P8.Diff = P8.ValueDeltaUnableToDiffUnknownValue = P8.ValueDeltaObjectWithSymbolKeyError = P8.Edit = P8.Delete = P8.Update = P8.Insert = undefined;
  var C0 = G0(), e$ = F$(), q0 = L0(), $4 = E1();
  P8.Insert = C0.Type.Object({ type: C0.Type.Literal("insert"), path: C0.Type.String(), value: C0.Type.Unknown() });
  P8.Update = C0.Type.Object({ type: C0.Type.Literal("update"), path: C0.Type.String(), value: C0.Type.Unknown() });
  P8.Delete = C0.Type.Object({ type: C0.Type.Literal("delete"), path: C0.Type.String() });
  P8.Edit = C0.Type.Union([P8.Insert, P8.Update, P8.Delete]);

  class x1 extends Error {
    constructor($) {
      super("ValueDelta: Cannot diff objects with symbol keys");
      this.key = $;
    }
  }
  P8.ValueDeltaObjectWithSymbolKeyError = x1;

  class J4 extends Error {
    constructor($) {
      super("ValueDelta: Unable to create diff edits for unknown value");
      this.value = $;
    }
  }
  P8.ValueDeltaUnableToDiffUnknownValue = J4;
  P8.Diff = jX;
  P8.Patch = OX;
});
var _8 = l((I8) => {
  var RX = function($, J, Y, X) {
    if (!P0.IsPlainObject(Y))
      U$.ValuePointer.Set($, J, X4.Clone(X));
    else {
      const Z = Object.keys(Y), Q = Object.keys(X);
      for (let q of Z)
        if (!Q.includes(q))
          delete Y[q];
      for (let q of Q)
        if (!Z.includes(q))
          Y[q] = null;
      for (let q of Q)
        W4($, `${J}/${q}`, Y[q], X[q]);
    }
  }, GX = function($, J, Y, X) {
    if (!P0.IsArray(Y))
      U$.ValuePointer.Set($, J, X4.Clone(X));
    else {
      for (let Z = 0;Z < X.length; Z++)
        W4($, `${J}/${Z}`, Y[Z], X[Z]);
      Y.splice(X.length);
    }
  }, EX = function($, J, Y, X) {
    if (P0.IsTypedArray(Y) && Y.length === X.length)
      for (let Z = 0;Z < Y.length; Z++)
        Y[Z] = X[Z];
    else
      U$.ValuePointer.Set($, J, X4.Clone(X));
  }, xX = function($, J, Y, X) {
    if (Y === X)
      return;
    U$.ValuePointer.Set($, J, X);
  }, W4 = function($, J, Y, X) {
    if (P0.IsArray(X))
      return GX($, J, Y, X);
    if (P0.IsTypedArray(X))
      return EX($, J, Y, X);
    if (P0.IsPlainObject(X))
      return RX($, J, Y, X);
    if (P0.IsValueType(X))
      return xX($, J, Y, X);
  }, C8 = function($) {
    return P0.IsTypedArray($) || P0.IsValueType($);
  }, VX = function($, J) {
    return P0.IsPlainObject($) && P0.IsArray(J) || P0.IsArray($) && P0.IsPlainObject(J);
  }, kX = function($, J) {
    if (C8($) || C8(J))
      throw new Q4;
    if (VX($, J))
      throw new Z4;
    W4($, "", $, J);
  };
  Object.defineProperty(I8, "__esModule", { value: true });
  I8.Mutate = I8.ValueMutateInvalidRootMutationError = I8.ValueMutateTypeMismatchError = undefined;
  var U$ = F$(), X4 = E1(), P0 = L0();

  class Z4 extends Error {
    constructor() {
      super("ValueMutate: Cannot assign due type mismatch of assignable values");
    }
  }
  I8.ValueMutateTypeMismatchError = Z4;

  class Q4 extends Error {
    constructor() {
      super("ValueMutate: Only object and array types can be mutated at the root level");
    }
  }
  I8.ValueMutateInvalidRootMutationError = Q4;
  I8.Mutate = kX;
});
var E8 = l((R8) => {
  var TX = function($, J) {
    if (!p0.IsPlainObject(J))
      return false;
    const Y = [...Object.keys($), ...Object.getOwnPropertySymbols($)], X = [...Object.keys(J), ...Object.getOwnPropertySymbols(J)];
    if (Y.length !== X.length)
      return false;
    return Y.every((Z) => B$($[Z], J[Z]));
  }, dX = function($, J) {
    return p0.IsDate(J) && $.getTime() === J.getTime();
  }, yX = function($, J) {
    if (!p0.IsArray(J) || $.length !== J.length)
      return false;
    return $.every((Y, X) => B$(Y, J[X]));
  }, vX = function($, J) {
    if (!p0.IsTypedArray(J) || $.length !== J.length || Object.getPrototypeOf($).constructor.name !== Object.getPrototypeOf(J).constructor.name)
      return false;
    return $.every((Y, X) => B$(Y, J[X]));
  }, iX = function($, J) {
    return $ === J;
  }, B$ = function($, J) {
    if (p0.IsPlainObject($))
      return TX($, J);
    if (p0.IsDate($))
      return dX($, J);
    if (p0.IsTypedArray($))
      return vX($, J);
    if (p0.IsArray($))
      return yX($, J);
    if (p0.IsValueType($))
      return iX($, J);
    throw new Error("ValueEquals: Unable to compare value");
  };
  Object.defineProperty(R8, "__esModule", { value: true });
  R8.Equal = undefined;
  var p0 = L0();
  R8.Equal = B$;
});
var n1 = l((x8) => {
  var mX = function($) {
    return $[$0.Kind] === "Any" || $[$0.Kind] === "Unknown";
  }, v = function($) {
    return $ !== undefined;
  }, oX = function($, J) {
    return A$.TypeSystem.ExactOptionalPropertyTypes ? J in $ : $[J] !== undefined;
  }, w$ = function($) {
    const J = m0.IsObject($);
    return A$.TypeSystem.AllowArrayObjects ? J : J && !m0.IsArray($);
  }, nX = function($) {
    return w$($) && !($ instanceof Date) && !($ instanceof Uint8Array);
  }, V1 = function($) {
    const J = m0.IsNumber($);
    return A$.TypeSystem.AllowNaN ? J : J && Number.isFinite($);
  }, uX = function($) {
    const J = m0.IsUndefined($);
    return A$.TypeSystem.AllowVoidNull ? J || $ === null : J;
  }, hX = function($, J, Y) {
    return true;
  }, cX = function($, J, Y) {
    if (!Array.isArray(Y))
      return false;
    if (v($.minItems) && !(Y.length >= $.minItems))
      return false;
    if (v($.maxItems) && !(Y.length <= $.maxItems))
      return false;
    if (!Y.every((Q) => Q0($.items, J, Q)))
      return false;
    if ($.uniqueItems === true && !function() {
      const Q = new Set;
      for (let q of Y) {
        const F = pX.Hash(q);
        if (Q.has(F))
          return false;
        else
          Q.add(F);
      }
      return true;
    }())
      return false;
    if (!(v($.contains) || V1($.minContains) || V1($.maxContains)))
      return true;
    const X = v($.contains) ? $.contains : $0.Type.Never(), Z = Y.reduce((Q, q) => Q0(X, J, q) ? Q + 1 : Q, 0);
    if (Z === 0)
      return false;
    if (V1($.minContains) && Z < $.minContains)
      return false;
    if (V1($.maxContains) && Z > $.maxContains)
      return false;
    return true;
  }, lX = function($, J, Y) {
    return w$(Y) && (Symbol.asyncIterator in Y);
  }, tX = function($, J, Y) {
    if (!m0.IsBigInt(Y))
      return false;
    if (v($.multipleOf) && Y % $.multipleOf !== BigInt(0))
      return false;
    if (v($.exclusiveMinimum) && !(Y > $.exclusiveMinimum))
      return false;
    if (v($.exclusiveMaximum) && !(Y < $.exclusiveMaximum))
      return false;
    if (v($.minimum) && !(Y >= $.minimum))
      return false;
    if (v($.maximum) && !(Y <= $.maximum))
      return false;
    return true;
  }, sX = function($, J, Y) {
    return typeof Y === "boolean";
  }, rX = function($, J, Y) {
    return Q0($.returns, J, Y.prototype);
  }, aX = function($, J, Y) {
    if (!(Y instanceof Date))
      return false;
    if (!V1(Y.getTime()))
      return false;
    if (v($.exclusiveMinimumTimestamp) && !(Y.getTime() > $.exclusiveMinimumTimestamp))
      return false;
    if (v($.exclusiveMaximumTimestamp) && !(Y.getTime() < $.exclusiveMaximumTimestamp))
      return false;
    if (v($.minimumTimestamp) && !(Y.getTime() >= $.minimumTimestamp))
      return false;
    if (v($.maximumTimestamp) && !(Y.getTime() <= $.maximumTimestamp))
      return false;
    return true;
  }, eX = function($, J, Y) {
    return typeof Y === "function";
  }, $Z = function($, J, Y) {
    if (!m0.IsInteger(Y))
      return false;
    if (v($.multipleOf) && Y % $.multipleOf !== 0)
      return false;
    if (v($.exclusiveMinimum) && !(Y > $.exclusiveMinimum))
      return false;
    if (v($.exclusiveMaximum) && !(Y < $.exclusiveMaximum))
      return false;
    if (v($.minimum) && !(Y >= $.minimum))
      return false;
    if (v($.maximum) && !(Y <= $.maximum))
      return false;
    return true;
  }, JZ = function($, J, Y) {
    const X = $.allOf.every((Z) => Q0(Z, J, Y));
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp($0.KeyResolver.ResolvePattern($)), Q = Object.getOwnPropertyNames(Y).every((q) => Z.test(q));
      return X && Q;
    } else if ($0.TypeGuard.TSchema($.unevaluatedProperties)) {
      const Z = new RegExp($0.KeyResolver.ResolvePattern($)), Q = Object.getOwnPropertyNames(Y).every((q) => Z.test(q) || Q0($.unevaluatedProperties, J, Y[q]));
      return X && Q;
    } else
      return X;
  }, YZ = function($, J, Y) {
    return w$(Y) && (Symbol.iterator in Y);
  }, XZ = function($, J, Y) {
    return Y === $.const;
  }, ZZ = function($, J, Y) {
    return false;
  }, QZ = function($, J, Y) {
    return !Q0($.not, J, Y);
  }, WZ = function($, J, Y) {
    return Y === null;
  }, zZ = function($, J, Y) {
    if (!V1(Y))
      return false;
    if (v($.multipleOf) && Y % $.multipleOf !== 0)
      return false;
    if (v($.exclusiveMinimum) && !(Y > $.exclusiveMinimum))
      return false;
    if (v($.exclusiveMaximum) && !(Y < $.exclusiveMaximum))
      return false;
    if (v($.minimum) && !(Y >= $.minimum))
      return false;
    if (v($.maximum) && !(Y <= $.maximum))
      return false;
    return true;
  }, HZ = function($, J, Y) {
    if (!w$(Y))
      return false;
    if (v($.minProperties) && !(Object.getOwnPropertyNames(Y).length >= $.minProperties))
      return false;
    if (v($.maxProperties) && !(Object.getOwnPropertyNames(Y).length <= $.maxProperties))
      return false;
    const X = Object.getOwnPropertyNames($.properties);
    for (let Z of X) {
      const Q = $.properties[Z];
      if ($.required && $.required.includes(Z)) {
        if (!Q0(Q, J, Y[Z]))
          return false;
        if (($0.ExtendsUndefined.Check(Q) || mX(Q)) && !(Z in Y))
          return false;
      } else if (oX(Y, Z) && !Q0(Q, J, Y[Z]))
        return false;
    }
    if ($.additionalProperties === false) {
      const Z = Object.getOwnPropertyNames(Y);
      if ($.required && $.required.length === X.length && Z.length === X.length)
        return true;
      else
        return Z.every((Q) => X.includes(Q));
    } else if (typeof $.additionalProperties === "object")
      return Object.getOwnPropertyNames(Y).every((Q) => X.includes(Q) || Q0($.additionalProperties, J, Y[Q]));
    else
      return true;
  }, qZ = function($, J, Y) {
    return typeof Y === "object" && typeof Y.then === "function";
  }, FZ = function($, J, Y) {
    if (!nX(Y))
      return false;
    if (v($.minProperties) && !(Object.getOwnPropertyNames(Y).length >= $.minProperties))
      return false;
    if (v($.maxProperties) && !(Object.getOwnPropertyNames(Y).length <= $.maxProperties))
      return false;
    const [X, Z] = Object.entries($.patternProperties)[0], Q = new RegExp(X);
    return Object.entries(Y).every(([q, F]) => {
      if (Q.test(q))
        return Q0(Z, J, F);
      if (typeof $.additionalProperties === "object")
        return Q0($.additionalProperties, J, F);
      if ($.additionalProperties === false)
        return false;
      return true;
    });
  }, MZ = function($, J, Y) {
    const X = J.findIndex((Q) => Q.$id === $.$ref);
    if (X === -1)
      throw new N$($);
    const Z = J[X];
    return Q0(Z, J, Y);
  }, UZ = function($, J, Y) {
    if (!m0.IsString(Y))
      return false;
    if (v($.minLength)) {
      if (!(Y.length >= $.minLength))
        return false;
    }
    if (v($.maxLength)) {
      if (!(Y.length <= $.maxLength))
        return false;
    }
    if (v($.pattern)) {
      if (!new RegExp($.pattern).test(Y))
        return false;
    }
    if (v($.format)) {
      if (!$0.FormatRegistry.Has($.format))
        return false;
      return $0.FormatRegistry.Get($.format)(Y);
    }
    return true;
  }, BZ = function($, J, Y) {
    if (typeof Y !== "symbol")
      return false;
    return true;
  }, AZ = function($, J, Y) {
    if (!m0.IsString(Y))
      return false;
    return new RegExp($.pattern).test(Y);
  }, NZ = function($, J, Y) {
    const X = J.findIndex((Q) => Q.$id === $.$ref);
    if (X === -1)
      throw new N$($);
    const Z = J[X];
    return Q0(Z, J, Y);
  }, wZ = function($, J, Y) {
    if (!m0.IsArray(Y))
      return false;
    if ($.items === undefined && Y.length !== 0)
      return false;
    if (Y.length !== $.maxItems)
      return false;
    if (!$.items)
      return true;
    for (let X = 0;X < $.items.length; X++)
      if (!Q0($.items[X], J, Y[X]))
        return false;
    return true;
  }, DZ = function($, J, Y) {
    return Y === undefined;
  }, KZ = function($, J, Y) {
    return $.anyOf.some((X) => Q0(X, J, Y));
  }, PZ = function($, J, Y) {
    if (!(Y instanceof Uint8Array))
      return false;
    if (v($.maxByteLength) && !(Y.length <= $.maxByteLength))
      return false;
    if (v($.minByteLength) && !(Y.length >= $.minByteLength))
      return false;
    return true;
  }, jZ = function($, J, Y) {
    return true;
  }, SZ = function($, J, Y) {
    return uX(Y);
  }, LZ = function($, J, Y) {
    if (!$0.TypeRegistry.Has($[$0.Kind]))
      return false;
    return $0.TypeRegistry.Get($[$0.Kind])($, Y);
  }, Q0 = function($, J, Y) {
    const X = v($.$id) ? [...J, $] : J, Z = $;
    switch (Z[$0.Kind]) {
      case "Any":
        return hX(Z, X, Y);
      case "Array":
        return cX(Z, X, Y);
      case "AsyncIterator":
        return lX(Z, X, Y);
      case "BigInt":
        return tX(Z, X, Y);
      case "Boolean":
        return sX(Z, X, Y);
      case "Constructor":
        return rX(Z, X, Y);
      case "Date":
        return aX(Z, X, Y);
      case "Function":
        return eX(Z, X, Y);
      case "Integer":
        return $Z(Z, X, Y);
      case "Intersect":
        return JZ(Z, X, Y);
      case "Iterator":
        return YZ(Z, X, Y);
      case "Literal":
        return XZ(Z, X, Y);
      case "Never":
        return ZZ(Z, X, Y);
      case "Not":
        return QZ(Z, X, Y);
      case "Null":
        return WZ(Z, X, Y);
      case "Number":
        return zZ(Z, X, Y);
      case "Object":
        return HZ(Z, X, Y);
      case "Promise":
        return qZ(Z, X, Y);
      case "Record":
        return FZ(Z, X, Y);
      case "Ref":
        return MZ(Z, X, Y);
      case "String":
        return UZ(Z, X, Y);
      case "Symbol":
        return BZ(Z, X, Y);
      case "TemplateLiteral":
        return AZ(Z, X, Y);
      case "This":
        return NZ(Z, X, Y);
      case "Tuple":
        return wZ(Z, X, Y);
      case "Undefined":
        return DZ(Z, X, Y);
      case "Union":
        return KZ(Z, X, Y);
      case "Uint8Array":
        return PZ(Z, X, Y);
      case "Unknown":
        return jZ(Z, X, Y);
      case "Void":
        return SZ(Z, X, Y);
      default:
        if (!$0.TypeRegistry.Has(Z[$0.Kind]))
          throw new z4(Z);
        return LZ(Z, X, Y);
    }
  }, OZ = function(...$) {
    return $.length === 3 ? Q0($[0], $[1], $[2]) : Q0($[0], [], $[1]);
  };
  Object.defineProperty(x8, "__esModule", { value: true });
  x8.Check = x8.ValueCheckDereferenceError = x8.ValueCheckUnknownTypeError = undefined;
  var A$ = i1(), $0 = G0(), m0 = L0(), pX = p1();

  class z4 extends Error {
    constructor($) {
      super(`ValueCheck: ${$[$0.Kind] ? `Unknown type '${$[$0.Kind]}'` : "Unknown type"}`);
      this.schema = $;
    }
  }
  x8.ValueCheckUnknownTypeError = z4;

  class N$ extends Error {
    constructor($) {
      super(`ValueCheck: Unable to dereference type with $id '${$.$ref}'`);
      this.schema = $;
    }
  }
  x8.ValueCheckDereferenceError = N$;
  x8.Check = OZ;
});
var A4 = l((f8) => {
  var _Z = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else
      return {};
  }, RZ = function($, J) {
    if ($.uniqueItems === true && !i.HasPropertyKey($, "default"))
      throw new Error("ValueCreate.Array: Array with the uniqueItems constraint requires a default value");
    else if (("contains" in $) && !i.HasPropertyKey($, "default"))
      throw new Error("ValueCreate.Array: Array with the contains constraint requires a default value");
    else if ("default" in $)
      return $.default;
    else if ($.minItems !== undefined)
      return Array.from({ length: $.minItems }).map((Y) => {
        return j0($.items, J);
      });
    else
      return [];
  }, GZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else
      return async function* () {
      }();
  }, EZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else
      return BigInt(0);
  }, xZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else
      return false;
  }, VZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else {
      const Y = j0($.returns, J);
      if (typeof Y === "object" && !Array.isArray(Y))
        return class {
          constructor() {
            for (let [X, Z] of Object.entries(Y)) {
              const Q = this;
              Q[X] = Z;
            }
          }
        };
      else
        return class {
        };
    }
  }, kZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else if ($.minimumTimestamp !== undefined)
      return new Date($.minimumTimestamp);
    else
      return new Date(0);
  }, gZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else
      return () => j0($.returns, J);
  }, fZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, TZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else {
      const Y = $.allOf.reduce((X, Z) => {
        const Q = j0(Z, J);
        return typeof Q === "object" ? { ...X, ...Q } : Q;
      }, {});
      if (!bZ.Check($, J, Y))
        throw new M4($);
      return Y;
    }
  }, dZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else
      return function* () {
      }();
  }, yZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else
      return $.const;
  }, vZ = function($, J) {
    throw new q4($);
  }, iZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else
      throw new F4($);
  }, pZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else
      return null;
  }, mZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, oZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else {
      const Y = new Set($.required);
      return $.default || Object.entries($.properties).reduce((X, [Z, Q]) => {
        return Y.has(Z) ? { ...X, [Z]: j0(Q, J) } : { ...X };
      }, {});
    }
  }, nZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else
      return Promise.resolve(j0($.item, J));
  }, uZ = function($, J) {
    const [Y, X] = Object.entries($.patternProperties)[0];
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else if (!(Y === r0.PatternStringExact || Y === r0.PatternNumberExact))
      return Y.slice(1, Y.length - 1).split("|").reduce((Q, q) => {
        return { ...Q, [q]: j0(X, J) };
      }, {});
    else
      return {};
  }, hZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else {
      const Y = J.findIndex((Z) => Z.$id === $.$ref);
      if (Y === -1)
        throw new D$($);
      const X = J[Y];
      return j0(X, J);
    }
  }, cZ = function($, J) {
    if ($.pattern !== undefined)
      if (!i.HasPropertyKey($, "default"))
        throw new Error("ValueCreate.String: String types with patterns must specify a default value");
      else
        return $.default;
    else if ($.format !== undefined)
      if (!i.HasPropertyKey($, "default"))
        throw new Error("ValueCreate.String: String types with formats must specify a default value");
      else
        return $.default;
    else if (i.HasPropertyKey($, "default"))
      return $.default;
    else if ($.minLength !== undefined)
      return Array.from({ length: $.minLength }).map(() => ".").join("");
    else
      return "";
  }, lZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else if ("value" in $)
      return Symbol.for($.value);
    else
      return Symbol();
  }, tZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    const Y = r0.TemplateLiteralParser.ParseExact($.pattern);
    if (!r0.TemplateLiteralFinite.Check(Y))
      throw new U4($);
    return r0.TemplateLiteralGenerator.Generate(Y).next().value;
  }, sZ = function($, J) {
    if (g8++ > k8)
      throw new B4($, k8);
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else {
      const Y = J.findIndex((Z) => Z.$id === $.$ref);
      if (Y === -1)
        throw new D$($);
      const X = J[Y];
      return j0(X, J);
    }
  }, rZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    if ($.items === undefined)
      return [];
    else
      return Array.from({ length: $.minItems }).map((Y, X) => j0($.items[X], J));
  }, aZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else
      return;
  }, eZ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else if ($.anyOf.length === 0)
      throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
    else
      return j0($.anyOf[0], J);
  }, $Q = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else if ($.minByteLength !== undefined)
      return new Uint8Array($.minByteLength);
    else
      return new Uint8Array(0);
  }, JQ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else
      return {};
  }, YQ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else
      return;
  }, XQ = function($, J) {
    if (i.HasPropertyKey($, "default"))
      return $.default;
    else
      throw new Error("ValueCreate: User defined types must specify a default value");
  }, j0 = function($, J) {
    const Y = i.IsString($.$id) ? [...J, $] : J, X = $;
    switch (X[r0.Kind]) {
      case "Any":
        return _Z(X, Y);
      case "Array":
        return RZ(X, Y);
      case "AsyncIterator":
        return GZ(X, Y);
      case "BigInt":
        return EZ(X, Y);
      case "Boolean":
        return xZ(X, Y);
      case "Constructor":
        return VZ(X, Y);
      case "Date":
        return kZ(X, Y);
      case "Function":
        return gZ(X, Y);
      case "Integer":
        return fZ(X, Y);
      case "Intersect":
        return TZ(X, Y);
      case "Iterator":
        return dZ(X, Y);
      case "Literal":
        return yZ(X, Y);
      case "Never":
        return vZ(X, Y);
      case "Not":
        return iZ(X, Y);
      case "Null":
        return pZ(X, Y);
      case "Number":
        return mZ(X, Y);
      case "Object":
        return oZ(X, Y);
      case "Promise":
        return nZ(X, Y);
      case "Record":
        return uZ(X, Y);
      case "Ref":
        return hZ(X, Y);
      case "String":
        return cZ(X, Y);
      case "Symbol":
        return lZ(X, Y);
      case "TemplateLiteral":
        return tZ(X, Y);
      case "This":
        return sZ(X, Y);
      case "Tuple":
        return rZ(X, Y);
      case "Undefined":
        return aZ(X, Y);
      case "Union":
        return eZ(X, Y);
      case "Uint8Array":
        return $Q(X, Y);
      case "Unknown":
        return JQ(X, Y);
      case "Void":
        return YQ(X, Y);
      default:
        if (!r0.TypeRegistry.Has(X[r0.Kind]))
          throw new H4(X);
        return XQ(X, Y);
    }
  }, ZQ = function(...$) {
    return g8 = 0, $.length === 2 ? j0($[0], $[1]) : j0($[0], []);
  };
  Object.defineProperty(f8, "__esModule", { value: true });
  f8.Create = f8.ValueCreateRecursiveInstantiationError = f8.ValueCreateDereferenceError = f8.ValueCreateTempateLiteralTypeError = f8.ValueCreateIntersectTypeError = f8.ValueCreateNotTypeError = f8.ValueCreateNeverTypeError = f8.ValueCreateUnknownTypeError = undefined;
  var r0 = G0(), bZ = n1(), i = L0();

  class H4 extends Error {
    constructor($) {
      super("ValueCreate: Unknown type");
      this.schema = $;
    }
  }
  f8.ValueCreateUnknownTypeError = H4;

  class q4 extends Error {
    constructor($) {
      super("ValueCreate: Never types cannot be created");
      this.schema = $;
    }
  }
  f8.ValueCreateNeverTypeError = q4;

  class F4 extends Error {
    constructor($) {
      super("ValueCreate: Not types must have a default value");
      this.schema = $;
    }
  }
  f8.ValueCreateNotTypeError = F4;

  class M4 extends Error {
    constructor($) {
      super("ValueCreate: Intersect produced invalid value. Consider using a default value.");
      this.schema = $;
    }
  }
  f8.ValueCreateIntersectTypeError = M4;

  class U4 extends Error {
    constructor($) {
      super("ValueCreate: Can only create template literal values from patterns that produce finite sequences. Consider using a default value.");
      this.schema = $;
    }
  }
  f8.ValueCreateTempateLiteralTypeError = U4;

  class D$ extends Error {
    constructor($) {
      super(`ValueCreate: Unable to dereference type with $id '${$.$ref}'`);
      this.schema = $;
    }
  }
  f8.ValueCreateDereferenceError = D$;

  class B4 extends Error {
    constructor($, J) {
      super("ValueCreate: Value cannot be created as recursive type may produce value of infinite size. Consider using a default.");
      this.schema = $, this.recursiveMaxDepth = J;
    }
  }
  f8.ValueCreateRecursiveInstantiationError = B4;
  var k8 = 512, g8 = 0;
  f8.Create = ZQ;
});
var m8 = l((i8) => {
  var UQ = function($, J, Y) {
    return o.Check($, J, Y) ? U0.Clone(Y) : u.Create($, J);
  }, BQ = function($, J, Y) {
    if (o.Check($, J, Y))
      return U0.Clone(Y);
    const X = a0.IsArray(Y) ? U0.Clone(Y) : u.Create($, J), Z = a0.IsNumber($.minItems) && X.length < $.minItems ? [...X, ...Array.from({ length: $.minItems - X.length }, () => null)] : X, q = (a0.IsNumber($.maxItems) && Z.length > $.maxItems ? Z.slice(0, $.maxItems) : Z).map((B) => x0($.items, J, B));
    if ($.uniqueItems !== true)
      return q;
    const F = [...new Set(q)];
    if (!o.Check($, J, F))
      throw new w4($, F);
    return F;
  }, AQ = function($, J, Y) {
    return o.Check($, J, Y) ? Y : u.Create($, J);
  }, NQ = function($, J, Y) {
    return o.Check($, J, Y) ? Y : u.Create($, J);
  }, wQ = function($, J, Y) {
    return o.Check($, J, Y) ? Y : u.Create($, J);
  }, DQ = function($, J, Y) {
    if (o.Check($, J, Y))
      return u.Create($, J);
    const X = new Set($.returns.required || []), Z = function() {
    };
    for (let [Q, q] of Object.entries($.returns.properties)) {
      if (!X.has(Q) && Y.prototype[Q] === undefined)
        continue;
      Z.prototype[Q] = x0(q, J, Y.prototype[Q]);
    }
    return Z;
  }, KQ = function($, J, Y) {
    return o.Check($, J, Y) ? U0.Clone(Y) : u.Create($, J);
  }, PQ = function($, J, Y) {
    return o.Check($, J, Y) ? Y : u.Create($, J);
  }, jQ = function($, J, Y) {
    return o.Check($, J, Y) ? Y : u.Create($, J);
  }, SQ = function($, J, Y) {
    const X = u.Create($, J), Z = a0.IsPlainObject(X) && a0.IsPlainObject(Y) ? { ...X, ...Y } : Y;
    return o.Check($, J, Z) ? Z : u.Create($, J);
  }, LQ = function($, J, Y) {
    return o.Check($, J, Y) ? Y : u.Create($, J);
  }, OQ = function($, J, Y) {
    return o.Check($, J, Y) ? Y : u.Create($, J);
  }, CQ = function($, J, Y) {
    throw new D4($);
  }, IQ = function($, J, Y) {
    return o.Check($, J, Y) ? Y : u.Create($, J);
  }, bQ = function($, J, Y) {
    return o.Check($, J, Y) ? Y : u.Create($, J);
  }, _Q = function($, J, Y) {
    return o.Check($, J, Y) ? Y : u.Create($, J);
  }, RQ = function($, J, Y) {
    if (o.Check($, J, Y))
      return Y;
    if (Y === null || typeof Y !== "object")
      return u.Create($, J);
    const X = new Set($.required || []), Z = {};
    for (let [Q, q] of Object.entries($.properties)) {
      if (!X.has(Q) && Y[Q] === undefined)
        continue;
      Z[Q] = x0(q, J, Y[Q]);
    }
    if (typeof $.additionalProperties === "object") {
      const Q = Object.getOwnPropertyNames($.properties);
      for (let q of Object.getOwnPropertyNames(Y)) {
        if (Q.includes(q))
          continue;
        Z[q] = x0($.additionalProperties, J, Y[q]);
      }
    }
    return Z;
  }, GQ = function($, J, Y) {
    return o.Check($, J, Y) ? Y : u.Create($, J);
  }, EQ = function($, J, Y) {
    if (o.Check($, J, Y))
      return U0.Clone(Y);
    if (Y === null || typeof Y !== "object" || Array.isArray(Y) || Y instanceof Date)
      return u.Create($, J);
    const X = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X], Q = {};
    for (let [q, F] of Object.entries(Y))
      Q[q] = x0(Z, J, F);
    return Q;
  }, xQ = function($, J, Y) {
    const X = J.findIndex((Q) => Q.$id === $.$ref);
    if (X === -1)
      throw new K$($);
    const Z = J[X];
    return x0(Z, J, Y);
  }, VQ = function($, J, Y) {
    return o.Check($, J, Y) ? Y : u.Create($, J);
  }, kQ = function($, J, Y) {
    return o.Check($, J, Y) ? U0.Clone(Y) : u.Create($, J);
  }, gQ = function($, J, Y) {
    return o.Check($, J, Y) ? U0.Clone(Y) : u.Create($, J);
  }, fQ = function($, J, Y) {
    const X = J.findIndex((Q) => Q.$id === $.$ref);
    if (X === -1)
      throw new K$($);
    const Z = J[X];
    return x0(Z, J, Y);
  }, TQ = function($, J, Y) {
    if (o.Check($, J, Y))
      return U0.Clone(Y);
    if (!a0.IsArray(Y))
      return u.Create($, J);
    if ($.items === undefined)
      return [];
    return $.items.map((X, Z) => x0(X, J, Y[Z]));
  }, dQ = function($, J, Y) {
    return o.Check($, J, Y) ? U0.Clone(Y) : u.Create($, J);
  }, yQ = function($, J, Y) {
    return o.Check($, J, Y) ? U0.Clone(Y) : N4.Create($, J, Y);
  }, vQ = function($, J, Y) {
    return o.Check($, J, Y) ? U0.Clone(Y) : u.Create($, J);
  }, iQ = function($, J, Y) {
    return o.Check($, J, Y) ? U0.Clone(Y) : u.Create($, J);
  }, pQ = function($, J, Y) {
    return o.Check($, J, Y) ? U0.Clone(Y) : u.Create($, J);
  }, mQ = function($, J, Y) {
    return o.Check($, J, Y) ? U0.Clone(Y) : u.Create($, J);
  }, x0 = function($, J, Y) {
    const X = a0.IsString($.$id) ? [...J, $] : J, Z = $;
    switch ($[u1.Kind]) {
      case "Any":
        return UQ(Z, X, Y);
      case "Array":
        return BQ(Z, X, Y);
      case "AsyncIterator":
        return AQ(Z, X, Y);
      case "BigInt":
        return NQ(Z, X, Y);
      case "Boolean":
        return wQ(Z, X, Y);
      case "Constructor":
        return DQ(Z, X, Y);
      case "Date":
        return KQ(Z, X, Y);
      case "Function":
        return PQ(Z, X, Y);
      case "Integer":
        return jQ(Z, X, Y);
      case "Intersect":
        return SQ(Z, X, Y);
      case "Iterator":
        return LQ(Z, X, Y);
      case "Literal":
        return OQ(Z, X, Y);
      case "Never":
        return CQ(Z, X, Y);
      case "Not":
        return IQ(Z, X, Y);
      case "Null":
        return bQ(Z, X, Y);
      case "Number":
        return _Q(Z, X, Y);
      case "Object":
        return RQ(Z, X, Y);
      case "Promise":
        return GQ(Z, X, Y);
      case "Record":
        return EQ(Z, X, Y);
      case "Ref":
        return xQ(Z, X, Y);
      case "String":
        return VQ(Z, X, Y);
      case "Symbol":
        return kQ(Z, X, Y);
      case "TemplateLiteral":
        return gQ(Z, X, Y);
      case "This":
        return fQ(Z, X, Y);
      case "Tuple":
        return TQ(Z, X, Y);
      case "Undefined":
        return dQ(Z, X, Y);
      case "Union":
        return yQ(Z, X, Y);
      case "Uint8Array":
        return vQ(Z, X, Y);
      case "Unknown":
        return iQ(Z, X, Y);
      case "Void":
        return pQ(Z, X, Y);
      default:
        if (!u1.TypeRegistry.Has(Z[u1.Kind]))
          throw new K4(Z);
        return mQ(Z, X, Y);
    }
  }, v8 = function(...$) {
    return $.length === 3 ? x0($[0], $[1], $[2]) : x0($[0], [], $[1]);
  };
  Object.defineProperty(i8, "__esModule", { value: true });
  i8.Cast = i8.ValueCastDereferenceError = i8.ValueCastUnknownTypeError = i8.ValueCastRecursiveTypeError = i8.ValueCastNeverTypeError = i8.ValueCastArrayUniqueItemsTypeError = i8.ValueCastReferenceTypeError = undefined;
  var u1 = G0(), u = A4(), o = n1(), U0 = E1(), a0 = L0();

  class d8 extends Error {
    constructor($) {
      super(`ValueCast: Cannot locate referenced schema with $id '${$.$ref}'`);
      this.schema = $;
    }
  }
  i8.ValueCastReferenceTypeError = d8;

  class w4 extends Error {
    constructor($, J) {
      super("ValueCast: Array cast produced invalid data due to uniqueItems constraint");
      this.schema = $, this.value = J;
    }
  }
  i8.ValueCastArrayUniqueItemsTypeError = w4;

  class D4 extends Error {
    constructor($) {
      super("ValueCast: Never types cannot be cast");
      this.schema = $;
    }
  }
  i8.ValueCastNeverTypeError = D4;

  class y8 extends Error {
    constructor($) {
      super("ValueCast.Recursive: Cannot cast recursive schemas");
      this.schema = $;
    }
  }
  i8.ValueCastRecursiveTypeError = y8;

  class K4 extends Error {
    constructor($) {
      super("ValueCast: Unknown type");
      this.schema = $;
    }
  }
  i8.ValueCastUnknownTypeError = K4;

  class K$ extends Error {
    constructor($) {
      super(`ValueCast: Unable to dereference type with $id '${$.$ref}'`);
      this.schema = $;
    }
  }
  i8.ValueCastDereferenceError = K$;
  var N4;
  (function($) {
    function J(Z, Q, q) {
      if (Z[u1.Kind] === "Object" && typeof q === "object" && !a0.IsNull(q)) {
        const F = Z, B = Object.getOwnPropertyNames(q), w = Object.entries(F.properties), [N, P] = [1 / w.length, w.length];
        return w.reduce((D, [A, L]) => {
          const O = L[u1.Kind] === "Literal" && L.const === q[A] ? P : 0, G = o.Check(L, Q, q[A]) ? N : 0, R = B.includes(A) ? N : 0;
          return D + (O + G + R);
        }, 0);
      } else
        return o.Check(Z, Q, q) ? 1 : 0;
    }
    function Y(Z, Q, q) {
      let [F, B] = [Z.anyOf[0], 0];
      for (let w of Z.anyOf) {
        const N = J(w, Q, q);
        if (N > B)
          F = w, B = N;
      }
      return F;
    }
    function X(Z, Q, q) {
      if ("default" in Z)
        return Z.default;
      else {
        const F = Y(Z, Q, q);
        return v8(F, Q, q);
      }
    }
    $.Create = X;
  })(N4 || (N4 = {}));
  i8.Cast = v8;
});
var t8 = l((c8) => {
  var j$ = function($) {
    return c.IsString($) && !isNaN($) && !isNaN(parseFloat($));
  }, sQ = function($) {
    return c.IsBigInt($) || c.IsBoolean($) || c.IsNumber($);
  }, h1 = function($) {
    return $ === true || c.IsNumber($) && $ === 1 || c.IsBigInt($) && $ === BigInt("1") || c.IsString($) && ($.toLowerCase() === "true" || $ === "1");
  }, c1 = function($) {
    return $ === false || c.IsNumber($) && $ === 0 || c.IsBigInt($) && $ === BigInt("0") || c.IsString($) && ($.toLowerCase() === "false" || $ === "0");
  }, rQ = function($) {
    return c.IsString($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, aQ = function($) {
    return c.IsString($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, eQ = function($) {
    return c.IsString($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, $W = function($) {
    return c.IsString($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, JW = function($) {
    return c.IsString($) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test($);
  }, YW = function($, J) {
    const Y = u8($);
    return Y === J ? Y : $;
  }, XW = function($, J) {
    const Y = h8($);
    return Y === J ? Y : $;
  }, ZW = function($, J) {
    const Y = n8($);
    return Y === J ? Y : $;
  }, QW = function($, J) {
    if (typeof $.const === "string")
      return YW(J, $.const);
    else if (typeof $.const === "number")
      return XW(J, $.const);
    else if (typeof $.const === "boolean")
      return ZW(J, $.const);
    else
      return o8.Clone(J);
  }, n8 = function($) {
    return h1($) ? true : c1($) ? false : $;
  }, WW = function($) {
    return j$($) ? BigInt(parseInt($)) : c.IsNumber($) ? BigInt($ | 0) : c1($) ? 0 : h1($) ? 1 : $;
  }, u8 = function($) {
    return sQ($) ? $.toString() : c.IsSymbol($) && $.description !== undefined ? $.description.toString() : $;
  }, h8 = function($) {
    return j$($) ? parseFloat($) : h1($) ? 1 : c1($) ? 0 : $;
  }, zW = function($) {
    return j$($) ? parseInt($) : c.IsNumber($) ? $ | 0 : h1($) ? 1 : c1($) ? 0 : $;
  }, HW = function($) {
    return c.IsString($) && $.toLowerCase() === "null" ? null : $;
  }, qW = function($) {
    return c.IsString($) && $ === "undefined" ? undefined : $;
  }, FW = function($) {
    return c.IsDate($) ? $ : c.IsNumber($) ? new Date($) : h1($) ? new Date(1) : c1($) ? new Date(0) : j$($) ? new Date(parseInt($)) : aQ($) ? new Date(`1970-01-01T${$}.000Z`) : rQ($) ? new Date(`1970-01-01T${$}`) : $W($) ? new Date(`${$}.000Z`) : eQ($) ? new Date($) : JW($) ? new Date(`${$}T00:00:00.000Z`) : $;
  }, MW = function($, J, Y) {
    return Y;
  }, UW = function($, J, Y) {
    if (c.IsArray(Y))
      return Y.map((X) => o0($.items, J, X));
    return Y;
  }, BW = function($, J, Y) {
    return Y;
  }, AW = function($, J, Y) {
    return WW(Y);
  }, NW = function($, J, Y) {
    return n8(Y);
  }, wW = function($, J, Y) {
    return o8.Clone(Y);
  }, DW = function($, J, Y) {
    return FW(Y);
  }, KW = function($, J, Y) {
    return Y;
  }, PW = function($, J, Y) {
    return zW(Y);
  }, jW = function($, J, Y) {
    return Y;
  }, SW = function($, J, Y) {
    return Y;
  }, LW = function($, J, Y) {
    return QW($, Y);
  }, OW = function($, J, Y) {
    return Y;
  }, CW = function($, J, Y) {
    return HW(Y);
  }, IW = function($, J, Y) {
    return h8(Y);
  }, bW = function($, J, Y) {
    if (c.IsObject(Y))
      return Object.getOwnPropertyNames($.properties).reduce((X, Z) => {
        return Y[Z] !== undefined ? { ...X, [Z]: o0($.properties[Z], J, Y[Z]) } : { ...X };
      }, Y);
    return Y;
  }, _W = function($, J, Y) {
    return Y;
  }, RW = function($, J, Y) {
    const X = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X], Q = {};
    for (let [q, F] of Object.entries(Y))
      Q[q] = o0(Z, J, F);
    return Q;
  }, GW = function($, J, Y) {
    const X = J.findIndex((Q) => Q.$id === $.$ref);
    if (X === -1)
      throw new P$($);
    const Z = J[X];
    return o0(Z, J, Y);
  }, EW = function($, J, Y) {
    return u8(Y);
  }, xW = function($, J, Y) {
    return Y;
  }, VW = function($, J, Y) {
    return Y;
  }, kW = function($, J, Y) {
    const X = J.findIndex((Q) => Q.$id === $.$ref);
    if (X === -1)
      throw new P$($);
    const Z = J[X];
    return o0(Z, J, Y);
  }, gW = function($, J, Y) {
    if (c.IsArray(Y) && !c.IsUndefined($.items))
      return Y.map((X, Z) => {
        return Z < $.items.length ? o0($.items[Z], J, X) : X;
      });
    return Y;
  }, fW = function($, J, Y) {
    return qW(Y);
  }, TW = function($, J, Y) {
    for (let X of $.anyOf) {
      const Z = o0(X, J, Y);
      if (tQ.Check(X, J, Z))
        return Z;
    }
    return Y;
  }, dW = function($, J, Y) {
    return Y;
  }, yW = function($, J, Y) {
    return Y;
  }, vW = function($, J, Y) {
    return Y;
  }, iW = function($, J, Y) {
    return Y;
  }, o0 = function($, J, Y) {
    const X = c.IsString($.$id) ? [...J, $] : J, Z = $;
    switch ($[P4.Kind]) {
      case "Any":
        return MW(Z, X, Y);
      case "Array":
        return UW(Z, X, Y);
      case "AsyncIterator":
        return BW(Z, X, Y);
      case "BigInt":
        return AW(Z, X, Y);
      case "Boolean":
        return NW(Z, X, Y);
      case "Constructor":
        return wW(Z, X, Y);
      case "Date":
        return DW(Z, X, Y);
      case "Function":
        return KW(Z, X, Y);
      case "Integer":
        return PW(Z, X, Y);
      case "Intersect":
        return jW(Z, X, Y);
      case "Iterator":
        return SW(Z, X, Y);
      case "Literal":
        return LW(Z, X, Y);
      case "Never":
        return OW(Z, X, Y);
      case "Null":
        return CW(Z, X, Y);
      case "Number":
        return IW(Z, X, Y);
      case "Object":
        return bW(Z, X, Y);
      case "Promise":
        return _W(Z, X, Y);
      case "Record":
        return RW(Z, X, Y);
      case "Ref":
        return GW(Z, X, Y);
      case "String":
        return EW(Z, X, Y);
      case "Symbol":
        return xW(Z, X, Y);
      case "TemplateLiteral":
        return VW(Z, X, Y);
      case "This":
        return kW(Z, X, Y);
      case "Tuple":
        return gW(Z, X, Y);
      case "Undefined":
        return fW(Z, X, Y);
      case "Union":
        return TW(Z, X, Y);
      case "Uint8Array":
        return dW(Z, X, Y);
      case "Unknown":
        return yW(Z, X, Y);
      case "Void":
        return vW(Z, X, Y);
      default:
        if (!P4.TypeRegistry.Has(Z[P4.Kind]))
          throw new j4(Z);
        return iW(Z, X, Y);
    }
  }, pW = function(...$) {
    return $.length === 3 ? o0($[0], $[1], $[2]) : o0($[0], [], $[1]);
  };
  Object.defineProperty(c8, "__esModule", { value: true });
  c8.Convert = c8.ValueConvertDereferenceError = c8.ValueConvertUnknownTypeError = undefined;
  var P4 = G0(), o8 = E1(), tQ = n1(), c = L0();

  class j4 extends Error {
    constructor($) {
      super("ValueConvert: Unknown type");
      this.schema = $;
    }
  }
  c8.ValueConvertUnknownTypeError = j4;

  class P$ extends Error {
    constructor($) {
      super(`ValueConvert: Unable to dereference type with $id '${$.$ref}'`);
      this.schema = $;
    }
  }
  c8.ValueConvertDereferenceError = P$;
  c8.Convert = pW;
});
var Q6 = l((X6) => {
  Object.defineProperty(X6, "__esModule", { value: true });
  X6.Value = undefined;
  var s8 = m1(), nW = _8(), uW = p1(), hW = E8(), r8 = m8(), cW = E1(), a8 = t8(), e8 = A4(), $6 = n1(), J6 = Y4(), Y6;
  (function($) {
    function J(...D) {
      return r8.Cast.apply(r8, D);
    }
    $.Cast = J;
    function Y(...D) {
      return e8.Create.apply(e8, D);
    }
    $.Create = Y;
    function X(...D) {
      return $6.Check.apply($6, D);
    }
    $.Check = X;
    function Z(...D) {
      return a8.Convert.apply(a8, D);
    }
    $.Convert = Z;
    function Q(D) {
      return cW.Clone(D);
    }
    $.Clone = Q;
    function q(...D) {
      return s8.Errors.apply(s8, D);
    }
    $.Errors = q;
    function F(D, A) {
      return hW.Equal(D, A);
    }
    $.Equal = F;
    function B(D, A) {
      return J6.Diff(D, A);
    }
    $.Diff = B;
    function w(D) {
      return uW.Hash(D);
    }
    $.Hash = w;
    function N(D, A) {
      return J6.Patch(D, A);
    }
    $.Patch = N;
    function P(D, A) {
      nW.Mutate(D, A);
    }
    $.Mutate = P;
  })(Y6 || (X6.Value = Y6 = {}));
});
var S4 = l((V0) => {
  Object.defineProperty(V0, "__esModule", { value: true });
  V0.Value = V0.ValuePointer = V0.Delete = V0.Update = V0.Insert = V0.Edit = V0.ValueErrorIterator = V0.ValueErrorType = undefined;
  var W6 = m1();
  Object.defineProperty(V0, "ValueErrorType", { enumerable: true, get: function() {
    return W6.ValueErrorType;
  } });
  Object.defineProperty(V0, "ValueErrorIterator", { enumerable: true, get: function() {
    return W6.ValueErrorIterator;
  } });
  var S$ = Y4();
  Object.defineProperty(V0, "Edit", { enumerable: true, get: function() {
    return S$.Edit;
  } });
  Object.defineProperty(V0, "Insert", { enumerable: true, get: function() {
    return S$.Insert;
  } });
  Object.defineProperty(V0, "Update", { enumerable: true, get: function() {
    return S$.Update;
  } });
  Object.defineProperty(V0, "Delete", { enumerable: true, get: function() {
    return S$.Delete;
  } });
  var lW = F$();
  Object.defineProperty(V0, "ValuePointer", { enumerable: true, get: function() {
    return lW.ValuePointer;
  } });
  var tW = Q6();
  Object.defineProperty(V0, "Value", { enumerable: true, get: function() {
    return tW.Value;
  } });
});
var F6 = l((H6) => {
  Object.defineProperty(H6, "__esModule", { value: true });
  H6.TypeCompiler = H6.TypeCompilerTypeGuardError = H6.TypeCompilerDereferenceError = H6.TypeCompilerUnknownTypeError = H6.TypeCheck = undefined;
  var l1 = i1(), a = G0(), rW = m1(), aW = p1(), d = L0();

  class O4 {
    constructor($, J, Y, X) {
      this.schema = $, this.references = J, this.checkFunc = Y, this.code = X;
    }
    Code() {
      return this.code;
    }
    Errors($) {
      return rW.Errors(this.schema, this.references, $);
    }
    Check($) {
      return this.checkFunc($);
    }
  }
  H6.TypeCheck = O4;
  var n0;
  (function($) {
    function J(Q) {
      return Q === 36;
    }
    $.DollarSign = J;
    function Y(Q) {
      return Q === 95;
    }
    $.IsUnderscore = Y;
    function X(Q) {
      return Q >= 65 && Q <= 90 || Q >= 97 && Q <= 122;
    }
    $.IsAlpha = X;
    function Z(Q) {
      return Q >= 48 && Q <= 57;
    }
    $.IsNumeric = Z;
  })(n0 || (n0 = {}));
  var L$;
  (function($) {
    function J(Q) {
      if (Q.length === 0)
        return false;
      return n0.IsNumeric(Q.charCodeAt(0));
    }
    function Y(Q) {
      if (J(Q))
        return false;
      for (let q = 0;q < Q.length; q++) {
        const F = Q.charCodeAt(q);
        if (!(n0.IsAlpha(F) || n0.IsNumeric(F) || n0.DollarSign(F) || n0.IsUnderscore(F)))
          return false;
      }
      return true;
    }
    function X(Q) {
      return Q.replace(/'/g, "\\'");
    }
    function Z(Q, q) {
      return Y(q) ? `${Q}.${q}` : `${Q}['${X(q)}']`;
    }
    $.Encode = Z;
  })(L$ || (L$ = {}));
  var L4;
  (function($) {
    function J(Y) {
      const X = [];
      for (let Z = 0;Z < Y.length; Z++) {
        const Q = Y.charCodeAt(Z);
        if (n0.IsNumeric(Q) || n0.IsAlpha(Q))
          X.push(Y.charAt(Z));
        else
          X.push(`_${Q}_`);
      }
      return X.join("").replace(/__/g, "_");
    }
    $.Encode = J;
  })(L4 || (L4 = {}));

  class C4 extends Error {
    constructor($) {
      super("TypeCompiler: Unknown type");
      this.schema = $;
    }
  }
  H6.TypeCompilerUnknownTypeError = C4;

  class I4 extends Error {
    constructor($) {
      super(`TypeCompiler: Unable to dereference type with $id '${$.$ref}'`);
      this.schema = $;
    }
  }
  H6.TypeCompilerDereferenceError = I4;

  class O$ extends Error {
    constructor($) {
      super("TypeCompiler: Preflight validation check failed to guard for the given schema");
      this.schema = $;
    }
  }
  H6.TypeCompilerTypeGuardError = O$;
  var z6;
  (function($) {
    function J(U) {
      return U[a.Kind] === "Any" || U[a.Kind] === "Unknown";
    }
    function Y(U, j, W) {
      return l1.TypeSystem.ExactOptionalPropertyTypes ? `('${j}' in ${U} ? ${W} : true)` : `(${L$.Encode(U, j)} !== undefined ? ${W} : true)`;
    }
    function X(U) {
      return !l1.TypeSystem.AllowArrayObjects ? `(typeof ${U} === 'object' && ${U} !== null && !Array.isArray(${U}))` : `(typeof ${U} === 'object' && ${U} !== null)`;
    }
    function Z(U) {
      return !l1.TypeSystem.AllowArrayObjects ? `(typeof ${U} === 'object' && ${U} !== null && !Array.isArray(${U}) && !(${U} instanceof Date) && !(${U} instanceof Uint8Array))` : `(typeof ${U} === 'object' && ${U} !== null && !(${U} instanceof Date) && !(${U} instanceof Uint8Array))`;
    }
    function Q(U) {
      return !l1.TypeSystem.AllowNaN ? `(typeof ${U} === 'number' && Number.isFinite(${U}))` : `typeof ${U} === 'number'`;
    }
    function q(U) {
      return l1.TypeSystem.AllowVoidNull ? `(${U} === undefined || ${U} === null)` : `${U} === undefined`;
    }
    function* F(U, j, W) {
      yield "true";
    }
    function* B(U, j, W) {
      yield `Array.isArray(${W})`;
      const [b, C] = [_0("value", "any"), _0("acc", "number")];
      if (d.IsNumber(U.minItems))
        yield `${W}.length >= ${U.minItems}`;
      if (d.IsNumber(U.maxItems))
        yield `${W}.length <= ${U.maxItems}`;
      const E = Y0(U.items, j, "value");
      if (yield `${W}.every((${b}) => ${E})`, a.TypeGuard.TSchema(U.contains) || d.IsNumber(U.minContains) || d.IsNumber(U.maxContains)) {
        const h = a.TypeGuard.TSchema(U.contains) ? U.contains : a.Type.Never(), z0 = Y0(h, j, "value"), N0 = d.IsNumber(U.minContains) ? [`(count >= ${U.minContains})`] : [], w0 = d.IsNumber(U.maxContains) ? [`(count <= ${U.maxContains})`] : [], D0 = `const count = ${W}.reduce((${C}, ${b}) => ${z0} ? acc + 1 : acc, 0)`, K1 = ["(count > 0)", ...N0, ...w0].join(" && ");
        yield `((${b}) => { ${D0}; return ${K1}})(${W})`;
      }
      if (U.uniqueItems === true)
        yield `((${b}) => { const set = new Set(); for(const element of value) { const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true } )(${W})`;
    }
    function* w(U, j, W) {
      yield `(typeof value === 'object' && Symbol.asyncIterator in ${W})`;
    }
    function* N(U, j, W) {
      if (yield `(typeof ${W} === 'bigint')`, d.IsBigInt(U.multipleOf))
        yield `(${W} % BigInt(${U.multipleOf})) === 0`;
      if (d.IsBigInt(U.exclusiveMinimum))
        yield `${W} > BigInt(${U.exclusiveMinimum})`;
      if (d.IsBigInt(U.exclusiveMaximum))
        yield `${W} < BigInt(${U.exclusiveMaximum})`;
      if (d.IsBigInt(U.minimum))
        yield `${W} >= BigInt(${U.minimum})`;
      if (d.IsBigInt(U.maximum))
        yield `${W} <= BigInt(${U.maximum})`;
    }
    function* P(U, j, W) {
      yield `(typeof ${W} === 'boolean')`;
    }
    function* D(U, j, W) {
      yield* A0(U.returns, j, `${W}.prototype`);
    }
    function* A(U, j, W) {
      if (yield `(${W} instanceof Date) && Number.isFinite(${W}.getTime())`, d.IsNumber(U.exclusiveMinimumTimestamp))
        yield `${W}.getTime() > ${U.exclusiveMinimumTimestamp}`;
      if (d.IsNumber(U.exclusiveMaximumTimestamp))
        yield `${W}.getTime() < ${U.exclusiveMaximumTimestamp}`;
      if (d.IsNumber(U.minimumTimestamp))
        yield `${W}.getTime() >= ${U.minimumTimestamp}`;
      if (d.IsNumber(U.maximumTimestamp))
        yield `${W}.getTime() <= ${U.maximumTimestamp}`;
    }
    function* L(U, j, W) {
      yield `(typeof ${W} === 'function')`;
    }
    function* O(U, j, W) {
      if (yield `(typeof ${W} === 'number' && Number.isInteger(${W}))`, d.IsNumber(U.multipleOf))
        yield `(${W} % ${U.multipleOf}) === 0`;
      if (d.IsNumber(U.exclusiveMinimum))
        yield `${W} > ${U.exclusiveMinimum}`;
      if (d.IsNumber(U.exclusiveMaximum))
        yield `${W} < ${U.exclusiveMaximum}`;
      if (d.IsNumber(U.minimum))
        yield `${W} >= ${U.minimum}`;
      if (d.IsNumber(U.maximum))
        yield `${W} <= ${U.maximum}`;
    }
    function* G(U, j, W) {
      const b = U.allOf.map((C) => Y0(C, j, W)).join(" && ");
      if (U.unevaluatedProperties === false) {
        const C = d0(`${new RegExp(a.KeyResolver.ResolvePattern(U))};`), E = `Object.getOwnPropertyNames(${W}).every(key => ${C}.test(key))`;
        yield `(${b} && ${E})`;
      } else if (a.TypeGuard.TSchema(U.unevaluatedProperties)) {
        const C = d0(`${new RegExp(a.KeyResolver.ResolvePattern(U))};`), E = `Object.getOwnPropertyNames(${W}).every(key => ${C}.test(key) || ${Y0(U.unevaluatedProperties, j, `${W}[key]`)})`;
        yield `(${b} && ${E})`;
      } else
        yield `(${b})`;
    }
    function* R(U, j, W) {
      yield `(typeof value === 'object' && Symbol.iterator in ${W})`;
    }
    function* k(U, j, W) {
      if (typeof U.const === "number" || typeof U.const === "boolean")
        yield `(${W} === ${U.const})`;
      else
        yield `(${W} === '${U.const}')`;
    }
    function* y(U, j, W) {
      yield "false";
    }
    function* S(U, j, W) {
      yield `(!${Y0(U.not, j, W)})`;
    }
    function* V(U, j, W) {
      yield `(${W} === null)`;
    }
    function* T(U, j, W) {
      if (yield Q(W), d.IsNumber(U.multipleOf))
        yield `(${W} % ${U.multipleOf}) === 0`;
      if (d.IsNumber(U.exclusiveMinimum))
        yield `${W} > ${U.exclusiveMinimum}`;
      if (d.IsNumber(U.exclusiveMaximum))
        yield `${W} < ${U.exclusiveMaximum}`;
      if (d.IsNumber(U.minimum))
        yield `${W} >= ${U.minimum}`;
      if (d.IsNumber(U.maximum))
        yield `${W} <= ${U.maximum}`;
    }
    function* M0(U, j, W) {
      if (yield X(W), d.IsNumber(U.minProperties))
        yield `Object.getOwnPropertyNames(${W}).length >= ${U.minProperties}`;
      if (d.IsNumber(U.maxProperties))
        yield `Object.getOwnPropertyNames(${W}).length <= ${U.maxProperties}`;
      const b = Object.getOwnPropertyNames(U.properties);
      for (let C of b) {
        const E = L$.Encode(W, C), h = U.properties[C];
        if (U.required && U.required.includes(C)) {
          if (yield* A0(h, j, E), a.ExtendsUndefined.Check(h) || J(h))
            yield `('${C}' in ${W})`;
        } else {
          const z0 = Y0(h, j, E);
          yield Y(W, C, z0);
        }
      }
      if (U.additionalProperties === false)
        if (U.required && U.required.length === b.length)
          yield `Object.getOwnPropertyNames(${W}).length === ${b.length}`;
        else {
          const C = `[${b.map((E) => `'${E}'`).join(", ")}]`;
          yield `Object.getOwnPropertyNames(${W}).every(key => ${C}.includes(key))`;
        }
      if (typeof U.additionalProperties === "object") {
        const C = Y0(U.additionalProperties, j, `${W}[key]`), E = `[${b.map((h) => `'${h}'`).join(", ")}]`;
        yield `(Object.getOwnPropertyNames(${W}).every(key => ${E}.includes(key) || ${C}))`;
      }
    }
    function* J0(U, j, W) {
      yield `(typeof value === 'object' && typeof ${W}.then === 'function')`;
    }
    function* X1(U, j, W) {
      if (yield Z(W), d.IsNumber(U.minProperties))
        yield `Object.getOwnPropertyNames(${W}).length >= ${U.minProperties}`;
      if (d.IsNumber(U.maxProperties))
        yield `Object.getOwnPropertyNames(${W}).length <= ${U.maxProperties}`;
      const [b, C] = Object.entries(U.patternProperties)[0], E = d0(`new RegExp(/${b}/)`), h = Y0(C, j, "value"), z0 = a.TypeGuard.TSchema(U.additionalProperties) ? Y0(U.additionalProperties, j, W) : U.additionalProperties === false ? "false" : "true", N0 = `(${E}.test(key) ? ${h} : ${z0})`;
      yield `(Object.entries(${W}).every(([key, value]) => ${N0}))`;
    }
    function* b0(U, j, W) {
      const b = j.findIndex((E) => E.$id === U.$ref);
      if (b === -1)
        throw new I4(U);
      const C = j[b];
      if (r.functions.has(U.$ref))
        return yield `${t(U.$ref)}(${W})`;
      yield* A0(C, j, W);
    }
    function* T0(U, j, W) {
      if (yield `(typeof ${W} === 'string')`, d.IsNumber(U.minLength))
        yield `${W}.length >= ${U.minLength}`;
      if (d.IsNumber(U.maxLength))
        yield `${W}.length <= ${U.maxLength}`;
      if (U.pattern !== undefined)
        yield `${d0(`${new RegExp(U.pattern)};`)}.test(${W})`;
      if (U.format !== undefined)
        yield `format('${U.format}', ${W})`;
    }
    function* e(U, j, W) {
      yield `(typeof ${W} === 'symbol')`;
    }
    function* Z1(U, j, W) {
      yield `(typeof ${W} === 'string')`, yield `${d0(`${new RegExp(U.pattern)};`)}.test(${W})`;
    }
    function* Q1(U, j, W) {
      yield `${t(U.$ref)}(${W})`;
    }
    function* c0(U, j, W) {
      if (yield `Array.isArray(${W})`, U.items === undefined)
        return yield `${W}.length === 0`;
      yield `(${W}.length === ${U.maxItems})`;
      for (let b = 0;b < U.items.length; b++)
        yield `${Y0(U.items[b], j, `${W}[${b}]`)}`;
    }
    function* W1(U, j, W) {
      yield `${W} === undefined`;
    }
    function* U1(U, j, W) {
      yield `(${U.anyOf.map((C) => Y0(C, j, W)).join(" || ")})`;
    }
    function* B1(U, j, W) {
      if (yield `${W} instanceof Uint8Array`, d.IsNumber(U.maxByteLength))
        yield `(${W}.length <= ${U.maxByteLength})`;
      if (d.IsNumber(U.minByteLength))
        yield `(${W}.length >= ${U.minByteLength})`;
    }
    function* A1(U, j, W) {
      yield "true";
    }
    function* N1(U, j, W) {
      yield q(W);
    }
    function* w1(U, j, W) {
      const b = r.instances.size;
      r.instances.set(b, U), yield `kind('${U[a.Kind]}', ${b}, ${W})`;
    }
    function* A0(U, j, W, b = true) {
      const C = d.IsString(U.$id) ? [...j, U] : j, E = U;
      if (b && d.IsString(U.$id)) {
        const h = t(U.$id);
        if (r.functions.has(h))
          return yield `${h}(${W})`;
        else {
          const z0 = l0(h, U, j, "value", false);
          return r.functions.set(h, z0), yield `${h}(${W})`;
        }
      }
      switch (E[a.Kind]) {
        case "Any":
          return yield* F(E, C, W);
        case "Array":
          return yield* B(E, C, W);
        case "AsyncIterator":
          return yield* w(E, C, W);
        case "BigInt":
          return yield* N(E, C, W);
        case "Boolean":
          return yield* P(E, C, W);
        case "Constructor":
          return yield* D(E, C, W);
        case "Date":
          return yield* A(E, C, W);
        case "Function":
          return yield* L(E, C, W);
        case "Integer":
          return yield* O(E, C, W);
        case "Intersect":
          return yield* G(E, C, W);
        case "Iterator":
          return yield* R(E, C, W);
        case "Literal":
          return yield* k(E, C, W);
        case "Never":
          return yield* y(E, C, W);
        case "Not":
          return yield* S(E, C, W);
        case "Null":
          return yield* V(E, C, W);
        case "Number":
          return yield* T(E, C, W);
        case "Object":
          return yield* M0(E, C, W);
        case "Promise":
          return yield* J0(E, C, W);
        case "Record":
          return yield* X1(E, C, W);
        case "Ref":
          return yield* b0(E, C, W);
        case "String":
          return yield* T0(E, C, W);
        case "Symbol":
          return yield* e(E, C, W);
        case "TemplateLiteral":
          return yield* Z1(E, C, W);
        case "This":
          return yield* Q1(E, C, W);
        case "Tuple":
          return yield* c0(E, C, W);
        case "Undefined":
          return yield* W1(E, C, W);
        case "Union":
          return yield* U1(E, C, W);
        case "Uint8Array":
          return yield* B1(E, C, W);
        case "Unknown":
          return yield* A1(E, C, W);
        case "Void":
          return yield* N1(E, C, W);
        default:
          if (!a.TypeRegistry.Has(E[a.Kind]))
            throw new C4(U);
          return yield* w1(E, C, W);
      }
    }
    const r = { language: "javascript", functions: new Map, variables: new Map, instances: new Map };
    function Y0(U, j, W, b = true) {
      return `(${[...A0(U, j, W, b)].join(" && ")})`;
    }
    function t(U) {
      return `check_${L4.Encode(U)}`;
    }
    function d0(U) {
      const j = `local_${r.variables.size}`;
      return r.variables.set(j, `const ${j} = ${U}`), j;
    }
    function l0(U, j, W, b, C = true) {
      const [E, h] = ["\n", (D0) => "".padStart(D0, " ")], z0 = _0("value", "any"), N0 = y0("boolean"), w0 = [...A0(j, W, b, C)].map((D0) => `${h(4)}${D0}`).join(` &&${E}`);
      return `function ${U}(${z0})${N0} {${E}${h(2)}return (${E}${w0}${E}${h(2)})\n}`;
    }
    function _0(U, j) {
      const W = r.language === "typescript" ? `: ${j}` : "";
      return `${U}${W}`;
    }
    function y0(U) {
      return r.language === "typescript" ? `: ${U}` : "";
    }
    function X0(U, j, W) {
      const b = l0("check", U, j, "value"), C = _0("value", "any"), E = y0("boolean"), h = [...r.functions.values()], z0 = [...r.variables.values()], N0 = d.IsString(U.$id) ? `return function check(${C})${E} {\n  return ${t(U.$id)}(value)\n}` : `return ${b}`;
      return [...z0, ...h, N0].join("\n");
    }
    function z1(...U) {
      const j = { language: "javascript" }, [W, b, C] = U.length === 2 && d.IsArray(U[1]) ? [U[0], U[1], j] : U.length === 2 && !d.IsArray(U[1]) ? [U[0], [], U[1]] : U.length === 3 ? [U[0], U[1], U[2]] : U.length === 1 ? [U[0], [], j] : [null, [], j];
      if (r.language = C.language, r.variables.clear(), r.functions.clear(), r.instances.clear(), !a.TypeGuard.TSchema(W))
        throw new O$(W);
      for (let E of b)
        if (!a.TypeGuard.TSchema(E))
          throw new O$(E);
      return X0(W, b, C);
    }
    $.Code = z1;
    function D1(U, j = []) {
      const W = z1(U, j, { language: "javascript" }), b = globalThis.Function("kind", "format", "hash", W), C = new Map(r.instances);
      function E(w0, D0, K1) {
        if (!a.TypeRegistry.Has(w0) || !C.has(D0))
          return false;
        const x$ = C.get(D0);
        return a.TypeRegistry.Get(w0)(x$, K1);
      }
      function h(w0, D0) {
        if (!a.FormatRegistry.Has(w0))
          return false;
        return a.FormatRegistry.Get(w0)(D0);
      }
      function z0(w0) {
        return aW.Hash(w0);
      }
      const N0 = b(E, h, z0);
      return new O4(U, j, N0, W);
    }
    $.Compile = D1;
  })(z6 || (H6.TypeCompiler = z6 = {}));
});
var M6 = l((u0) => {
  var Xz = u0 && u0.__createBinding || (Object.create ? function($, J, Y, X) {
    if (X === undefined)
      X = Y;
    var Z = Object.getOwnPropertyDescriptor(J, Y);
    if (!Z || ("get" in Z ? !J.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return J[Y];
      } };
    Object.defineProperty($, X, Z);
  } : function($, J, Y, X) {
    if (X === undefined)
      X = Y;
    $[X] = J[Y];
  }), Zz = u0 && u0.__exportStar || function($, J) {
    for (var Y in $)
      if (Y !== "default" && !Object.prototype.hasOwnProperty.call(J, Y))
        Xz(J, $, Y);
  };
  Object.defineProperty(u0, "__esModule", { value: true });
  u0.ValueErrorType = undefined;
  var Qz = m1();
  Object.defineProperty(u0, "ValueErrorType", { enumerable: true, get: function() {
    return Qz.ValueErrorType;
  } });
  Zz(F6(), u0);
});
var w6 = l((az, N6) => {
  var zz = function($) {
    var J = $.indexOf("%");
    if (J === -1)
      return $;
    var Y = $.length, X = "", Z = 0, Q = 0, q = J, F = B6;
    while (J > -1 && J < Y) {
      var B = A6($[J + 1], 4), w = A6($[J + 2], 0), N = B | w, P = E4[N];
      if (F = E4[256 + F + P], Q = Q << 6 | N & E4[364 + P], F === B6)
        X += $.slice(Z, q), X += Q <= 65535 ? String.fromCharCode(Q) : String.fromCharCode(55232 + (Q >> 10), 56320 + (Q & 1023)), Q = 0, Z = J + 3, J = q = $.indexOf("%", Z);
      else if (F === Wz)
        return null;
      else {
        if (J += 3, J < Y && $.charCodeAt(J) === 37)
          continue;
        return null;
      }
    }
    return X + $.slice(Z);
  }, A6 = function($, J) {
    var Y = Hz[$];
    return Y === undefined ? 255 : Y << J;
  }, B6 = 12, Wz = 0, E4 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7], Hz = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  N6.exports = zz;
});
var S6 = l((ez, j6) => {
  var qz = function($) {
    const J = new P6;
    if (typeof $ !== "string")
      return J;
    let Y = $.length, X = "", Z = "", Q = -1, q = -1, F = false, B = false, w = false, N = false, P = false, D = 0;
    for (let A = 0;A < Y + 1; A++)
      if (D = A !== Y ? $.charCodeAt(A) : 38, D === 38) {
        if (P = q > Q, !P)
          q = A;
        if (X = $.slice(Q + 1, q), P || X.length > 0) {
          if (w)
            X = X.replace(K6, " ");
          if (F)
            X = D6(X) || X;
          if (P) {
            if (Z = $.slice(q + 1, A), N)
              Z = Z.replace(K6, " ");
            if (B)
              Z = D6(Z) || Z;
          }
          const L = J[X];
          if (L === undefined)
            J[X] = Z;
          else if (L.pop)
            L.push(Z);
          else
            J[X] = [L, Z];
        }
        Z = "", Q = A, q = A, F = false, B = false, w = false, N = false;
      } else if (D === 61)
        if (q <= Q)
          q = A;
        else
          B = true;
      else if (D === 43)
        if (q > Q)
          N = true;
        else
          w = true;
      else if (D === 37)
        if (q > Q)
          B = true;
        else
          F = true;
    return J;
  }, D6 = w6(), K6 = /\+/g, P6 = function() {
  };
  P6.prototype = Object.create(null);
  j6.exports = qz;
});
var O6 = l(($9, L6) => {
  var Mz = function($) {
    const J = $.length;
    if (J === 0)
      return "";
    let Y = "", X = 0, Z = 0;
    $:
      for (;Z < J; Z++) {
        let Q = $.charCodeAt(Z);
        while (Q < 128) {
          if (Fz[Q] !== 1) {
            if (X < Z)
              Y += $.slice(X, Z);
            X = Z + 1, Y += g0[Q];
          }
          if (++Z === J)
            break $;
          Q = $.charCodeAt(Z);
        }
        if (X < Z)
          Y += $.slice(X, Z);
        if (Q < 2048) {
          X = Z + 1, Y += g0[192 | Q >> 6] + g0[128 | Q & 63];
          continue;
        }
        if (Q < 55296 || Q >= 57344) {
          X = Z + 1, Y += g0[224 | Q >> 12] + g0[128 | Q >> 6 & 63] + g0[128 | Q & 63];
          continue;
        }
        if (++Z, Z >= J)
          throw new Error("URI malformed");
        const q = $.charCodeAt(Z) & 1023;
        X = Z + 1, Q = 65536 + ((Q & 1023) << 10 | q), Y += g0[240 | Q >> 18] + g0[128 | Q >> 12 & 63] + g0[128 | Q >> 6 & 63] + g0[128 | Q & 63];
      }
    if (X === 0)
      return $;
    if (X < J)
      return Y + $.slice(X);
    return Y;
  }, g0 = Array.from({ length: 256 }, ($, J) => "%" + ((J < 16 ? "0" : "") + J.toString(16)).toUpperCase()), Fz = new Int8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0]);
  L6.exports = { encodeString: Mz };
});
var b6 = l((J9, I6) => {
  var C6 = function($) {
    const J = typeof $;
    if (J === "string")
      return x4($);
    else if (J === "bigint")
      return $.toString();
    else if (J === "boolean")
      return $ ? "true" : "false";
    else if (J === "number" && Number.isFinite($))
      return $ < 1000000000000000000000 ? "" + $ : x4("" + $);
    return "";
  }, Uz = function($) {
    let J = "";
    if ($ === null || typeof $ !== "object")
      return J;
    const Y = "&", X = Object.keys($), Z = X.length;
    let Q = 0;
    for (let q = 0;q < Z; q++) {
      const F = X[q], B = $[F], w = x4(F) + "=";
      if (q)
        J += Y;
      if (Array.isArray(B)) {
        Q = B.length;
        for (let N = 0;N < Q; N++) {
          if (N)
            J += Y;
          J += w, J += C6(B[N]);
        }
      } else
        J += w, J += C6(B);
    }
    return J;
  }, { encodeString: x4 } = O6();
  I6.exports = Uz;
});
var V4 = l((Y9, s1) => {
  var _6 = S6(), R6 = b6(), G6 = { parse: _6, stringify: R6 };
  s1.exports = G6;
  s1.exports.default = G6;
  s1.exports.parse = _6;
  s1.exports.stringify = R6;
});
var P1 = ($, J) => ({ part: $, store: null, inert: J !== undefined ? new Map(J.map((Y) => [Y.part.charCodeAt(0), Y])) : null, params: null, wildcardStore: null });
var v4 = ($, J) => ({ ...$, part: J });
var i4 = ($) => ({ paramName: $, store: null, inert: null });

class s0 {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g };
  add($, J, Y) {
    let X;
    if (typeof J != "string")
      throw TypeError("Route path must be a string");
    J === "" ? J = "/" : J[0] !== "/" && (J = `/${J}`), this.history.push([$, J, Y]);
    let Z = J[J.length - 1] === "*";
    Z && (J = J.slice(0, -1));
    let Q = J.split(s0.regex.static), q = J.match(s0.regex.params) || [];
    Q[Q.length - 1] === "" && Q.pop(), X = this.root[$] ? this.root[$] : this.root[$] = P1("/");
    let F = 0;
    for (let B = 0;B < Q.length; ++B) {
      let w = Q[B];
      if (B > 0) {
        let N = q[F++].slice(1);
        if (X.params === null)
          X.params = i4(N);
        else if (X.params.paramName !== N)
          throw Error(`Cannot create route "${J}" with parameter "${N}" because a route already exists with a different parameter name ("${X.params.paramName}") in the same location`);
        let P = X.params;
        if (P.inert === null) {
          X = P.inert = P1(w);
          continue;
        }
        X = P.inert;
      }
      for (let N = 0;; ) {
        if (N === w.length) {
          if (N < X.part.length) {
            let P = v4(X, X.part.slice(N));
            Object.assign(X, P1(w, [P]));
          }
          break;
        }
        if (N === X.part.length) {
          if (X.inert === null)
            X.inert = new Map;
          else if (X.inert.has(w.charCodeAt(N))) {
            X = X.inert.get(w.charCodeAt(N)), w = w.slice(N), N = 0;
            continue;
          }
          let P = P1(w.slice(N));
          X.inert.set(w.charCodeAt(N), P), X = P;
          break;
        }
        if (w[N] !== X.part[N]) {
          let P = v4(X, X.part.slice(N)), D = P1(w.slice(N));
          Object.assign(X, P1(X.part.slice(0, N), [P, D])), X = D;
          break;
        }
        ++N;
      }
    }
    if (F < q.length) {
      let B = q[F], w = B.slice(1);
      if (X.params === null)
        X.params = i4(w);
      else if (X.params.paramName !== w)
        throw Error(`Cannot create route "${J}" with parameter "${w}" because a route already exists with a different parameter name ("${X.params.paramName}") in the same location`);
      return X.params.store === null && (X.params.store = Y), X.params.store;
    }
    return Z ? (X.wildcardStore === null && (X.wildcardStore = Y), X.wildcardStore) : (X.store === null && (X.store = Y), X.store);
  }
  find($, J) {
    let Y = this.root[$];
    return Y ? V$(J, J.length, Y, 0) : null;
  }
}
var V$ = ($, J, Y, X) => {
  let Z = Y?.part, Q = X + Z.length;
  if (Z.length > 1) {
    if (Q > J)
      return null;
    if (Z.length < 15) {
      for (let q = 1, F = X + 1;q < Z.length; ++q, ++F)
        if (Z.charCodeAt(q) !== $.charCodeAt(F))
          return null;
    } else if ($.substring(X, Q) !== Z)
      return null;
  }
  if (Q === J)
    return Y.store !== null ? { store: Y.store, params: {} } : Y.wildcardStore !== null ? { store: Y.wildcardStore, params: { "*": "" } } : null;
  if (Y.inert !== null) {
    let q = Y.inert.get($.charCodeAt(Q));
    if (q !== undefined) {
      let F = V$($, J, q, Q);
      if (F !== null)
        return F;
    }
  }
  if (Y.params !== null) {
    let q = Y.params, F = $.indexOf("/", Q);
    if (F !== Q) {
      if (F === -1 || F >= J) {
        if (q.store !== null) {
          let B = {};
          return B[q.paramName] = $.substring(Q, J), { store: q.store, params: B };
        }
      } else if (q.inert !== null) {
        let B = V$($, J, q.inert, F);
        if (B !== null)
          return B.params[q.paramName] = $.substring(Q, F), B;
      }
    }
  }
  return Y.wildcardStore !== null ? { store: Y.wildcardStore, params: { "*": $.substring(Q, J) } } : null;
};
var C$ = t0(G0(), 1);
var t1 = t0(S4(), 1);
var _4 = t0(M6(), 1);
var F0 = ($, J) => {
  const Y = [...Array.isArray($) ? $ : [$]], X = [];
  for (let Z of Y)
    if (Z.$elysiaChecksum)
      X.push(Z.$elysiaChecksum);
  for (let Z of Array.isArray(J) ? J : [J])
    if (!X.includes(Z?.$elysiaChecksum))
      Y.push(Z);
  return Y;
};
var e0 = ($, J) => {
  return { body: J?.body ?? $?.body, headers: J?.headers ?? $?.headers, params: J?.params ?? $?.params, query: J?.query ?? $?.query, response: J?.response ?? $?.response, type: $?.type || J?.type, detail: k0(J?.detail ?? {}, $?.detail ?? {}), parse: F0($.parse ?? [], J?.parse ?? []), transform: F0($.transform ?? [], J?.transform ?? []), beforeHandle: F0($.beforeHandle ?? [], J?.beforeHandle ?? []), afterHandle: F0($.afterHandle ?? [], J?.afterHandle ?? []), onResponse: F0($.onResponse ?? [], J?.onResponse ?? []), error: F0($.error ?? [], J?.error ?? []) };
};
var b4 = ($) => $ && typeof $ === "object" && !Array.isArray($);
var k0 = ($, J) => {
  const Y = Object.assign({}, $);
  if (b4($) && b4(J))
    Object.keys(J).forEach((X) => {
      if (b4(J[X]))
        if (!(X in $))
          Object.assign(Y, { [X]: J[X] });
        else
          Y[X] = k0($[X], J[X]);
      else
        Object.assign(Y, { [X]: J[X] });
    });
  return Y;
};
var I0 = ($, { models: J = {}, additionalProperties: Y = false, dynamic: X = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in J))
    return;
  const Z = typeof $ === "string" ? J[$] : $;
  if (Z.type === "object" && ("additionalProperties" in Z) === false)
    Z.additionalProperties = Y;
  if (X)
    return { schema: Z, references: "", checkFunc: () => {
    }, code: "", Check: (Q) => t1.Value.Check(Z, Q), Errors: (Q) => t1.Value.Errors(Z, Q), Code: () => "" };
  return _4.TypeCompiler.Compile(Z);
};
var R4 = ($, { models: J = {}, additionalProperties: Y = false, dynamic: X = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in J))
    return;
  const Z = typeof $ === "string" ? J[$] : $, Q = (F) => {
    if (X)
      return { schema: F, references: "", checkFunc: () => {
      }, code: "", Check: (B) => t1.Value.Check(F, B), Errors: (B) => t1.Value.Errors(F, B), Code: () => "" };
    return _4.TypeCompiler.Compile(F);
  };
  if (C$.Kind in Z)
    return { 200: Q(Z) };
  const q = {};
  return Object.keys(Z).forEach((F) => {
    const B = Z[F];
    if (typeof B === "string") {
      if (B in J) {
        const w = J[B];
        w.type === "object" && ("additionalProperties" in w), q[+F] = (C$.Kind in w) ? Q(w) : w;
      }
      return;
    }
    if (B.type === "object" && ("additionalProperties" in B) === false)
      B.additionalProperties = Y;
    q[+F] = (C$.Kind in B) ? Q(B) : B;
  }), q;
};
var G4 = ($) => {
  let J = 9;
  for (let Y = 0;Y < $.length; )
    J = Math.imul(J ^ $.charCodeAt(Y++), 387420489);
  return J = J ^ J >>> 9;
};
var f1 = ($, J, Y) => {
  const X = (Z) => {
    if (Y)
      Z.$elysiaChecksum = Y;
    return Z;
  };
  return { start: F0($.start, ("start" in J ? J.start : []).map(X)), request: F0($.request, ("request" in J ? J.request : []).map(X)), parse: F0($.parse, J?.parse ?? []).map(X), transform: F0($.transform, (J?.transform ?? []).map(X)), beforeHandle: F0($.beforeHandle, (J?.beforeHandle ?? []).map(X)), afterHandle: F0($.afterHandle, (J?.afterHandle ?? []).map(X)), onResponse: F0($.onResponse, (J?.onResponse ?? []).map(X)), error: F0($.error, (J?.error ?? []).map(X)), stop: F0($.stop, ("stop" in J ? J.stop : []).map(X)) };
};
var k1 = ($) => {
  if (!$)
    return $;
  if (typeof $ === "function")
    return $.$elysiaHookType = "inline", $;
  return $.map((J) => {
    return J.$elysiaHookType = "inline", J;
  });
};
var S0 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: k1($?.parse), transform: k1($?.transform), beforeHandle: k1($?.beforeHandle), afterHandle: k1($?.afterHandle), onResponse: k1($?.onResponse), error: k1($?.error) };
};
var g1 = ($) => {
  if (!$)
    return $;
  if (typeof $ === "function")
    return $.$elysiaHookType === "inline" ? $ : undefined;
  return $.filter((J) => J.$elysiaHookType === "inline");
};
var U6 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: g1($?.parse), transform: g1($?.transform), beforeHandle: g1($?.beforeHandle), afterHandle: g1($?.afterHandle), onResponse: g1($?.onResponse), error: g1($?.error) };
};
var g6 = t0(V4(), 1);
var E6 = ($) => {
  for (let J in $)
    return true;
  return false;
};
var x6 = ($, J) => {
  $.delete("Set-Cookie");
  for (let Y = 0;Y < J.length; Y++) {
    const X = J[Y].indexOf("=");
    $.append("Set-Cookie", `${J[Y].slice(0, X)}=${J[Y].slice(X + 1)}`);
  }
  return $;
};
var f0 = ($, J) => {
  if (E6(J.headers) || J.status !== 200 || J.redirect) {
    if (J.redirect)
      J.headers.Location = J.redirect, J.status = 302;
    if (J.headers["Set-Cookie"] && Array.isArray(J.headers["Set-Cookie"]))
      J.headers = x6(new Headers(J.headers), J.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, J);
      case "Object":
      case "Array":
        return Response.json($, J);
      case undefined:
        if (!$)
          return;
        return Response.json($, J);
      case "Response":
        for (let X in J.headers)
          $.headers.append(X, J.headers[X]);
        return $;
      case "Promise":
        return $.then((X) => {
          const Z = f0(X, J);
          if (Z !== undefined)
            return Z;
          return;
        });
      case "Error":
        return r1($, J.headers);
      case "Function":
        return $();
      case "Number":
      case "Boolean":
        return new Response($.toString(), J);
      default:
        if ($ instanceof Response)
          return $;
        const Y = JSON.stringify($);
        if (Y.charCodeAt(0) === 123) {
          if (!J.headers["Content-Type"])
            J.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), J);
        }
        return new Response(Y, J);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Promise":
        return $.then((X) => {
          const Z = f0(X, J);
          if (Z !== undefined)
            return Z;
          return;
        });
      case "Error":
        return r1($, J.headers);
      case "Function":
        return $();
      case "Number":
      case "Boolean":
        return new Response($.toString());
      default:
        if ($ instanceof Response)
          return $;
        const Y = JSON.stringify($);
        if (Y.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(Y);
    }
};
var h0 = ($, J) => {
  if (E6(J.headers) || J.status !== 200 || J.redirect) {
    if (J.redirect)
      J.headers.Location = J.redirect, J.status = 302;
    if (J.headers["Set-Cookie"] && Array.isArray(J.headers["Set-Cookie"]))
      J.headers = x6(new Headers(J.headers), J.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, { status: J.status, headers: J.headers });
      case "Object":
      case "Array":
        return Response.json($, J);
      case undefined:
        if (!$)
          return new Response("", J);
        return Response.json($, J);
      case "Response":
        for (let X in J.headers)
          $.headers.append(X, J.headers[X]);
        return $;
      case "Error":
        return r1($, J.headers);
      case "Promise":
        return $.then((X) => h0(X, J));
      case "Function":
        return $();
      case "Number":
      case "Boolean":
        return new Response($.toString(), J);
      default:
        if ($ instanceof Response)
          return $;
        const Y = JSON.stringify($);
        if (Y.charCodeAt(0) === 123) {
          if (!J.headers["Content-Type"])
            J.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), J);
        }
        return new Response(Y, J);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Error":
        return r1($);
      case "Promise":
        return $.then((X) => {
          const Z = h0(X, J);
          if (Z !== undefined)
            return Z;
          return new Response("");
        });
      case "Function":
        return $();
      case "Number":
      case "Boolean":
        return new Response($.toString());
      default:
        if ($ instanceof Response)
          return $;
        const Y = JSON.stringify($);
        if (Y.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(Y);
    }
};
var I$ = ($) => {
  switch ($?.constructor?.name) {
    case "String":
    case "Blob":
      return new Response($);
    case "Object":
    case "Array":
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case undefined:
      if (!$)
        return new Response("");
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "Response":
      return $;
    case "Error":
      return r1($);
    case "Promise":
      return $.then((Y) => {
        const X = I$(Y);
        if (X !== undefined)
          return X;
        return new Response("");
      });
    case "Function":
      return $();
    case "Number":
    case "Boolean":
      return new Response($.toString());
    default:
      if ($ instanceof Response)
        return $;
      const J = JSON.stringify($);
      if (J.charCodeAt(0) === 123)
        return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
      return new Response(J);
  }
};
var r1 = ($, J) => new Response(JSON.stringify({ name: $?.name, message: $?.message, cause: $?.cause }), { status: 500, headers: J });
var k4 = t0(S4(), 1);
var V6 = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var $1 = Symbol("ErrorCode");
var a1 = (V6?.NODE_ENV ?? V6?.ENV) === "production";

class b$ extends Error {
  code = "NOT_FOUND";
  status = 500;
  constructor() {
    super("INTERNAL_SERVER_ERROR");
  }
}

class M1 extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor() {
    super("NOT_FOUND");
  }
}
class B0 extends Error {
  $;
  J;
  Y;
  code = "VALIDATION";
  status = 400;
  constructor($, J, Y) {
    const X = a1 ? undefined : J.Errors(Y).First(), Z = X?.schema.error ? typeof X.schema.error === "function" ? X.schema.error($, J, Y) : X.schema.error : undefined, Q = a1 ? Z ?? `Invalid ${$ ?? X?.schema.error ?? X?.message}` : Z ?? `Invalid ${$}, '${X?.path?.slice(1) || "type"}': ${X?.message}` + "\n\nExpected: " + JSON.stringify(k4.Value.Create(J.schema), null, 2) + "\n\nFound: " + JSON.stringify(Y, null, 2);
    super(Q);
    this.type = $;
    this.validator = J;
    this.value = Y;
    Object.setPrototypeOf(this, B0.prototype);
  }
  get all() {
    return [...this.validator.Errors(this.value)];
  }
  get model() {
    return k4.Value.Create(this.validator.schema);
  }
  toResponse($) {
    return new Response(this.message, { status: 400, headers: $ });
  }
}
var Bz = new Headers;
var Az = new RegExp(" (\\w+) = context", "g");
var $$ = ($) => {
  const J = $.indexOf(")");
  if ($.charCodeAt(J + 2) === 61 && $.charCodeAt(J + 5) !== 123)
    return true;
  return $.includes("return");
};
var Nz = ($) => ({ composeValidation: (J, Y = `c.${J}`) => $ ? `throw new ValidationError(
'${J}',
${J},
${Y}
)` : `return new ValidationError(
	'${J}',
	${J},
	${Y}
).toResponse(c.set.headers)`, composeResponseValidation: (J = "r") => $ ? `throw new ValidationError(
'response',
response[c.set.status],
${J}
)` : `return new ValidationError(
'response',
response[c.set.status],
${J}
).toResponse(c.set.headers)` });
var e1 = ($, J) => {
  J = J.trimStart(), J = J.replaceAll(/^async /g, "");
  const Y = J.charCodeAt(0) === 40 || J.startsWith("function") ? J.slice(J.indexOf("(") + 1, J.indexOf(")")) : J.slice(0, J.indexOf("=") - 1);
  if (Y === "")
    return false;
  if (Y.charCodeAt(0) === 123) {
    if (Y.includes($))
      return true;
    return false;
  }
  if (J.match(new RegExp(`${Y}(.${$}|\\["${$}"\\])`)))
    return true;
  const X = [Y];
  for (let Q of J.matchAll(Az))
    X.push(Q[1]);
  const Z = new RegExp(`{.*?} = (${X.join("|")})`, "g");
  for (let [Q] of J.matchAll(Z))
    if (Q.includes(`{ ${$}`) || Q.includes(`, ${$}`))
      return true;
  return false;
};
var T1 = ($, J, Y = [], X = "") => {
  if (J.type === "object") {
    const Z = J.properties;
    for (let Q in Z) {
      const q = Z[Q], F = !X ? Q : X + "." + Q;
      if (q.type === "object") {
        T1($, q, Y, F);
        continue;
      } else if (q.anyOf) {
        for (let B of q.anyOf)
          T1($, B, Y, F);
        continue;
      }
      if (q.elysiaMeta === $)
        Y.push(F);
    }
    if (Y.length === 0)
      return null;
    return Y;
  } else if (J?.elysiaMeta === $) {
    if (X)
      Y.push(X);
    return "root";
  }
  return null;
};
var wz = ($) => {
  if (!$)
    return;
  const J = $?.schema;
  if (J && ("anyOf" in J)) {
    let Y = false;
    const X = J.anyOf[0].type;
    for (let Z of J.anyOf)
      if (Z.type !== X) {
        Y = true;
        break;
      }
    if (!Y)
      return X;
  }
};
var Dz = /(?:return|=>) \S*\(/g;
var W0 = ($) => {
  if ($.constructor.name === "AsyncFunction")
    return true;
  if ($.toString().match(Dz))
    return true;
  return false;
};
var f6 = ({ method: $, hooks: J, validator: Y, handler: X, handleError: Z, meta: Q, onRequest: q, config: F }) => {
  const B = F.forceErrorEncapsulation || J.error.length > 0 || typeof Bun === "undefined" || J.onResponse.length > 0, { composeValidation: w, composeResponseValidation: N } = Nz(B), P = J.onResponse.length ? `\n;(async () => {${J.onResponse.map((S, V) => `await res${V}(c)`).join(";")}})();\n` : "";
  let D = B ? "try {\n" : "";
  const A = Y || $ !== "GET" ? [X, ...J.transform, ...J.beforeHandle, ...J.afterHandle].map((S) => S.toString()) : [], L = $ !== "GET" && J.type !== "none" && (!!Y.body || !!J.type || A.some((S) => e1("body", S))), O = Y.headers || A.some((S) => e1("headers", S));
  if (O)
    D += Bz.toJSON ? "c.headers = c.request.headers.toJSON()\n" : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  if (Y.query || A.some((S) => e1("query", S)))
    D += `const url = c.request.url

		if(c.qi !== -1) {
			c.query ??= parseQuery(url.substring(c.qi + 1))
		} else {
			c.query ??= {}
		}
		`;
  const R = A.some((S) => e1("set", S)) || q.some((S) => e1("set", S.toString())), k = L || W0(X) || J.parse.length > 0 || J.afterHandle.some(W0) || J.beforeHandle.some(W0) || J.transform.some(W0);
  if (L) {
    const S = wz(Y?.body);
    if (J.type || S) {
      if (J.type)
        switch (J.type) {
          case "application/json":
            D += "c.body = await c.request.json();";
            break;
          case "text/plain":
            D += "c.body = await c.request.text();";
            break;
          case "application/x-www-form-urlencoded":
            D += "c.body = parseQuery(await c.request.text());";
            break;
          case "application/octet-stream":
            D += "c.body = await c.request.arrayBuffer();";
            break;
          case "multipart/form-data":
            D += `c.body = {}

					const form = await c.request.formData()
					for (const key of form.keys()) {
						if (c.body[key])
							continue

						const value = form.getAll(key)
						if (value.length === 1)
							c.body[key] = value[0]
						else c.body[key] = value
					}`;
            break;
        }
      else if (S) {
        const V = Y?.body?.schema;
        switch (S) {
          case "object":
            if (V.elysiaMeta === "URLEncoded")
              D += "c.body = parseQuery(await c.request.text())";
            else if (Y.body.Code().includes("custom('File"))
              D += `c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue
		
								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}`;
            else
              D += "c.body = JSON.parse(await c.request.text())";
            break;
          default:
            D += "c.body = await c.request.text()";
            break;
        }
      }
      if (J.parse.length)
        D += "}}";
    } else {
      if (D += "\n", D += O ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", D += `
            if (contentType) {
				const index = contentType.indexOf(';')
				if (index !== -1) contentType = contentType.substring(0, index)\n`, J.parse.length) {
        D += "let used = false\n";
        for (let V = 0;V < J.parse.length; V++) {
          const T = `bo${V}`;
          if (V !== 0)
            D += "if(!used) {\n";
          if (D += `let ${T} = parse[${V}](c, contentType);`, D += `if(${T} instanceof Promise) ${T} = await ${T};`, D += `
						if(${T} !== undefined) { c.body = ${T}; used = true }\n`, V !== 0)
            D += "}";
        }
        D += "if (!used)";
      }
      D += `switch (contentType) {
			case 'application/json':
				c.body = await c.request.json()
				break

			case 'text/plain':
				c.body = await c.request.text()
				break

			case 'application/x-www-form-urlencoded':
				c.body = parseQuery(await c.request.text())
				break

			case 'application/octet-stream':
				c.body = await c.request.arrayBuffer();
				break

			case 'multipart/form-data':
				c.body = {}

				const form = await c.request.formData()
				for (const key of form.keys()) {
					if (c.body[key])
						continue

					const value = form.getAll(key)
					if (value.length === 1)
						c.body[key] = value[0]
					else c.body[key] = value
				}

				break
			}
		}\n`;
    }
    D += "\n";
  }
  if (Y.params) {
    const S = T1("Numeric", Y.params.schema);
    if (S) {
      switch (typeof S) {
        case "object":
          for (let V of S)
            D += `if(c.params.${V}) c.params.${V} = +c.params.${V};`;
          break;
      }
      D += "\n";
    }
  }
  if (Y.query) {
    const S = T1("Numeric", Y.query.schema);
    if (S) {
      switch (typeof S) {
        case "object":
          for (let V of S)
            D += `if(c.query.${V}) c.query.${V} = +c.query.${V};`;
          break;
      }
      D += "\n";
    }
  }
  if (Y.headers) {
    const S = T1("Numeric", Y.headers.schema);
    if (S) {
      switch (typeof S) {
        case "object":
          for (let V of S)
            D += `c.headers.${V} = +c.headers.${V};`;
          break;
      }
      D += "\n";
    }
  }
  if (Y.body) {
    const S = T1("Numeric", Y.body.schema);
    if (S) {
      switch (typeof S) {
        case "string":
          D += "c.body = +c.body;";
          break;
        case "object":
          for (let V of S)
            D += `c.body.${V} = +c.body.${V};`;
          break;
      }
      D += "\n";
    }
  }
  if (J?.transform)
    for (let S = 0;S < J.transform.length; S++)
      if (J.transform[S].$elysia === "derive")
        D += W0(J.transform[S]) ? `Object.assign(c, await transform[${S}](c));` : `Object.assign(c, transform[${S}](c));`;
      else
        D += W0(J.transform[S]) ? `await transform[${S}](c);` : `transform[${S}](c);`;
  if (Y) {
    if (Y.headers)
      D += `
                if (headers.Check(c.headers) === false) {
                    ${w("headers")}
				}
        `;
    if (Y.params)
      D += `if(params.Check(c.params) === false) { ${w("params")} }`;
    if (Y.query)
      D += `if(query.Check(c.query) === false) { ${w("query")} }`;
    if (Y.body)
      D += `if(body.Check(c.body) === false) { ${w("body")} }`;
  }
  if (J?.beforeHandle)
    for (let S = 0;S < J.beforeHandle.length; S++) {
      const V = `be${S}`;
      if (!$$(J.beforeHandle[S].toString()))
        D += W0(J.beforeHandle[S]) ? `await beforeHandle[${S}](c);\n` : `beforeHandle[${S}](c);\n`;
      else {
        if (D += W0(J.beforeHandle[S]) ? `let ${V} = await beforeHandle[${S}](c);\n` : `let ${V} = beforeHandle[${S}](c);\n`, D += `if(${V} !== undefined) {\n`, J?.afterHandle) {
          const M0 = V;
          for (let J0 = 0;J0 < J.afterHandle.length; J0++)
            if (!$$(J.afterHandle[J0].toString()))
              D += W0(J.afterHandle[J0]) ? `await afterHandle[${J0}](c, ${M0});\n` : `afterHandle[${J0}](c, ${M0});\n`;
            else {
              const b0 = `af${J0}`;
              D += W0(J.afterHandle[J0]) ? `const ${b0} = await afterHandle[${J0}](c, ${M0});\n` : `const ${b0} = afterHandle[${J0}](c, ${M0});\n`, D += `if(${b0} !== undefined) { ${M0} = ${b0} }\n`;
            }
        }
        if (Y.response)
          D += `if(response[c.set.status]?.Check(${V}) === false) { 
						if(!(response instanceof Error))
							${N(V)}
					}\n`;
        D += `return mapEarlyResponse(${V}, c.set)}\n`;
      }
    }
  if (J?.afterHandle.length) {
    D += W0(X) ? "let r = await handler(c);\n" : "let r = handler(c);\n";
    for (let S = 0;S < J.afterHandle.length; S++) {
      const V = `af${S}`;
      if (!$$(J.afterHandle[S].toString()))
        D += W0(J.afterHandle[S]) ? `await afterHandle[${S}](c, r)\n` : `afterHandle[${S}](c, r)\n`;
      else if (D += W0(J.afterHandle[S]) ? `let ${V} = await afterHandle[${S}](c, r)\n` : `let ${V} = afterHandle[${S}](c, r)\n`, Y.response)
        D += `if(${V} !== undefined) {`, D += `if(response[c.set.status]?.Check(${V}) === false) { 
						if(!(response instanceof Error))
						${N(V)}
					}\n`, D += `${V} = mapEarlyResponse(${V}, c.set)\n`, D += `if(${V}) return ${V};\n}`;
      else
        D += `if(${V}) return ${V};\n`;
    }
    if (Y.response)
      D += `if(response[c.set.status]?.Check(r) === false) { 
				if(!(response instanceof Error))
					${N()}
			}\n`;
    if (R)
      D += "return mapResponse(r, c.set)\n";
    else
      D += "return mapCompactResponse(r)\n";
  } else if (Y.response)
    if (D += W0(X) ? "const r = await handler(c);\n" : "const r = handler(c);\n", D += `if(response[c.set.status]?.Check(r) === false) { 
				if(!(response instanceof Error))
					${N()}
			}\n`, R)
      D += "return mapResponse(r, c.set)\n";
    else
      D += "return mapCompactResponse(r)\n";
  else {
    const S = W0(X) ? "await handler(c) " : "handler(c)";
    if (R)
      D += `return mapResponse(${S}, c.set)\n`;
    else
      D += `return mapCompactResponse(${S})\n`;
  }
  if (B)
    D += `
} catch(error) {
	

	${k ? "" : "return (async () => {"}
		const set = c.set

		if (!set.status || set.status < 300) set.status = 500

		${J.error.length ? `for (let i = 0; i < handleErrors.length; i++) {
				let handled = handleErrors[i]({
					request: c.request,
					error: error,
					set,
					code: error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
				})
				if (handled instanceof Promise) handled = await handled

				const response = mapEarlyResponse(handled, set)
				if (response) return response
			}` : ""}

		return handleError(c.request, error, set)
	${k ? "" : "})()"}
} finally {
	${P}
}`;
  return D = `const { 
		handler,
		handleError,
		hooks: {
			transform,
			beforeHandle,
			afterHandle,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		meta,
		ERROR_CODE
	} = hooks

	${J.onResponse.length ? `const ${J.onResponse.map((S, V) => `res${V} = onResponse[${V}]`).join(",")}` : ""}

	return ${k ? "async" : ""} function(c) {
		${Q ? 'c["schema"] = meta["schema"]; c["defs"] = meta["defs"];' : ""}
		${D}
	}`, Function("hooks", D)({ handler: X, hooks: J, validator: Y, handleError: Z, utils: { mapResponse: h0, mapCompactResponse: I$, mapEarlyResponse: f0, parseQuery: g6.parse }, error: { NotFoundError: M1, ValidationError: B0, InternalServerError: b$ }, meta: Q, ERROR_CODE: $1 });
};
var g4 = ($) => {
  let J = "";
  for (let F of Object.keys($.decorators))
    J += `,${F}: app.decorators.${F}`;
  const { router: Y, staticRouter: X } = $, Z = `
	const route = find(request.method, path) ${Y.root.ALL ? '?? find("ALL", path)' : ""}
	if (route === null)
		return ${$.event.error.length ? `handleError(
			request,
			notFound,
			ctx.set
		)` : `new Response(error404, {
					status: 404
				})`}

	ctx.params = route.params

	return route.store(ctx)`;
  let Q = "";
  for (let [F, { code: B, all: w }] of Object.entries(X.map))
    Q += `case '${F}':\nswitch(request.method) {\n${B}\n${w ?? `default: ${Z}`}}\n\n`;
  let q = `const {
		app,
		app: { store, router, staticRouter },
		mapEarlyResponse,
		NotFoundError
	} = data

	const notFound = new NotFoundError()

	${$.event.request.length ? "const onRequest = app.event.request" : ""}

	${X.variables}

	const find = router.find.bind(router)
	const handleError = app.handleError.bind(this)

	${$.event.error.length ? "" : "const error404 = notFound.message.toString()"}

	return function(request) {
	`;
  if ($.event.request.length) {
    q += `
			const ctx = {
				request,
				store,
				set: {
					headers: {},
					status: 200
				}
				${J}
			}

			try {\n`;
    for (let F = 0;F < $.event.request.length; F++) {
      const B = $$($.event.request[F].toString());
      q += !B ? `mapEarlyResponse(onRequest[${F}](ctx), ctx.set);` : `const response = mapEarlyResponse(
					onRequest[${F}](ctx),
					ctx.set
				)
				if (response) return response\n`;
    }
    q += `} catch (error) {
			return handleError(request, error, ctx.set)
		}
		
		const url = request.url,
		s = url.indexOf('/', 11),
		i = ctx.qi = url.indexOf('?', s + 1),
		path = ctx.path = i === -1 ? url.substring(s) : url.substring(s, i);`;
  } else
    q += `
		const url = request.url,
			s = url.indexOf('/', 11),
			qi = url.indexOf('?', s + 1),
			path = qi === -1
				? url.substring(s)
				: url.substring(s, qi)

		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: {},
				status: 200
			}
			${J}
		}`;
  return q += `
		switch(path) {
			${Q}

			default:
				${Z}
		}
	}`, $.handleError = f4($), Function("data", q)({ app: $, mapEarlyResponse: f0, NotFoundError: M1 });
};
var f4 = ($) => {
  let J = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE
	} = inject

	return ${$.event.error.find(W0) ? "async" : ""} function(request, error, set) {`;
  for (let Y = 0;Y < $.event.error.length; Y++) {
    const X = $.event.error[Y], Z = `${W0(X) ? "await " : ""}onError[${Y}]({
			request,
			code: error.code ?? error[ERROR_CODE] ?? 'UNKNOWN',
			error,
			set
		})`;
    if ($$(X.toString()))
      J += `const r${Y} = ${Z}; if(r${Y} !== undefined) return mapResponse(r${Y}, set)\n`;
    else
      J += Z + "\n";
  }
  return J += `if(error.constructor.name === "ValidationError") {
		return new Response(
			error.message, 
			{ headers: set.headers, status: error.status ?? 400 }
		)
	} else {
		return new Response(error.message, { headers: set.headers, status: error.status ?? 500 })
	}
}`, Function("inject", J)({ app: $, mapResponse: h0, ERROR_CODE: $1 });
};
var _$ = ($) => {
  const J = $.indexOf("/", 10), Y = $.indexOf("?", J);
  if (Y === -1)
    return $.slice(J);
  return $.slice(J, Y);
};

class J$ {
  raw;
  data;
  isSubscribed;
  constructor($) {
    this.raw = $, this.data = $.data, this.isSubscribed = $.isSubscribed;
  }
  publish($, J = undefined, Y) {
    if (typeof J === "object")
      J = JSON.stringify(J);
    return this.raw.publish($, J, Y), this;
  }
  publishToSelf($, J = undefined, Y) {
    if (typeof J === "object")
      J = JSON.stringify(J);
    return this.raw.publish($, J, Y), this;
  }
  send($) {
    if (typeof $ === "object")
      $ = JSON.stringify($);
    return this.raw.send($), this;
  }
  subscribe($) {
    return this.raw.subscribe($), this;
  }
  unsubscribe($) {
    return this.raw.unsubscribe($), this;
  }
  cork($) {
    return this.raw.cork($), this;
  }
  close() {
    return this.raw.close(), this;
  }
}
var R$ = ($) => (J) => {
  if (!J.wsRouter)
    J.wsRouter = new s0;
  const Y = J.wsRouter;
  if (!J.config.serve)
    J.config.serve = { websocket: { ...$, open(X) {
      if (!X.data)
        return;
      const Z = _$(X?.data.request.url);
      if (!Z)
        return;
      const Q = Y.find("subscribe", Z)?.store;
      if (Q && Q.open)
        Q.open(new J$(X));
    }, message(X, Z) {
      if (!X.data)
        return;
      const Q = _$(X?.data.request.url);
      if (!Q)
        return;
      const q = Y.find("subscribe", Q)?.store;
      if (!q?.message)
        return;
      Z = Z.toString();
      const F = Z.charCodeAt(0);
      if (F === 47 || F === 123)
        try {
          Z = JSON.parse(Z);
        } catch (B) {
        }
      else if (!Number.isNaN(+Z))
        Z = +Z;
      for (let B = 0;B < X.data.transformMessage.length; B++) {
        const w = X.data.transformMessage[B](Z);
        if (w !== undefined)
          Z = w;
      }
      if (X.data.message?.Check(Z) === false)
        return void X.send(new B0("message", X.data.message, Z).cause);
      q.message(new J$(X), Z);
    }, close(X, Z, Q) {
      if (!X.data)
        return;
      const q = _$(X?.data.request.url);
      if (!q)
        return;
      const F = Y.find("subscribe", q)?.store;
      if (F && F.close)
        F.close(new J$(X), Z, Q);
    }, drain(X) {
      if (!X.data)
        return;
      const Z = _$(X?.data.request.url);
      if (!Z)
        return;
      const Q = Y.find("subscribe", Z)?.store;
      if (Q && Q.drain)
        Q.drain(new J$(X));
    } } };
  return J.decorate("publish", J.server?.publish).onStart((X) => {
    X.decorators.publish = X.server?.publish;
  });
};
var G$ = t0(V4(), 1);
var T4 = ($) => async (J) => {
  const Y = { status: 200, headers: {} };
  let X;
  if ($.decorators)
    X = $.decorators, X.request = J, X.set = Y, X.store = $.store;
  else
    X = { set: Y, store: $.store, request: J };
  const Z = J.url, Q = Z.indexOf("/", 12), q = Z.indexOf("?", Q + 1), F = q === -1 ? Z.substring(Q) : Z.substring(Q, q);
  try {
    for (let O = 0;O < $.event.request.length; O++) {
      const G = $.event.request[O];
      let R = G(X);
      if (R instanceof Promise)
        R = await R;
      if (R = f0(R, Y), R)
        return R;
    }
    const B = $.dynamicRouter.find(J.method, F) ?? $.dynamicRouter.find("ALL", F);
    if (!B)
      throw new M1;
    const { handle: w, hooks: N, validator: P, content: D } = B.store;
    let A;
    if (J.method !== "GET")
      if (D)
        switch (D) {
          case "application/json":
            A = await J.json();
            break;
          case "text/plain":
            A = await J.text();
            break;
          case "application/x-www-form-urlencoded":
            A = G$.parse(await J.text());
            break;
          case "application/octet-stream":
            A = await J.arrayBuffer();
            break;
          case "multipart/form-data":
            A = {};
            const O = await J.formData();
            for (let G of O.keys()) {
              if (A[G])
                continue;
              const R = O.getAll(G);
              if (R.length === 1)
                A[G] = R[0];
              else
                A[G] = R;
            }
            break;
        }
      else {
        let O = J.headers.get("content-type");
        if (O) {
          const G = O.indexOf(";");
          if (G !== -1)
            O = O.slice(0, G);
          for (let R = 0;R < $.event.parse.length; R++) {
            let k = $.event.parse[R](X, O);
            if (k instanceof Promise)
              k = await k;
            if (k) {
              A = k;
              break;
            }
          }
          if (A === undefined)
            switch (O) {
              case "application/json":
                A = await J.json();
                break;
              case "text/plain":
                A = await J.text();
                break;
              case "application/x-www-form-urlencoded":
                A = G$.parse(await J.text());
                break;
              case "application/octet-stream":
                A = await J.arrayBuffer();
                break;
              case "multipart/form-data":
                A = {};
                const R = await J.formData();
                for (let k of R.keys()) {
                  if (A[k])
                    continue;
                  const y = R.getAll(k);
                  if (y.length === 1)
                    A[k] = y[0];
                  else
                    A[k] = y;
                }
                break;
            }
        }
      }
    X.body = A, X.params = B?.params || {}, X.query = G$.parse(Z.substring(q + 1));
    for (let O = 0;O < N.transform.length; O++) {
      const G = N.transform[O](X);
      if (G instanceof Promise)
        await G;
    }
    if (P) {
      if (P.headers) {
        const O = {};
        for (let G in J.headers)
          O[G] = J.headers.get(G);
        if (P.headers.Check(O) === false)
          throw new B0("header", P.headers, O);
      }
      if (P.params?.Check(X.params) === false)
        throw new B0("params", P.params, X.params);
      if (P.query?.Check(X.query) === false)
        throw new B0("query", P.query, X.query);
      if (P.body?.Check(A) === false)
        throw new B0("body", P.body, A);
    }
    for (let O = 0;O < N.beforeHandle.length; O++) {
      let G = N.beforeHandle[O](X);
      if (G instanceof Promise)
        G = await G;
      if (G !== undefined) {
        for (let k = 0;k < N.afterHandle.length; k++) {
          let y = N.afterHandle[k](X, G);
          if (y instanceof Promise)
            y = await y;
          if (y)
            G = y;
        }
        const R = f0(G, X.set);
        if (R)
          return R;
      }
    }
    let L = w(X);
    if (L instanceof Promise)
      L = await L;
    if (!N.afterHandle.length) {
      const O = P?.response?.[L.status];
      if (O?.Check(L) === false)
        throw new B0("response", O, L);
    } else
      for (let O = 0;O < N.afterHandle.length; O++) {
        let G = N.afterHandle[O](X, L);
        if (G instanceof Promise)
          G = await G;
        const R = f0(G, X.set);
        if (R !== undefined) {
          const k = P?.response?.[L.status];
          if (k?.Check(R) === false)
            throw new B0("response", k, R);
          return R;
        }
      }
    return h0(L, X.set);
  } catch (B) {
    return $.handleError(J, B, Y);
  } finally {
    for (let B of $.event.onResponse)
      await B(X);
  }
};
var T6 = ($) => async (J, Y, X = { headers: {} }) => {
  for (let Z = 0;Z < $.event.error.length; Z++) {
    let Q = $.event.error[Z]({ request: J, code: Y.code ?? Y[$1] ?? "UNKNOWN", error: Y, set: X });
    if (Q instanceof Promise)
      Q = await Q;
    if (Q !== undefined && Q !== null)
      return h0(Q, X);
  }
  return new Response(typeof Y.cause === "string" ? Y.cause : Y.message, { headers: X.headers, status: Y.status ?? 500 });
};
var Y1 = t0(G0(), 1);
var J1 = t0(i1(), 1);
try {
  J1.TypeSystem.Format("email", ($) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test($)), J1.TypeSystem.Format("uuid", ($) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test($)), J1.TypeSystem.Format("date", ($) => !Number.isNaN(new Date($).getTime())), J1.TypeSystem.Format("date-time", ($) => !Number.isNaN(new Date($).getTime()));
} catch ($) {
}
var d6 = ($) => {
  if (typeof $ === "string")
    switch ($.slice(-1)) {
      case "k":
        return +$.slice(0, $.length - 1) * 1024;
      case "m":
        return +$.slice(0, $.length - 1) * 1048576;
      default:
        return +$;
    }
  return $;
};
var y6 = ($, J) => {
  if (!(J instanceof Blob))
    return false;
  if ($.minSize && J.size < d6($.minSize))
    return false;
  if ($.maxSize && J.size > d6($.maxSize))
    return false;
  if ($.extension)
    if (typeof $.extension === "string") {
      if (!J.type.startsWith($.extension))
        return false;
    } else {
      for (let Y = 0;Y < $.extension.length; Y++)
        if (J.type.startsWith($.extension[Y]))
          return true;
      return false;
    }
  return true;
};
var v6 = { Numeric: J1.TypeSystem.Type("Numeric", {}), File: J1.TypeSystem.Type("File", y6), Files: J1.TypeSystem.Type("Files", ($, J) => {
  if (!Array.isArray(J))
    return false;
  if ($.minItems && J.length < $.minItems)
    return false;
  if ($.maxItems && J.length > $.maxItems)
    return false;
  for (let Y = 0;Y < J.length; Y++)
    if (!y6($, J[Y]))
      return false;
  return true;
}) };
Y1.Type.Numeric = ($) => {
  return Y1.Type.Number({ ...$, elysiaMeta: "Numeric" });
};
Y1.Type.URLEncoded = ($, J) => {
  return Y1.Type.Object($, { ...J, elysiaMeta: "URLEncoded" });
};
Y1.Type.File = ($) => v6.File({ elysiaMeta: "File", default: "File", ...$, extension: $?.type, type: "string", format: "binary" });
Y1.Type.Files = ($) => v6.Files({ ...$, elysiaMeta: "Files", default: "Files", extension: $?.type, type: "array", items: { ...$, default: "Files", type: "string", format: "binary" } });

class E$ {
  config;
  dependencies = {};
  store = {};
  meta = { schema: Object.create(null), defs: Object.create(null), exposed: Object.create(null) };
  decorators = {};
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], onResponse: [], error: [], stop: [] };
  server = null;
  $schema = null;
  error = {};
  router = new s0;
  routes = [];
  staticRouter = { handlers: [], variables: "", map: {}, all: "" };
  wsRouter;
  dynamicRouter = new s0;
  lazyLoadModules = [];
  path = "";
  constructor($) {
    this.config = { forceErrorEncapsulation: false, prefix: "", aot: typeof CF === "undefined", strictPath: false, ...$, seed: $?.name && $.seed === undefined ? "" : $?.seed };
  }
  add($, J, Y, X, { allowMeta: Z = false } = { allowMeta: false }) {
    if (J = J === "" ? J : J.charCodeAt(0) === 47 ? J : `/${J}`, this.config.prefix)
      J = this.config.prefix + J;
    const Q = this.meta.defs;
    if (X?.type)
      switch (X.type) {
        case "text":
          X.type = "text/plain";
          break;
        case "json":
          X.type = "application/json";
          break;
        case "formdata":
          X.type = "multipart/form-data";
          break;
        case "urlencoded":
          X.type = "application/x-www-form-urlencoded";
          break;
        case "arrayBuffer":
          X.type = "application/octet-stream";
          break;
        default:
          break;
      }
    const q = { body: I0(X?.body ?? this.$schema?.body, { dynamic: !this.config.aot, models: Q }), headers: I0(X?.headers ?? this.$schema?.headers, { dynamic: !this.config.aot, models: Q, additionalProperties: true }), params: I0(X?.params ?? this.$schema?.params, { dynamic: !this.config.aot, models: Q }), query: I0(X?.query ?? this.$schema?.query, { dynamic: !this.config.aot, models: Q }), response: R4(X?.response ?? this.$schema?.response, { dynamic: !this.config.aot, models: Q }) }, F = e0(this.event, X), B = J.endsWith("/") ? J.slice(0, J.length - 1) : J + "/";
    if (this.config.aot === false) {
      if (this.dynamicRouter.add($, J, { validator: q, hooks: F, content: X?.type, handle: Y }), this.config.strictPath === false)
        this.dynamicRouter.add($, B, { validator: q, hooks: F, content: X?.type, handle: Y });
      return;
    }
    const w = f6({ path: J, method: $, hooks: F, validator: q, handler: Y, handleError: this.handleError, meta: Z ? this.meta : undefined, onRequest: this.event.request, config: this.config });
    if (this.routes.push({ method: $, path: J, composed: w, handler: Y, hooks: F }), J.indexOf(":") === -1 && J.indexOf("*") === -1) {
      const N = this.staticRouter.handlers.length;
      if (this.staticRouter.handlers.push(w), this.staticRouter.variables += `const st${N} = staticRouter.handlers[${N}]\n`, !this.staticRouter.map[J])
        this.staticRouter.map[J] = { code: "" };
      if ($ === "ALL")
        this.staticRouter.map[J].all = `default: return st${N}(ctx)\n`;
      else
        this.staticRouter.map[J].code += `case '${$}': return st${N}(ctx)\n`;
      if (!this.config.strictPath) {
        if (!this.staticRouter.map[B])
          this.staticRouter.map[B] = { code: "" };
        if ($ === "ALL")
          this.staticRouter.map[B].all = `default: return st${N}(ctx)\n`;
        else
          this.staticRouter.map[B].code += `case '${$}': return st${N}(ctx)\n`;
      }
    } else if (this.router.add($, J, w), !this.config.strictPath)
      this.router.add($, J.endsWith("/") ? J.slice(0, J.length - 1) : J + "/", w);
  }
  onStart($) {
    return this.event.start.push($), this;
  }
  onRequest($) {
    return this.event.request.push($), this;
  }
  onParse($) {
    return this.event.parse.splice(this.event.parse.length - 1, 0, $), this;
  }
  onTransform($) {
    return this.event.transform.push($), this;
  }
  onBeforeHandle($) {
    return this.event.beforeHandle.push($), this;
  }
  onAfterHandle($) {
    return this.event.afterHandle.push($), this;
  }
  onResponse($) {
    return this.event.onResponse.push($), this;
  }
  addError($, J) {
    if (typeof $ === "string" && J)
      return J.prototype[$1] = $, this;
    for (let [Y, X] of Object.entries($))
      X.prototype[$1] = Y;
    return this;
  }
  onError($) {
    if ($)
      this.event.error.push($);
    return this;
  }
  onStop($) {
    return this.event.stop.push($), this;
  }
  on($, J) {
    switch ($) {
      case "start":
        this.event.start.push(J);
        break;
      case "request":
        this.event.request.push(J);
        break;
      case "response":
        this.event.onResponse.push(J);
        break;
      case "parse":
        this.event.parse.push(J);
        break;
      case "transform":
        this.event.transform.push(J);
        break;
      case "beforeHandle":
        this.event.beforeHandle.push(J);
        break;
      case "afterHandle":
        this.event.afterHandle.push(J);
        break;
      case "error":
        this.event.error.push(J);
        break;
      case "stop":
        this.event.stop.push(J);
        break;
    }
    return this;
  }
  group($, J, Y) {
    const X = new E$({ ...this.config, prefix: this.config.prefix + $ });
    if (X.store = this.store, this.wsRouter)
      X.use(R$());
    const Z = typeof J === "object", Q = (Z ? Y : J)(X);
    if (this.decorators = k0(this.decorators, X.decorators), Q.event.request.length)
      this.event.request = [...this.event.request, ...Q.event.request];
    if (Q.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...Q.event.onResponse];
    if (this.model(Q.meta.defs), Object.values(X.routes).forEach(({ method: q, path: F, handler: B, hooks: w }) => {
      if (Z) {
        const N = J, P = w;
        if (X.wsRouter?.find("subscribe", F)) {
          const A = X.wsRouter.history.find(([L, O]) => F === O);
          if (!A)
            return;
          return this.ws(F, A[2]);
        }
        this.add(q, F, B, e0(N, { ...P, error: !P.error ? Q.event.error : Array.isArray(P.error) ? [...P.error, ...Q.event.error] : [P.error, ...Q.event.error] }));
      } else {
        if (X.wsRouter?.find("subscribe", F)) {
          const P = X.wsRouter.history.find(([D, A]) => F === A);
          if (!P)
            return;
          return this.ws(F, P[2]);
        }
        this.add(q, F, B, e0(w, { error: Q.event.error }));
      }
    }), X.wsRouter && this.wsRouter)
      X.wsRouter.history.forEach(([q, F, B]) => {
        if (F === "/")
          this.wsRouter?.add(q, $, B);
        else
          this.wsRouter?.add(q, `${$}${F}`, B);
      });
    return this;
  }
  guard($, J) {
    if (!J)
      return this.event = f1(this.event, $), this.$schema = { body: $.body, headers: $.headers, params: $.params, query: $.query, response: $.response }, this;
    const Y = new E$;
    if (Y.store = this.store, this.wsRouter)
      Y.use(R$());
    const X = J(Y);
    if (this.decorators = k0(this.decorators, Y.decorators), X.event.request.length)
      this.event.request = [...this.event.request, ...X.event.request];
    if (X.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...X.event.onResponse];
    if (this.model(X.meta.defs), Object.values(Y.routes).forEach(({ method: Z, path: Q, handler: q, hooks: F }) => {
      if (Y.wsRouter?.find("subscribe", Q)) {
        const w = Y.wsRouter.history.find(([N, P]) => Q === P);
        if (!w)
          return;
        return this.ws(Q, w[2]);
      }
      this.add(Z, Q, q, S0(e0($, { ...F, error: !F.error ? X.event.error : Array.isArray(F.error) ? [...F.error, ...X.event.error] : [F.error, ...X.event.error] })));
    }), Y.wsRouter && this.wsRouter)
      Y.wsRouter.history.forEach(([Z, Q, q]) => {
        this.wsRouter?.add(Z, Q, q);
      });
    return this;
  }
  use($) {
    if ($ instanceof Promise)
      return this.lazyLoadModules.push($.then((X) => {
        if (typeof X === "function")
          return X(this);
        if (typeof X.default === "function")
          return X.default(this);
        const Z = X.default, { config: { name: Q, seed: q } } = Z;
        if (Q) {
          if (!this.dependencies[Q])
            this.dependencies[Q] = [];
          const F = q !== undefined ? G4(Q + JSON.stringify(q)) : 0;
          if (this.dependencies[Q].some((B) => F === B))
            return this;
          this.dependencies[Q].push(F), this.event = f1(this.event, Z.event, F);
        } else
          this.event = f1(this.event, Z.event);
        return this.decorators = k0(this.decorators, Z.decorators), this.model(Z.meta.defs), Object.values(Z.routes).forEach(({ method: F, path: B, handler: w, hooks: N }) => {
          if (Z.wsRouter?.find("subscribe", B)) {
            const D = Z.wsRouter.history.find(([A, L]) => B === L);
            if (!D)
              return;
            return this.ws(B, D[2]);
          }
          this.add(F, B, w, e0(N, { error: Z.event.error }));
        }), this;
      }).then((X) => X.compile())), this;
    if (typeof $ === "function") {
      const X = $(this);
      if (X instanceof Promise)
        return this.lazyLoadModules.push(X.then((Z) => Z.compile())), this;
      return X;
    }
    const { config: { name: J, seed: Y } } = $;
    if (J) {
      if (!(J in this.dependencies))
        this.dependencies[J] = [];
      const X = Y !== undefined ? G4(J + JSON.stringify(Y)) : 0;
      if (this.dependencies[J].some((Z) => X === Z))
        return this;
      this.dependencies[J].push(X), this.event = f1(this.event, $.event, X);
    } else
      this.event = f1(this.event, $.event);
    return this.decorators = k0(this.decorators, $.decorators), this.model($.meta.defs), Object.values($.routes).forEach(({ method: X, path: Z, handler: Q, hooks: q }) => {
      if ($.wsRouter?.find("subscribe", Z)) {
        const B = $.wsRouter.history.find(([w, N]) => Z === N);
        if (!B)
          return;
        return this.ws(Z, B[2]);
      }
      this.add(X, Z, Q, e0(U6(q), { error: $.event.error }));
    }), this;
  }
  mount($, J) {
    if (typeof $ === "function" || $.length === 0 || $ === "/") {
      const Z = typeof $ === "function" ? $ : J, Q = async ({ request: q, path: F }) => Z(new Request("http://a.cc" + F || "/", q));
      return this.all("/", Q, { type: "none" }), this.all("/*", Q, { type: "none" }), this;
    }
    const Y = $.length, X = async ({ request: Z, path: Q }) => J(new Request("http://a.cc" + Q.slice(Y) || "/", Z));
    return this.all($, X, { type: "none" }), this.all($ + ($.endsWith("/") ? "*" : "/*"), X, { type: "none" }), this;
  }
  get($, J, Y) {
    return this.add("GET", $, J, S0(Y)), this;
  }
  post($, J, Y) {
    return this.add("POST", $, J, S0(Y)), this;
  }
  put($, J, Y) {
    return this.add("PUT", $, J, S0(Y)), this;
  }
  patch($, J, Y) {
    return this.add("PATCH", $, J, S0(Y)), this;
  }
  delete($, J, Y) {
    return this.add("DELETE", $, J, S0(Y)), this;
  }
  options($, J, Y) {
    return this.add("OPTIONS", $, J, S0(Y)), this;
  }
  all($, J, Y) {
    return this.add("ALL", $, J, S0(Y)), this;
  }
  head($, J, Y) {
    return this.add("HEAD", $, J, S0(Y)), this;
  }
  trace($, J, Y) {
    return this.add("TRACE", $, J, S0(Y)), this;
  }
  connect($, J, Y) {
    return this.add("CONNECT", $, J, S0(Y)), this;
  }
  ws($, J) {
    if (!this.wsRouter)
      throw new Error("Can't find WebSocket. Please register WebSocket plugin first by importing 'elysia/ws'");
    return this.wsRouter.add("subscribe", $, J), this.get($, (Y) => {
      if (this.server?.upgrade(Y.request, { headers: typeof J.upgrade === "function" ? J.upgrade(Y) : J.upgrade, data: { ...Y, id: Date.now(), headers: Y.request.headers.toJSON(), message: I0(J?.body, { models: this.meta.defs }), transformMessage: !J.transform ? [] : Array.isArray(J.transformMessage) ? J.transformMessage : [J.transformMessage] } }))
        return;
      return Y.set.status = 400, "Expected a websocket connection";
    }, { beforeHandle: J.beforeHandle, transform: J.transform, headers: J?.headers, params: J?.params, query: J?.query }), this;
  }
  route($, J, Y, { config: X, ...Z } = { config: { allowMeta: false } }) {
    return this.add($, J, Y, S0(Z), X), this;
  }
  state($, J) {
    if (typeof $ === "object")
      return this.store = k0(this.store, $), this;
    if (!($ in this.store))
      this.store[$] = J;
    return this;
  }
  decorate($, J) {
    if (typeof $ === "object")
      return this.decorators = k0(this.decorators, $), this;
    if (!($ in this.decorators))
      this.decorators[$] = J;
    return this;
  }
  derive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  schema($) {
    const J = this.meta.defs;
    return this.$schema = { body: I0($.body, { models: J }), headers: I0($?.headers, { models: J, additionalProperties: true }), params: I0($?.params, { models: J }), query: I0($?.query, { models: J }), response: I0($?.response, { models: J }) }, this;
  }
  compile() {
    if (this.fetch = this.config.aot ? g4(this) : T4(this), this.server)
      this.server.reload({ ...this.server, fetch: this.fetch });
    return this;
  }
  handle = async ($) => this.fetch($);
  fetch = ($) => (this.fetch = this.config.aot ? g4(this) : T4(this))($);
  handleError = async ($, J, Y) => (this.handleError = this.config.aot ? f4(this) : T6(this))($, J, Y);
  outerErrorHandler = ($) => new Response($.message, { status: $?.status ?? 500 });
  listen = ($, J) => {
    if (!Bun)
      throw new Error("Bun to run");
    if (this.compile(), typeof $ === "string") {
      if ($ = +$.trim(), Number.isNaN($))
        throw new Error("Port must be a numeric value");
    }
    const Y = this.fetch, X = typeof $ === "object" ? { development: !a1, ...this.config.serve, ...$, fetch: Y, error: this.outerErrorHandler } : { development: !a1, ...this.config.serve, port: $, fetch: Y, error: this.outerErrorHandler };
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    this.server = Bun?.serve(X);
    for (let Z = 0;Z < this.event.start.length; Z++)
      this.event.start[Z](this);
    if (J)
      J(this.server);
    return Promise.all(this.lazyLoadModules).then(() => {
      Bun?.gc(true);
    }), this;
  };
  stop = async () => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    this.server.stop();
    for (let $ = 0;$ < this.event.stop.length; $++)
      await this.event.stop[$](this);
  };
  get modules() {
    return Promise.all(this.lazyLoadModules);
  }
  model($, J) {
    if (typeof $ === "object")
      Object.entries($).forEach(([Y, X]) => {
        if (!(Y in this.meta.defs))
          this.meta.defs[Y] = X;
      });
    else
      this.meta.defs[$] = J;
    return this;
  }
}
var export_t = Y1.Type;

// node_modules/@elysiajs/html/dist/index.js
var import_sanitize_html = __toESM(require_sanitize_html(), 1);
var html = () => new E$({
  name: "@elysiajs/html"
}).derive((context) => ({
  sanitize: import_sanitize_html.default,
  html(value) {
    return new Response(value, {
      headers: {
        ...context.set.headers,
        "content-type": "text/html"
      }
    });
  }
})).onAfterHandle((context, response) => {
  if (typeof response === "string" && response.trimStart().slice(0, 9).toLowerCase().startsWith("<!doctype"))
    return context.html(response);
});

// src/app.tsx
var elements6 = __toESM(require_elements(), 1);

// src/templates/pages/index.tsx
var elements4 = __toESM(require_elements(), 1);

// src/templates/components/comment-list.tsx
var elements2 = __toESM(require_elements(), 1);

// src/templates/components/comment-item.tsx
var elements = __toESM(require_elements(), 1);
var CommentItem = (props) => {
  const { comment } = props;
  return elements.createElement("div", {
    class: "card mb-3",
    "hx-target": "this",
    "hx-swap": "outerHTML"
  }, elements.createElement("div", {
    class: "card-body"
  }, elements.createElement("p", {
    class: "card-text"
  }, comment.id, ".", comment.body), elements.createElement("h6", {
    class: "card-subtitle mb-2 text-body-secondary"
  }, comment.email), elements.createElement("small", {
    class: "text-muted"
  }, comment.timestamp), elements.createElement("button", {
    class: "btn btn-primary btn-small",
    "hx-get": `/h/comments/${comment.id}`
  }, "Edit")));
};
var comment_item_default = CommentItem;

// src/templates/components/comment-list.tsx
var CommentList = (props) => {
  return elements2.createElement("div", {
    "hx-target": "this"
  }, elements2.createElement("button", {
    "hx-get": "/h/comments",
    "hx-trigger": "new-comment-added from:body",
    class: "btn btn-primary"
  }, "Reload comments"), props.comments.map((comment) => elements2.createElement(comment_item_default, {
    comment
  })));
};
var comment_list_default = CommentList;

// src/templates/components/comment-form.tsx
var elements3 = __toESM(require_elements(), 1);
var CommentForm = (props) => {
  return elements3.createElement("form", {
    "hx-post": "/",
    "hx-swap": "outerHTML",
    class: "fade-me-in"
  }, elements3.createElement("div", {
    class: "mb-3"
  }, elements3.createElement("label", {
    for: "exampleFormControlInput1",
    class: "form-label"
  }, "Email address"), elements3.createElement("input", {
    type: "email",
    class: "form-control",
    id: "exampleFormControlInput1",
    placeholder: "name@example.com",
    name: "email"
  })), elements3.createElement("div", {
    class: "mb-3"
  }, elements3.createElement("label", {
    for: "exampleFormControlTextarea1",
    class: "form-label"
  }, "Your comment"), elements3.createElement("textarea", {
    class: "form-control",
    id: "exampleFormControlTextarea1",
    rows: "3",
    name: "body"
  })), " ", props.isError ? elements3.createElement("div", {
    class: "alert alert-warning",
    role: "alert"
  }, "You missed some input, please check again!") : null, elements3.createElement("div", {
    class: "mb-3"
  }, elements3.createElement("button", {
    class: "btn btn-primary"
  }, " Submit ")));
};
var comment_form_default = CommentForm;

// src/templates/pages/index.tsx
function Index(props) {
  return "<!DOCTYPE html>" + elements4.createElement("html", null, elements4.createElement("head", null, elements4.createElement("meta", {
    name: "viewport",
    content: "width=device-width, initial-scale=1"
  }), elements4.createElement("link", {
    href: "https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css",
    rel: "stylesheet",
    integrity: "sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9",
    crossorigin: "anonymous"
  }), elements4.createElement("title", null, "Blog bun htmx"), elements4.createElement("style", null, `
      .fade-me-in.htmx-added {
        border: 3px solid red;
      }
      .fade-me-in {
        border: 0px solid red;
        transition: border-width 1s ease-out;
      }
          `)), elements4.createElement("body", null, elements4.createElement("section", {
    class: "container-fluid"
  }, elements4.createElement("div", {
    class: "row py-5"
  }, elements4.createElement("div", {
    class: "col-lg-8 mx-auto"
  }, elements4.createElement("h1", {
    class: "fw-light"
  }, "Blog example"), elements4.createElement("p", {
    class: "lead text-muted"
  }, "Something short and leading about the collection below\u2014its contents, the creator, etc. Make it short and sweet, but not too short so folks don't simply skip over it entirely."), elements4.createElement(comment_form_default, {
    isError: false
  }), elements4.createElement(comment_list_default, {
    comments: props.comments
  })))), elements4.createElement("script", {
    src: "https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js",
    integrity: "sha384-HwwvtgBNo3bZJJLYd8oVXjrBZt8cqVSpeBNS5n7C8IVInixGAoxmnlMuBnhbgrkm",
    crossorigin: "anonymous"
  }), elements4.createElement("script", {
    src: "https://unpkg.com/htmx.org@1.9.4",
    integrity: "sha384-zUfuhFKKZCbHTY6aRR46gxiqszMk5tcHjsVFxnUo8VMus4kHGVdIYVbOYYNlKmHV",
    crossorigin: "anonymous"
  })));
}

// node_modules/zod/lib/index.mjs
var setErrorMap = function(map) {
  overrideErrorMap = map;
};
var getErrorMap = function() {
  return overrideErrorMap;
};
var addIssueToContext = function(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
};
var processCreateParams = function(params) {
  if (!params)
    return {};
  const { errorMap, invalid_type_error, required_error, description } = params;
  if (errorMap && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap)
    return { errorMap, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== undefined ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== undefined ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
};
var isValidIP = function(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
};
var floatSafeRemainder = function(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
};
var deepPartialify = function(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
};
var mergeValues = function(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
};
var createZodEnum = function(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
};
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (typeof value.value !== "undefined" || pair.alwaysSet) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};

class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === undefined ? undefined : params.async) !== null && _a !== undefined ? _a : false,
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
        async: true
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
var emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z\$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z\$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z\$`);
    }
  }
};

class ZodString extends ZodType {
  constructor() {
    super(...arguments);
    this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
    this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
    this.trim = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
    this.toLowerCase = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
    this.toUpperCase = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      offset: (_a = options === null || options === undefined ? undefined : options.offset) !== null && _a !== undefined ? _a : false,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === undefined ? undefined : options.position,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === undefined ? undefined : _b.call(_a, issue, ctx).message) !== null && _c !== undefined ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== undefined ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements6) {
      const parsedSet = new Set;
      for (const element of elements6) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements5 = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements5).then((elements6) => finalizeSet(elements6));
    } else {
      return finalizeSet(elements5);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      return OK(async (...args) => {
        const error = new ZodError([]);
        const parsedArgs = await this._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await fn(...parsedArgs);
        const parsedReturns = await this._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      return OK((...args) => {
        const parsedArgs = this._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = fn(...parsedArgs.data);
        const parsedReturns = this._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};

class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return ZodEnum.create(values);
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data);
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};

class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== undefined ? _a : fatal) !== null && _b !== undefined ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// src/templates/components/comment-item-form.tsx
var elements5 = __toESM(require_elements(), 1);
var CommentItemForm = (props) => {
  return elements5.createElement("div", {
    class: "card mb-3",
    "hx-target": "this",
    "hx-swap": "outerHTML"
  }, elements5.createElement("div", {
    class: "card-body"
  }, elements5.createElement("div", {
    class: "row g-3 align-items-center"
  }, elements5.createElement("div", {
    class: "col-auto"
  }, elements5.createElement("form", null, elements5.createElement("input", {
    type: "hidden",
    class: "form-control",
    name: "id",
    value: String(props.comment.id)
  }), elements5.createElement("input", {
    type: "text",
    class: "form-control",
    name: "body",
    value: props.comment.body
  }), elements5.createElement("button", {
    class: "btn btn-primary btn-small",
    "hx-put": `/h/comments/${props.comment.id}`
  }, "Submit"), elements5.createElement("button", {
    class: "btn btn-warning btn-small",
    "hx-get": `/h/comments/${props.comment.id}/item`
  }, "Cancel"), elements5.createElement("button", {
    class: "btn btn-danger btn-small",
    "hx-delete": `/h/comments/${props.comment.id}`
  }, "Delete"))))));
};
var comment_item_form_default = CommentItemForm;

// src/app.tsx
var xss = require_lib8();
var commentSchema = z.object({
  email: z.string().email(),
  body: z.string().min(2)
});
var commentBodySchema = z.object({
  body: z.string().min(2)
});
var commentEditParamsSchema = z.object({
  id: z.string()
});
var comments = [
  {
    id: 1,
    email: "test@example.com",
    body: "Hello Malaysia!",
    timestamp: "2023-08-18T12:27:56.173Z"
  }
];
var addComment = (email, body) => {
  const newId = comments.length + 1;
  const timestamp = new Date().toISOString();
  comments.push({ id: newId, email, body, timestamp });
  console.log(comments);
};
var editComment = (id, body) => {
  comments[id - 1].body = body;
  return comments[id - 1];
};
var deleteComment = (id) => {
  comments.splice(id - 1, 1);
};
var sanitizeHtml = (html3) => {
  return xss(html3);
};
var app = new E$().use(html()).get("/", ({ html: html3 }) => html3(elements6.createElement(Index, {
  comments
}))).get("/h/comments", () => elements6.createElement(comment_list_default, {
  comments
})).get("/h/comments/:id", ({ params }) => {
  const prm = commentEditParamsSchema.parse(params);
  const comment = comments.find((c) => c.id === parseInt(prm.id));
  if (!comment) {
    return elements6.createElement("div", null, "Comment not found!");
  }
  return elements6.createElement(comment_item_form_default, {
    comment
  });
}).put("/h/comments/:id", ({ params, body }) => {
  const prm = commentEditParamsSchema.parse(params);
  const bdy = commentBodySchema.parse(body);
  const comment = editComment(parseInt(prm.id), sanitizeHtml(bdy.body));
  return elements6.createElement(comment_item_default, {
    comment
  });
}).delete("/h/comments/:id", ({ params }) => {
  const prm = commentEditParamsSchema.parse(params);
  deleteComment(parseInt(prm.id));
  return "";
}).get("/h/comments/:id/item", ({ params }) => {
  const prm = commentEditParamsSchema.parse(params);
  const comment = comments.find((c) => c.id === parseInt(prm.id));
  return elements6.createElement(comment_item_default, {
    comment
  });
}).post("/", ({ body, set }) => {
  const res = commentSchema.safeParse(body);
  if (!res.success) {
    return elements6.createElement(comment_form_default, {
      isError: true
    });
  }
  addComment(sanitizeHtml(res.data.email), sanitizeHtml(res.data.body));
  set.headers["HX-Trigger"] = "new-comment-added";
  return elements6.createElement(comment_form_default, {
    isError: false
  });
}).listen(3000);
console.log(`\uD83E\uDD8A Elysia is running at ${app.server?.hostname}:${app.server?.port}`);
